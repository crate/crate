.. highlight:: psql
.. _sql_operators:

Operators and Expressions
=========================

Comparison Operators
--------------------

    ================  ==================================
    Operator          Description
    ================  ==================================
    <                 less than
    ----------------  ----------------------------------
    >                 greater than
    ----------------  ----------------------------------
    <=                less than or equal to
    ----------------  ----------------------------------
    >=                greater than or equal to
    ----------------  ----------------------------------
    =                 equal
    ----------------  ----------------------------------
    <>                not equal
    ----------------  ----------------------------------
    !=                not equal - same as <>
    ----------------  ----------------------------------
    like              matches a part of the given value
    ----------------  ----------------------------------
    ~                 regular expression match
    ----------------  ----------------------------------
    !~                negated regular expression match
    ----------------  ----------------------------------
    between           ``a BETWEEN x and y``:
                      shortcut for ``a >= x AND a <= y``
    ================  ==================================

.. _sql_dql_like:

``LIKE``
--------

CrateDB supports the `LIKE` operator. This operator can be used to query for
rows where only part of a columns value should match something. For example to
get all locations where the name starts with 'Ar' the following query can be
used::

    cr> select name from locations where name like 'Ar%' order by name asc;
    +-------------------+
    | name              |
    +-------------------+
    | Argabuthon        |
    | Arkintoofle Minor |
    +-------------------+
    SELECT 2 rows in set (... sec)

The following wildcard operators are available:

    == ========================================
    %  A substitute for zero or more characters
    _  A substitute for a single character
    == ========================================

The wildcard operators may be used at any point in the string literal. For
example a more complicated like clause could look like this::

    cr> select name from locations where name like '_r%a%' order by name asc;
    +------------+
    | name       |
    +------------+
    | Argabuthon |
    +------------+
    SELECT 1 row in set (... sec)

In order so search for the wildcard characters themselves it is possible to
escape them using a backslash::

    cr> select description from locations
    ... where description like '%\%' order by description asc;
    +-------------------------+
    | description             |
    +-------------------------+
    | The end of the Galaxy.% |
    +-------------------------+
    SELECT 1 row in set (... sec)

.. NOTE::

    Queries with a like clause can be quite slow. Especially if the like clause
    starts with a wildcard character. Because in that case CrateDB has to
    iterate over all rows and can't utilize the index. For better performance
    consider using a fulltext index.


.. _sql_dql_not:

``NOT``
-------

``NOT`` negates a boolean expression::

    [ NOT ] boolean_expression

The result type is boolean.

    ==========  ======
    expression  result
    ==========  ======
    true        false
    false       true
    null        null
    ==========  ======

.. WARNING::

   CrateDB handles the case of `NOT (NULL)` inconsistently. The above is only
   true when the `NOT` appears in a `SELECT` clause or a `WHERE` clause that
   operates on system tables. The result of `NOT (NULL)` in a `WHERE` clause
   that operates on user tables will produce inconsistent but deterministic
   results (`NULL` or `TRUE`) depending on the specifics of the clause. This
   does not adhere to standard SQL three-valued-logic and will be fixed in a
   future release.

.. _sql_dql_in:

``IN``
------

CrateDB also supports the binary operator ``IN``, which allows you to verify
the membership of left-hand operand in a right-hand set of expressions. Returns
``true`` if any evaluated expression value from a right-hand set equals
left-hand operand. Returns ``false`` otherwise::

    cr> select name, kind from locations
    ... where (kind in ('Star System', 'Planet'))  order by name asc;
     +---------------------+-------------+
     | name                | kind        |
     +---------------------+-------------+
     |                     | Planet      |
     | Aldebaran           | Star System |
     | Algol               | Star System |
     | Allosimanius Syneca | Planet      |
     | Alpha Centauri      | Star System |
     | Altair              | Star System |
     | Argabuthon          | Planet      |
     | Arkintoofle Minor   | Planet      |
     | Bartledan           | Planet      |
     +---------------------+-------------+
     SELECT 9 rows in set (... sec)

.. _sql_dql_is_null:

``IS NULL``
-----------

Returns ``TRUE`` if ``expr`` evaluates to ``NULL``. Given a column reference it
returns ``TRUE`` if the field contains ``NULL`` or is missing.

Use this predicate to check for ``NULL`` values as SQL's three-valued logic
does always return ``NULL`` when comparing ``NULL``.

:expr: expression of one of the supported :ref:`sql_ddl_datatypes` supported by
       CrateDB.

::

    cr> select name from locations where race is null order by name;
    +------------------------------------+
    | name                               |
    +------------------------------------+
    |                                    |
    | Aldebaran                          |
    | Algol                              |
    | Allosimanius Syneca                |
    | Alpha Centauri                     |
    | Altair                             |
    | Argabuthon                         |
    | Galactic Sector QQ7 Active J Gamma |
    | North West Ripple                  |
    | Outer Eastern Rim                  |
    | NULL                               |
    +------------------------------------+
    SELECT 11 rows in set (... sec)

::

    cr> select count(*) from locations where name is null;
    +----------+
    | count(*) |
    +----------+
    |        1 |
    +----------+
    SELECT 1 row in set (... sec)

.. _sql_dql_is_not_null:

``IS NOT NULL``
---------------

Returns ``TRUE`` if ``expr`` does not evaluate to ``NULL``. Additionally, for
column references it returns ``FALSE`` if the column does not exist.

Use this predicate to check for non-``NULL`` values as SQL's three-valued logic
does always return ``NULL`` when comparing ``NULL``.

:expr: expression of one of the supported :ref:`sql_ddl_datatypes` supported by
       CrateDB.

::

    cr> select name from locations where race['interests'] is not null;
    +-------------------+
    | name              |
    +-------------------+
    | Arkintoofle Minor |
    | Bartledan         |
    +-------------------+
    SELECT 2 rows in set (... sec)

::

    cr> select count(*) from locations where name is not null;
    +----------+
    | count(*) |
    +----------+
    |       12 |
    +----------+
    SELECT 1 row in set (... sec)

.. _sql_dql_any_array:

``ANY (array)``
---------------

The ANY (or SOME) operator allows to search for elements within arrays. This
allows to query for rows where an element of an array is, for example, equal to
or greater than some ``expression``.

The following example returns any row where the array ``race['interests']``
contains an element 'netball'::

    cr> select race['name'], race['interests'] from locations
    ... where 'netball' = ANY(race['interests']);
    +----------------+-----------------------------------------+
    | race['name']   | race['interests']                       |
    +----------------+-----------------------------------------+
    | Bartledannians | ["netball", "books with 100.000 words"] |
    +----------------+-----------------------------------------+
    SELECT 1 row in set (... sec)

::

    cr> select race['name'], race['interests'] from locations
    ... where 'books%' LIKE ANY(race['interests']);
    +----------------+-----------------------------------------+
    | race['name']   | race['interests']                       |
    +----------------+-----------------------------------------+
    | Bartledannians | ["netball", "books with 100.000 words"] |
    +----------------+-----------------------------------------+
    SELECT 1 row in set (... sec)

It can also be used on arrays::

    cr> select name, race['interests'] from locations
    ... where name = ANY(ARRAY['Bartledan', 'Algol'])
    ... order by name asc;
    +-----------+-----------------------------------------+
    | name      | race['interests']                       |
    +-----------+-----------------------------------------+
    | Algol     | NULL                                    |
    | Bartledan | ["netball", "books with 100.000 words"] |
    +-----------+-----------------------------------------+
    SELECT 2 rows in set (... sec)

This way it can be used as a shortcut for ``name = 'Bartledan' OR name =
'Algol'`` or any other ANY comparison.

Syntax of the ANY Operator:

.. code-block:: sql

    expression operator ANY | SOME (array)

The ANY operator allows to apply an ``operator`` on the elements of an
``array``. The ``expression`` is evaluated and compared to each element of the
array using the ``operator``. The comparison must yield a boolean result.

- The result of ANY is ``true`` if any comparison returns ``true``.

- The result of ANY is ``false`` if no comparison returns ``true``, or an
  array contains no elements.

- The result of ANY is ``NULL`` if either the expression or the array is null.
  The result is also null, if no ``true`` comparison is obtained and any
  element of the array is null.

.. NOTE::

    The following is not supported by the ANY operator:

    - 'is null' and 'is not null' as ``operator``.

    - Arrays of type object.

    - Objects as ``expressions``.

Negating ``ANY``
................

One important thing to notice when using ANY is that negating the ANY operator
does not behave as negating normal comparison operators.

The following query can be translated to *get all rows where race['interests']
has at least one element that equals 'netball'*::

    cr> select race['name'], race['interests'] from locations
    ... where 'netball' = ANY(race['interests']);
    +----------------+-----------------------------------------+
    | race['name']   | race['interests']                       |
    +----------------+-----------------------------------------+
    | Bartledannians | ["netball", "books with 100.000 words"] |
    +----------------+-----------------------------------------+
    SELECT 1 row in set (... sec)

The following query using the negated operator ``!=`` can be translated to *get
all rows where race['interests'] has at least one element that does not equal
'netball'*. As you see, the result is the same in this case::

    cr> select race['name'], race['interests'] from locations
    ... where 'netball' != ANY(race['interests']);
    +----------------+-----------------------------------------+
    | race['name']   | race['interests']                       |
    +----------------+-----------------------------------------+
    | Minories       | ["baseball", "short stories"]           |
    | Bartledannians | ["netball", "books with 100.000 words"] |
    +----------------+-----------------------------------------+
    SELECT 2 rows in set (... sec)

.. NOTE::

    When using the negated operator ``!= ANY`` by default the maximum size of
    the array to operate on is ``8192``. To be able to use larger arrays the
    :ref:`indices.query.bool.max_clause_count <conf-indices-query-bool.max_clause_count>`
    setting must be changed appropriately on each node.

Negating the ``=`` query from above is totally different. It can be translated
to *get all rows where race['interests'] has no value that equals 'netball'*::

    cr> select race['name'], race['interests'] from locations
    ... where not 'netball' = ANY(race['interests']) order by race['name'];
    +--------------+-------------------------------+
    | race['name'] | race['interests']             |
    +--------------+-------------------------------+
    | Minories     | ["baseball", "short stories"] |
    +--------------+-------------------------------+
    SELECT 1 row in set (... sec)

The same behaviour (though different comparison operations involved) holds true
for operators

 - ``LIKE`` and ``NOT LIKE``

 - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)

.. NOTE::

    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the
    maximum size of the array to operate on is ``8192``. To be able to use
    larger arrays the :ref:`indices.query.bool.max_clause_count <conf-indices-query-bool.max_clause_count>`
    setting must be changed appropriately on each node.


.. _sql_ddl_regexp:

Regular Expressions
-------------------

Operators for matching using regular expressions.

.. list-table::
   :widths: 5 20 15
   :header-rows: 1

   * - Operator
     - Description
     - Example
   * - ``~``
     - Matches regular expression, case sensitive
     - ::

         'foo' ~ '.*foo.*'
   * - ``~*``
     - Matches regular expression, case insensitive
     - ::

         'Foo' ~* '.*foo.*'
   * - ``!~``
     - Does not match regular expression, case sensitive
     - ::

         'Foo' !~ '.*foo.*'
   * - ``!~*``
     - Does not match regular expression, case insensitive
     - ::

         'foo' !~* '.*bar.*'

The ``~`` operator can be used to match a string against a regular expression.
It returns ``true`` if the string matches the pattern, ``false`` if not, and
``NULL`` if string is ``NULL``.

To negate the matching, use the optional ``!`` prefix. The operator returns
``true`` if the string does not match the pattern, ``false`` otherwise.

The regular expression pattern is implicitly anchored, that means that the
whole string must match, not a single subsequence. All unicode characters are
allowed.

If using `PCRE`_ features in the regular expression pattern, the operator uses
the regular expression engine of the Java standard library ``java.util.regex``.

If not using `PCRE`_ features in the regular expression pattern, the operator
uses `Lucene Regular Expressions`_, which are optimized for fast regular
expression matching on Lucene terms.

`Lucene Regular Expressions`_ are basically `POSIX Extended Regular
Expressions`_ without the character classes and with some extensions, like a
metacharacter ``#``  for the empty string or ``~`` for negation and others. By
default all Lucene extensions are enabled. See the Lucene documentation for
more details.

.. NOTE::

    Since case-insensitive matching using ``~*`` or ``!~*`` implicitly uses the
    regular expression engine of the Java standard library, features of `Lucene
    Regular Expressions`_ do not work there.

Examples::

    cr> select name from locations where name ~ '([A-Z][a-z0-9]+)+'
    ... order by name;
    +------------+
    | name       |
    +------------+
    | Aldebaran  |
    | Algol      |
    | Altair     |
    | Argabuthon |
    | Bartledan  |
    +------------+
    SELECT 5 rows in set (... sec)

::

    cr> select 'matches' from sys.cluster where
    ... 'gcc --std=c99 -Wall source.c' ~ '[A-Za-z0-9]+( (-|--)[A-Za-z0-9]+)*( [^ ]+)*';
    +-----------+
    | 'matches' |
    +-----------+
    | matches   |
    +-----------+
    SELECT 1 row in set (... sec)

::

    cr> select 'no_match' from sys.cluster where 'foobaz' !~ '(foo)?(bar)$';
    +------------+
    | 'no_match' |
    +------------+
    | no_match   |
    +------------+
    SELECT 1 row in set (... sec)

.. _Lucene Regular Expressions: http://lucene.apache.org/core/4_9_0/core/org/apache/lucene/util/automaton/RegExp.html
.. _POSIX Extended Regular Expressions: http://en.wikipedia.org/wiki/Regular_expression#POSIX_extended
.. _PCRE: https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions
