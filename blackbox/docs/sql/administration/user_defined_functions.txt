.. _sql_administration_udf:

User Defined Functions
======================

.. NOTE::

   The User Defined Functions is an experimental feature. It is disabled by default.
   You can enable the :ref:`conf_udf_enabled` via the CrateDB configuration file.

CREATE OR REPLACE
-----------------

CrateDB supports user-defined functions. See :ref:`ref-create-function`
for a full syntax description.

These functions can be created like this::

    cr> CREATE FUNCTION subtract(integer, integer)
    ...  RETURNS integer
    ...  LANGUAGE JAVASCRIPT
    ...  AS 'function subtract(a, b) { return a - b; }';
    CREATE OK, 1 row affected  (... sec)

.. hide:

    cr> _wait_for_function('subtract', 1)

::

    cr> SELECT subtract(3, 1);
    +----------------+
    | subtract(3, 1) |
    +----------------+
    |              2 |
    +----------------+
    SELECT 1 row in set (... sec)

``OR REPLACE`` can be used to replace an existing function::

    cr> CREATE OR REPLACE FUNCTION log10(long)
    ...  RETURNS double
    ...  LANGUAGE JAVASCRIPT
    ...  AS 'function log10(a) { return Math.log(a)/Math.log(10); }';
    CREATE OK, 1 row affected  (... sec)

.. hide:

    cr> _wait_for_function('log10', 1)

::

    cr> SELECT log10(10);
    +-----------+
    | log10(10) |
    +-----------+
    |       1.0 |
    +-----------+
    SELECT 1 row in set (... sec)

Arguments can be named in the function definition.

For example, if you wanted to name two ``geo_point`` arguments ``start_point`` and
``end_point`` you would do it like this::

    cr> CREATE OR REPLACE FUNCTION calculate_distance(start_point geo_point, end_point geo_point)
    ...  RETURNS float
    ...  LANGUAGE JAVASCRIPT
    ...  AS 'function calculate_distance(start_point, end_point){
    ...        return Math.sqrt( Math.pow(end_point[0] - start_point[0], 2), Math.pow(end_point[1] - start_point[1], 2));
    ...      }';
    CREATE OK, 1 row affected  (... sec)

.. hide:

    cr> _wait_for_function('calculate_distance', 1)

.. NOTE::

   Argument names are used for query documentation purposes only. You cannot
   reference arguments by name in the function body.

Optionally, you can specify a schema for the function. If you omit the schema,
the current session schema is used.

You can explicitly assign a schema like this::

    cr> CREATE OR REPLACE FUNCTION my_schema.log10(long)
    ...  RETURNS double
    ...  LANGUAGE JAVASCRIPT
    ...  AS 'function log10(a) { return Math.log(a)/Math.log(10); }';
    CREATE OK, 1 row affected  (... sec)

.. hide:

    cr> _wait_for_function('log10', 2)


Supported Types
---------------

The argument types, and the return type of the user-defined function can be
any of the CrateDB supported :ref:`sql_ddl_datatypes`. Data types of values
passed into a user-defined function must strictly correspond to its argument
data types.

.. NOTE::

   The value returned by the function will be casted to the return type
   provided in the definition if required. An exception will be thrown
   if the cast is not successful.


OVERLOADING
-----------

Within a specific schema, you can overload functions by defining two functions with the
same name that have a different set of arguments::

    cr> CREATE FUNCTION my_schema.multiply(integer, integer)
    ...  RETURNS integer
    ...  LANGUAGE JAVASCRIPT
    ...  AS 'function multiply(a, b) { return a * b; }';
    CREATE OK, 1 row affected  (... sec)

This would overload our ``multiply`` function with different argument types::

    cr> CREATE FUNCTION my_schema.multiply(long, long)
    ...  RETURNS long
    ...  LANGUAGE JAVASCRIPT
    ...  AS 'function multiply(a, b) { return a * b; }';
    CREATE OK, 1 row affected  (... sec)

This would overload our ``multiply`` function with more arguments::

    cr> CREATE FUNCTION my_schema.multiply(long, long, long)
    ...  RETURNS long
    ...  LANGUAGE JAVASCRIPT
    ...  AS 'function multiply(a, b, c) { return a * b * c; }';
    CREATE OK, 1 row affected  (... sec)

.. NOTE::

   It is considered bad practice to create functions that have the same name
   as the CrateDB built-in functions. If you call a function without a schema
   name, CrateDB will look up the builtin functions first and then the
   user-defined functions in the session schema. Therefore a built-in function
   with the same name as a user defined function will hide the latter. However,
   such user-defined functions can still be called if the schema name is explicitly provided.

.. hide:

    cr> _wait_for_function('multiply', 3)

Determinism
-----------

User-defined functions are considered deterministic, meaning that they will
always return the same result value when called with the same argument values.
These return values are then cached, preventing multiple function executions.


DROP FUNCTION
-------------

User defined functions can be dropped like this::

     cr> DROP FUNCTION log10(long);
     DROP OK, 1 row affected  (... sec)

Adding ``IF EXISTS`` prevents from raising an error if the function doesn't exist::

     cr> DROP FUNCTION IF EXISTS log10(integer);
     DROP OK, 1 row affected  (... sec)

Optionally, argument names can be specified within the drop statement::

     cr> DROP FUNCTION IF EXISTS calculate_distance(start_point geo_point, end_point geo_point);
     DROP OK, 1 row affected  (... sec)

Optionally, you can provide a schema::

     cr> DROP FUNCTION my_schema.log10(long);
     DROP OK, 1 row affected  (... sec)

Supported Languages
-------------------

JavaScript
..........

The current version of CrateDB supports ECMAScript 5.1.

Supported Types
...............

JavaScript user-defined functions can handle all CrateDB data types. However,
for some return types the user defined functions output must correspond to
the certain format.

If a user-defined function requires ``geo_point`` as a return type,
then the JavaScript function must return a ``double array`` of size 2,
``WKT`` string or ``GeoJson`` object.

Here is an example of a JavaScript function returning a ``double array``::

    cr> CREATE FUNCTION rotate_point(point geo_point, angle float)
    ...  RETURNS geo_point
    ...  LANGUAGE JAVASCRIPT
    ...  AS 'function rotate_point(point, angle) {
    ...        var cos = Math.cos(angle);
    ...        var sin = Math.sin(angle);
    ...        var x = cos * point[0] - sin * point[1];
    ...        var y = sin * point[0] + cos * point[1];
    ...        return [x, y];
    ...      }';
    CREATE OK, 1 row affected  (... sec)

.. hide:

    cr> _wait_for_function('rotate_point')

Below is an example of a JavaScript function returning a ``WKT`` string,
which will be casted to ``geo_point``::


     cr> CREATE FUNCTION symmetric_point(point geo_point)
     ...  RETURNS geo_point
     ...  LANGUAGE JAVASCRIPT
     ...  AS 'function(point, angle) {
     ...        var x = - point[0],
     ...            y = - point[1];
     ...        return "POINT (\" + x + \", \" + y +\")";
     ...      }';
     CREATE OK, 1 row affected  (... sec)

.. hide:

    cr> _wait_for_function('symmetric_point')

Similarly, if the function specifies the ``geo_shape`` return data type, then
the JavaScript function should return a ``GeoJson`` object or``WKT`` string::

     cr> CREATE FUNCTION line(start_point array(double), end_point array(double))
     ...  RETURNS object
     ...  LANGUAGE JAVASCRIPT
     ...  AS 'function line(start_point, end_point) {
     ...        return { "type": "LineString", "coordinates" : [start_point, end_point] };
     ...      }';
     CREATE OK, 1 row affected  (... sec)

.. hide:

    cr> _wait_for_function('line')

.. NOTE::

   If the return value of the JavaScript function is ``undefined`` it is converted
   to ``NULL``.


.. hide:

    cr> DROP FUNCTION subtract(integer, integer);
    DROP OK, 1 row affected  (... sec)

    cr> DROP FUNCTION my_schema.multiply(integer, integer);
    DROP OK, 1 row affected  (... sec)

    cr> DROP FUNCTION my_schema.multiply(long, long, long);
    DROP OK, 1 row affected  (... sec)

    cr> DROP FUNCTION my_schema.multiply(long, long);
    DROP OK, 1 row affected  (... sec)

    cr> DROP FUNCTION rotate_point(point geo_point, angle float);
    DROP OK, 1 row affected  (... sec)

    cr> DROP FUNCTION symmetric_point(point geo_point);
    DROP OK, 1 row affected  (... sec)

    cr> DROP FUNCTION line(start_point array(double), end_point array(double));
    DROP OK, 1 row affected  (... sec)
