.. highlight:: psql
.. _ref-create-table:

============
CREATE TABLE
============

Define a new table.

Synopsis
========

::

    CREATE TABLE [ IF NOT EXISTS ] table_ident ( [
        { column_name data_type [ column_constraint [ ... ] ] | table_constraint }
        [, ... ] ]
    )
    [ PARTITIONED BY (column_name [, ...] ) ]
    [ CLUSTERED [ BY (routing_column) ] INTO num_shards SHARDS ]
    [ WITH ( table_parameter [= value] [, ... ] ) ]


where ``column_constraint`` is::

    { PRIMARY KEY |
      INDEX { OFF | USING { PLAIN |
                            FULLTEXT [ WITH ( analyzer = analyzer_name ) ]  }
    }


and table_constraint is::

    { PRIMARY KEY ( column_name [, ... ] ) |
      INDEX index_name USING FULLTEXT ( column_name [, ... ] )
           [ WITH ( analyzer = analyzer_name ) ]
    }

Description
===========

CREATE TABLE will create a new, initially empty table.

If the table_ident does not contain a schema, the table is created in
the ``doc`` schema. Otherwise it is created in the given schema, which
is implicitly created, if it didn't exist yet.

The optional constraint clauses specify constraints (tests) that new
or updated rows must satisfy for an insert or update operation to
succeed. A constraint is an SQL object that helps define the set of
valid values in the table in various ways.

There are two ways to define constraints: table constraints and column
constraints. A column constraint is defined as part of a column
definition. A table constraint definition is not tied to a particular
column, and it can encompass more than one column. Every column
constraint can also be written as a table constraint; a column
constraint is only a notational convenience for use when the
constraint only affects one column.


Parameters
==========

:table_ident: The name (optionally schema-qualified) of the table to be
             created.

:column_name: The name of a column to be created in the new table.

:data_type: The data type of the column. This can include array and
    object specifiers. For more information on the data types
    supported by Crate see .


IF NOT EXISTS Clause
====================

If the optional IF NOT EXISTS clause is used this statement won't do anything
if the table exists already.

.. _primary_key_constraint:

PRIMARY KEY Constraint
======================

The PRIMARY KEY constraint specifies that a column or columns of a
table can contain only unique (non-duplicate), non-null values.

INDEX Constraint
================

The INDEX constraint specifies a specific index method on one or more
columns.

It is possible to define more than one index per table, whether as a
column constraint or a table constraint.

For further details about the meaning of the options see
:ref:`indices_and_fulltext`.

.. _ref_clustered_clause:

CLUSTERED Clause
================

The optional CLUSTERED clause specifies how a table should be
distributed accross a cluster.

:num_shards: specifies the number of shards a table is stored in.
    Must be greater than 0; the default is 5.

:routing_column: allows to explicitly specify a column or field on
    which basis rows are sharded. all rows having the same value in
    ``routing_column`` are stored in the same shard. The default is
    the primary key if specified, otherwise the internal ``_id``
    column.

.. _partitioned_by_clause:

PARTITIONED BY Clause
=====================

The PARTITIONED clause splits the created table
into separate partitions for every distinct combination of values
in the listed columns.

::

    [ PARTITIONED BY ( column_name [ , ... ] ) ]

:column_name: a column from the table definition this table gets partitioned by.

Several restrictions apply to columns that can be used here:

* columns may not be part of :ref:`ref_clustered_clause`.
* columns may not be of type array or inside an array (e.g. an object array).
* columns may not be of type object.
* columns may not be indexed with a :ref:`sql_ddl_index_fulltext`.
* if the table has a :ref:`primary_key_constraint` the columns in PARTITIONED clause have to be part of it


.. note:: Columns referenced in the PARTITIONED clause cannot be altered by an ``UPDATE`` statement.



.. _with_clause:

WITH Clause
-----------

The optional WITH clause can specify parameters for tables.

::

    [ WITH ( table_parameter [= value] [, ... ] ) ]


:table_parameter: specifies an optional parameter for the table.

Available parameters are:


.. _number_of_replicas:

number_of_replicas
~~~~~~~~~~~~~~~~~~

Specifies the number or range of replicas each shard of a table should
have for normal operation, the default is to have 1 replica.

The number of replicas is defined like this::

    min_replicas [ - [ max_replicas ] ]

:min_replicas: The minimum number of replicas required.

:max_replicas: The maximum number of replicas. The actual maximum
    number of replicas is max(num_replicas, N-1), where N is the
    number of data nodes in the cluster. If ``max_replicas`` is the
    string ``all`` then it will always be N.

For further details and examples see :ref:`replication`.

.. _sql_ref_refresh_interval:

refresh_interval
~~~~~~~~~~~~~~~~

Specifies the refresh interval of a shard in milliseconds. The default is set
to 1000 milliseconds.

:value: The refresh interval in milliseconds. A value of smaller or
    equal than 0 turns off the automatic refresh. A value of greater than 0
    schedules a periodic refresh of the table.

.. note::

    a ``refresh_interval`` of 0 does not guarantee that new writes are *NOT* visible to
    subsequent reads. Only the periodic refresh is disabled. There are other
    internal factors that might trigger a refresh.

For further details see :ref:`refresh_data` or :ref:`sql_ref_refresh`.

blocks.read_only
~~~~~~~~~~~~~~~~

Allows to have a read only table.

:value:  Table is read only if value set to ``true``. Allows writes and table settings changes if set to ``false``.

blocks.read
~~~~~~~~~~~

``disable``/``enable`` all the read operations

:value: Set to ``true`` to disable all read operations for a table, otherwise set ``false``.

blocks.write
~~~~~~~~~~~~

``disable``/``enable`` all the write operations

:value: Set to ``true`` to disable all write operations and table settings modifications, otherwise set ``false``.

blocks.metadata
~~~~~~~~~~~~~~~

``disable``/``enable`` the table settings modifications.

:values: Disables the table settings modifications if set to ``true``, if set to ``false`` â€” table settings modifications are enabled.

translog.flush_threshold_ops
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sets the number of operations before flushing.

:value: Number of operations prior to flushing.

translog.flush_threshold_size
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sets size of transaction log prior to flushing.

:value: Size (bytes) of translog.

translog.flush_threshold_period
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sets period of no flushing after which force flush occurs.

:value: Period length in milliseconds.

translog.disable_flush
~~~~~~~~~~~~~~~~~~~~~~

``enable``/``disable`` flushing.

:value: set ``true`` to disable flushing, otherwise set to ``false``.

.. note::

    It is recommended to use ``disable_flush`` only for short periods of time.

translog.interval
~~~~~~~~~~~~~~~~~

Sets frequency of flush necessity check.

:value: frequency in milliseconds.


gateway.local.sync
~~~~~~~~~~~~~~~~~~

How often the translog is fsynced to disk. Defaults to 5s

:value: interval in milliseconds.

allocation.total_shards_per_node
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Controls the total number of shards (replicas and primaries) allowed to be allocated on a single node. Defaults to unbounded (-1).

:value: number of shards per node.

allocation.enable
~~~~~~~~~~~~~~~~~

Controls shard allocation for a specific table. Can be set to:

:all: Allows shard allocation for all shards. (Default)

:primaries: Allows shard allocation only for primary shards.

:new_primaries: Allows shard allocation only for primary shards for new tables.

:none: No shard allocation allowed.

.. _initial_shards_ref:

recovery.initial_shards
~~~~~~~~~~~~~~~~~~~~~~~

When using local gateway a particular shard is recovered only if there can be allocated quorum of its copies in the cluster. It can be set to:

:value: ``quorum`` (default), ``quorum-1``, ``full``, ``full-1`` and number values (e.g. ``1``, ``2`` ...)

warming.enable
~~~~~~~~~~~~~~

``disable``/``enable`` table warming.
Table warming allows to run registered queries to warm up the table before it is available.
Enabled by default.

:value: ``true`` to enable warming up, otherwise ``false``

.. _sql_ref_column_policy:

gateway.local.sync
~~~~~~~~~~~~~~~~~~

How often the translog is ``fsync`` ed to disk.

:value: time in seconds of ``fsync`` period

column_policy
~~~~~~~~~~~~~

Specifies the column policy of the table. The default column policy is
``dynamic``.

The column policy is defined like this::

    WITH ( column_policy = {'dynamic' | 'strict'} )

:strict: Rejecting any column on insert, update or copy from which is not
    defined in the schema
:dynamic: New columns can be added using insert, update or copy from.
    New columns added to ``dynamic`` tables are, once added,
    usable as usual columns. One can retrieve them, sort by them
    and use them in where clauses.

For futher details and examples see :ref:`column_policy` or :ref:`configuration`.
