apply plugin: 'idea'
apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'de.thetaphi.forbiddenapis'
apply plugin: 'maven'

archivesBaseName = 'crate-sql'

// we do not want to have elasticsearch here, since we provide it in :es
configurations {
    all*.exclude group: 'org.elasticsearch'
    benchmarksCompile.extendsFrom testCompile
    benchmarksRuntime.extendsFrom testRuntime, benchmarksCompile
}

dependencies {
    compile project(':es')
    compile project(':core')
    compile project(':blob')
    compile project(':sql-parser')
    compile 'com.amazonaws:aws-java-sdk-s3:1.10.33'
    compile 'org.apache.commons:commons-math3:3.4.1'
    testCompile project(':testing')
    testCompile 'org.skyscreamer:jsonassert:1.2.0'
    testCompile 'org.powermock:powermock-module-junit4:1.6.1'
    testCompile ('org.powermock:powermock-api-mockito:1.6.1') {
        // includes hamcrest stuff
        exclude group: 'org.mockito', module: 'mockito-all'
    }
    testCompile 'org.hamcrest:hamcrest-all:1.3'
    benchmarksCompile 'com.carrotsearch:junit-benchmarks:0.7.2'
    benchmarksCompile 'com.h2database:h2:1.3.173'

}

buildscript {
    repositories {
        mavenCentral()
    }
}

test {
    testLogging.exceptionFormat = 'full'
    outputs.dir("$projectDir/data")

    // fix powermock issue - causing VerifyErrors being thrown
    // see: https://issues.jboss.org/browse/JASSIST-228
    jvmArgs '-XX:-UseSplitVerifier'

    jacoco.excludes = ["*Test*"]

    // make sure sources are first on classpath because we do override some class(es) (currently: lucene's AssertingLeafReader)
    classpath = sourceSets.main.output + sourceSets.test.output + configurations.testCompile
}

clean.dependsOn(cleanTest)

sourceSets {
    test {
        resources {
            srcDir 'src/test/java'
            include '**/*.Plugin'
            include '**/*.rst'
            include '**/*.json'
            include '**/*.gz'
            include '**/*.sql'
            include '**/*.html'
            include '**/*.jsonp'
        }
    }
    benchmarks {
        java {
            srcDir 'src/benchmarks/java'
            compileClasspath += main.output + test.output + configurations.benchmarksCompile
            runtimeClasspath += main.output + test.output + configurations.benchmarksRuntime
        }
    }
}

forbiddenApisMain {
    bundledSignatures = ['jdk-unsafe', 'jdk-deprecated']
    ignoreFailures = false
}

task benchmarks(type: Test) {
    description = "Run internal benchmarks"

    testClassesDir = project.sourceSets.benchmarks.output.classesDir

    // move lucene-test-framework to the beginning of the classpath
    def cp = project.sourceSets.benchmarks.runtimeClasspath
    def testFrameworkEntry = cp.find({it.name.contains("lucene-test-framework")})
    if (testFrameworkEntry != null) {
        cp = files(testFrameworkEntry) + cp.filter({ !it.name.contains("lucene-test-framework") })
    }
    classpath = cp
    def benchmark_dir = project.projectDir.path + '/reports/bench/'

    // Properties for JUnit Benchmarks
    systemProperty 'jub.consumers', 'CONSOLE,H2,XML'
    systemProperty 'jub.db.file', benchmark_dir + 'results-sql'
    systemProperty 'jub.xml.file', benchmark_dir + 'results-sql.xml'
    systemProperty 'jub.charts.dir', benchmark_dir

    // force run, see: http://gradle.1045684.n5.nabble.com/how-does-gradle-decide-when-to-run-tests-td3314172.html
    outputs.upToDateWhen { false }

    jacoco {
        enabled = false
    }
}

idea {
    module {
        testSourceDirs += file('src/benchmarks/java')
        // put additional dependencies on the classpath
        scopes.TEST.plus += [configurations.benchmarksCompile]
        scopes.TEST.plus += [configurations.benchmarksRuntime]
    }
}
