/**
 * Copyright 2011-2013 Akiban Technologies, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * SQL Parser Grammar.
 *
 * This grammar is derived from the one in Apache DB Derby (SVN revision 959991),
 * which descends through IBM and Informix from the original Cloudscape parser.
 * It has now been set up to stand on its own, somewhat
 * independent of any particular datbase engine.
 * 
 */

/* The original from which this derives bore the following: */

/*

   Derby - File org.apache.derby.impl.sql.compile.sqlgrammar.jj

   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to you under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/

options
{
    // Allow multiple instances.
    STATIC = false;
    // Keep things package protected; there is a public wrapper.
    SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
    // Next few needed to get a refinement of default stream that records token positions.
    UNICODE_INPUT = true;
    USER_CHAR_STREAM = true;
    TOKEN_EXTENDS = "BaseToken";
    COMMON_TOKEN_ACTION = true;
    TOKEN_MANAGER_USES_PARSER = true;
    // Some performance gain from this.
    CACHE_TOKENS = true;
    // Debugging normally off.
    DEBUG_PARSER = false;
    DEBUG_LOOKAHEAD = false;
    DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(SQLGrammar)

package org.cratedb.sql.parser.parser;

import org.cratedb.sql.parser.StandardException;
import org.cratedb.sql.parser.types.AliasInfo;
import org.cratedb.sql.parser.types.RoutineAliasInfo;
import org.cratedb.sql.parser.types.CharacterTypeAttributes;
import org.cratedb.sql.parser.types.DataTypeDescriptor;
import org.cratedb.sql.parser.types.TypeId;

import java.sql.ParameterMetaData;

import java.sql.Types;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.*;

class SQLGrammar
{

    /* SAVEPOINT variations */
    // TODO: I think these should be constants in the savepoint node. ***
    private static final int SAVEPOINT_UNIQUE = 0;
    private static final int SAVEPOINT_RETAIN_LOCKS = 1;
    private static final int SAVEPOINT_RETAIN_CURSORS = 2;
    private static final int SAVEPOINT_NCLAUSES = 3;
    
    /* Corresponding clauses for error messages. */
    private static final String[] SAVEPOINT_CLAUSE_NAMES = {
        "UNIQUE", "ON ROLLBACK RETAIN LOCKS", "ON ROLLBACK RETAIN CURSORS" 
    };

    /* Keep in synch with CreateAliasNode's index constants */
    private static final String[] ROUTINE_CLAUSE_NAMES = { null,
        "SPECIFIC",
        "RESULT SET",
        "LANGUAGE",
        "EXTERNAL NAME",
        "PARAMETER STYLE",
        "SQL",
        "DETERMINISTIC",
        "ON NULL INPUT",
        "RETURN TYPE",
        "EXTERNAL SECURITY",
        "AS",
    };

    /* Possible clauses to CREATE TEMPORARY TABLE. */
    private static final int TEMPORARY_TABLE_NOT_LOGGED = 0;
    private static final int TEMPORARY_TABLE_ON_COMMIT = 1;
    private static final int TEMPORARY_TABLE_ON_ROLLBACK = 2;
    private static final int TEMPORARY_TABLE_NCLAUSES = 3;

    /* Corresponding clauses for error messages. */
    private static final String[] TEMPORARY_TABLE_CLAUSE_NAMES = {
        "NOT LOGGED", "ON COMMIT", "ON ROLLBACK" 
    };

    /* Possible JOIN clauses. */
    private static final int JOIN_ON = 0;
    private static final int JOIN_USING = 1;
    private static final int JOIN_NCLAUSES = 2;

    /* Possible TABLE optional clauses. */
    private static final int OPTIONAL_TABLE_PROPERTIES = 0;
    private static final int OPTIONAL_TABLE_DERIVED_RCL = 1;
    private static final int OPTIONAL_TABLE_CORRELATION_NAME = 2;
    private static final int OPTIONAL_TABLE_MYSQL_INDEX_HINTS = 3;
    private static final int OPTIONAL_TABLE_NCLAUSES = 4;

    /* Possible CREATE SEQUENCE optional clauses. */
    private static final int SEQUENCE_DATA_TYPE = 0;
    private static final int SEQUENCE_START_WITH = 1;
    private static final int SEQUENCE_INCREMENT_BY = 2;
    private static final int SEQUENCE_MAX_VALUE = 3;
    private static final int SEQUENCE_MIN_VALUE = 4;
    private static final int SEQUENCE_CYCLE = 5;
    private static final int SEQUENCE_NCLAUSES = 6;

    /* Constants for set operator types. */
    private static final int NO_SET_OP = 0;
    private static final int UNION_OP = 1;
    private static final int UNION_ALL_OP = 2;
    private static final int EXCEPT_OP = 3;
    private static final int EXCEPT_ALL_OP = 4;
    private static final int INTERSECT_OP = 5;
    private static final int INTERSECT_ALL_OP = 6;

    /* The default length of a [VAR]CHAR or BIT if the length is omitted. */
    private static final int DEFAULT_STRING_COLUMN_LENGTH = 1;

    /* TODO: Is there any need for these limits? */
    public static final int MAX_DECIMAL_PRECISION_SCALE = TypeId.DECIMAL_PRECISION;
    public static final int DEFAULT_DECIMAL_PRECISION = TypeId.DEFAULT_DECIMAL_PRECISION;
    public static final int DEFAULT_DECIMAL_SCALE = TypeId.DEFAULT_DECIMAL_SCALE;
    public static final int MAX_FLOATINGPOINT_LITERAL_LENGTH = 30;

    /* Different kinds of string delimiters. */
    static final String SINGLEQUOTES = "\'\'";
    static final String DOUBLEQUOTES = "\"\"";
    static final String BACKQUOTES = "``";

    // TODO: Probably not right.
    static final String IBM_SYSTEM_FUN_SCHEMA_NAME = "SYSFUN";

    /**
     * The system authorization ID is defined by the SQL2003 spec as the grantor
     * of privileges to object owners.
     */
    public static final String SYSTEM_AUTHORIZATION_ID = "_SYSTEM";

    /**
     * The public authorization ID is defined by the SQL2003 spec as implying all users.
     */
    public static final String PUBLIC_AUTHORIZATION_ID = "PUBLIC";

    /* The owner / user-visible parser. */
    private SQLParserContext parserContext;
    
    /* Creator of AST nodes. */
    private NodeFactory nodeFactory;
    
    /* The statement being parsed. */
    private String statementSQLText;

    /* The number of the next ? parameter */
    private int parameterNumber;

    /* The list of ? parameters */
    private List<ParameterNode> parameterList;

    /* Remember if the last identifier or keyword was a delimited identifier.
         This is used for Java references. */
    private Boolean lastTokenDelimitedIdentifier = Boolean.FALSE,
                    nextToLastTokenDelimitedIdentifier = Boolean.FALSE;

    /* Remember the last token we got that was an identifier. */
    private Token lastIdentifierToken, nextToLastIdentifierToken;

    private DataTypeDescriptor getType(int type, int precision, int scale, int length)
            throws StandardException {
        return new DataTypeDescriptor(TypeId.getBuiltInTypeId(type),
                                      precision,
                                      scale,
                                      true, /* assume nullable for now, change it if not nullable */
                                      length);
    }

    private DataTypeDescriptor getJavaClassDataTypeDescriptor(TableName typeName) 
            throws StandardException {
        return new DataTypeDescriptor(TypeId.getUserDefinedTypeId(typeName.getSchemaName(),
                                                                  typeName.getTableName(),
                                                                  null),
                                      true);
    }

    private void forbidNextValueFor() {
        // TODO: Needed for bind phase.
    }

    /**
     * Check to see if the required claues have been added to a
     * procedure or function defintion.
     *   
     * @param clauses the array of declared clauses.
    */
    private void checkRequiredRoutineClause(Object[] clauses)
            throws StandardException {
        String language = (String)clauses[CreateAliasNode.LANGUAGE];
        if (language == null) {
            throw new StandardException("Missing required " + ROUTINE_CLAUSE_NAMES[CreateAliasNode.LANGUAGE]);
        }
        int[] required;
        if (language.equalsIgnoreCase("JAVA")) {
            required = new int[] {  
                CreateAliasNode.PARAMETER_STYLE, 
                CreateAliasNode.EXTERNAL_NAME
            };
        }
        else {
            required = new int[] {  
                CreateAliasNode.PARAMETER_STYLE, 
                CreateAliasNode.INLINE_DEFINITION
            };
        }
        for (int i = 0; i < required.length; i++) {
            int re = required[i];
            if (clauses[re] == null) {
                throw new StandardException("Missing required " + ROUTINE_CLAUSE_NAMES[re]);
            }
        }
    }

    /**
     * Remove first and last quotes and compress adjacent ones in the
     * middle.
     */
    // TODO: Need to support backslash escaping for compatible double-quoted string.
    // TODO: This looks pretty inefficient.
    private static String trimAndCompressQuotes(String source, String quotes, boolean backslash) {
        String result = source.substring(1, source.length() - 1);

        /* Find the first occurrence of adjacent quotes. */
        int index = result.indexOf(quotes);

        /* Replace each occurrence with a single quote and begin the
         * search for the next occurrence from where we left off.
         */
        while (index != -1) {
            result = result.substring(0, index + 1) + result.substring(index + 2);
            index = result.indexOf(quotes, index + 1);
        }

        return result;
    }

    private String sliceSQLText(int beginOffset, int endOffset, boolean trim) {
        // NOTE: endOffset is inclusive.
        String retval = statementSQLText.substring(beginOffset, endOffset + 1);
        
        if (trim)
            retval = retval.trim();
        
        return retval;
    }
 
    private String SQLToIdentifierCase(String s) {
        switch (parserContext.getIdentifierCase()) {
        case UPPER:
            // Always use the ENGLISH locale.
            return s.toUpperCase(Locale.ENGLISH);
        case LOWER:
            return s.toLowerCase(Locale.ENGLISH);
        case PRESERVE:
        default:
            return s;
        }
    }

    /** Is the given feature enabled for this parser? */
    public boolean hasFeature(SQLParserFeature feature) {
        return parserContext.hasFeature(feature);
    }

    /**
     * Is this token a date / time function name?
     */
    private static boolean isDATETIME(int tokKind) {
        if (tokKind == DATE || tokKind == TIME || tokKind == TIMESTAMP)
            return true;
        else
            return false;
    }

    /**
     * Determine whether the next sequence of tokens can be the beginning
     * of an aggregateNode()() rule.    aggregateNodes() start with one
     * of the built-in aggregate names, or with an identifier followed
     * by "( DISTINCT". A non-distinct user-defined aggregate invocation
     * is treated as a staticMethodInvocationAlias() by the parser,
     * and the binding phase figures out what it really is by looking
     * at the data dictionary.
     *
     * We check only for the punctuation here, because identifiers are
     * very hard to check for in semantic lookahead.
     *
     * @return TRUE iff the next set of tokens is the beginning of a aggregateNode()
     */
    private boolean aggregateFollows() {
        boolean retval = false;

        switch (getToken(1).kind) {
        case MAX:
        case AVG:
        case MIN:
        case SUM:
        case GROUP_CONCAT:
            // This is a built-in aggregate
            retval = true;
            break;

        case COUNT:
            // COUNT is not a reserved word
            // This may eclipse use of COUNT as a function or a procedure that is probably what we want
            if (getToken(2).kind == LEFT_PAREN)
                retval = true;
        default:
            // Not a built-in aggregate - assume the first token is an
            // identifier, and see whether it is followed by " ( DISTINCT "
            if (getToken(2).kind == LEFT_PAREN && getToken(3).kind == DISTINCT)
                retval = true;
            break;
        }

        return retval;
    }

    /**
     * Determine whether the next sequence of tokens can be the beginning of a
     * window or aggregate function.
     * @return TRUE iff the next set of tokens is the beginning of a
     *                          window or aggregate function
     */
    private boolean windowOrAggregateFunctionFollows() {
        boolean retval = false;

        switch (getToken(1).kind) {
        case ROWNUMBER:

        // case RANK:
        // case DENSE_RANK:
        // case PERCENT_RANK:
        // case CUME_DIST:

            retval = true;
            break;

        default:
            retval = aggregateFollows();
            break;
        }

        return retval;
    }

    private boolean divOperatorFollows() {
        if (!hasFeature(SQLParserFeature.DIV_OPERATOR))
            return false;
        return getToken(1).kind == DIV;
    }

    private boolean mysqlLeftRightFuncFollows() 
    {
        if (!hasFeature(SQLParserFeature.MYSQL_LEFT_RIGHT_FUNC))
            return false;

        switch(getToken(1).kind) 
        {
            case LEFT:
            case RIGHT:
                if (getToken(2).kind == LEFT_PAREN)
                    return true;
             
            default:
                return false;
        }
    }

    /**
     * Determine whether the next sequence of tokens can be the beginning
     * of a miscBuiltins().
     *
     * We check only for the punctuation here, because identifiers are
     * very hard to check for in semantic lookahead.
     *
     * @return TRUE iff the next set of tokens is the beginning of a aggregateNode()
     */
    private boolean miscBuiltinFollows() {
        boolean retval = false;
        int tokKind = getToken(1).kind;

        if (getToken(0).kind == CALL) 
            retval = true;

        switch (tokKind) {
        case GET_CURRENT_CONNECTION:
        case CURRENT_DATE:
        case CURRENT_TIME:
        case CURRENT_TIMESTAMP:
            retval = true;
            break;

        case CURRENT:
            if (isDATETIME(getToken(2).kind)) 
                retval = true;
            break;

        case CAST:
        case LEFT_PAREN:
            retval = false;
            break;

        default:
            if (getToken(2).kind == LEFT_PAREN)
                retval = true;
            break;
        }

        return retval;
    }

    /**
     * Determine whether the next tokens are a call to one of the
     * functions in miscBuiltinsCore().
     */
    private boolean miscBuiltinCoreFollows() {
        // NOTE: If you add rule to miscBuiltinsCore(), you must add the
        // appropriate token(s) here.
        switch (getToken(1).kind) {
        case LEFT:
        case RIGHT:
        case GET_CURRENT_CONNECTION:
        case ABS:
        case ABSVAL:
        case SQRT:
        case MOD:
        case COALESCE:
        case VALUE:
        case IDENTITY_VAL_LOCAL:
        case SUBSTRING:
        case SUBSTR:
        case UPPER:
        case LOWER:
        case UCASE:
        case LCASE:
        case LTRIM:
        case RTRIM:
        case TRIM:
        case DATE:
        case TIME:
        case TIMESTAMP:
        case TIMESTAMPADD:
        case TIMESTAMPDIFF:
        case DOUBLE:
        case CHAR:
        case VARCHAR:
        case INTEGER:
        case MEDIUMINT:
        case TINYINT:
        case INT:
        case SMALLINT:
        case LONGINT:
        case YEAR:
        case MONTH:
        case DAY:
        case HOUR:
        case MINUTE:
        case SECOND:
        case CHAR_LENGTH:
        case CHARACTER_LENGTH:
        case OCTET_LENGTH:
        case LENGTH:
        case LOCATE:
        case POSITION:
        case XMLPARSE:
        case XMLSERIALIZE:
        case XMLEXISTS:
        case XMLQUERY:
        case EXTRACT:
            break;
        default:
            return false;
        }
        return (getToken(2).kind == LEFT_PAREN);
    }

    /**
     * Determine whether the next sequence of tokens can be the beginning
     * of a subquery. A subquery can begin with an arbitrary number of
     * left parentheses, followed by either SELECT or VALUES.
     *
     * @return TRUE iff the next set of tokens is the beginning of a subquery.
     */
    private boolean subqueryFollows() {
        boolean retval = false;

        for (int i = 1; true; i++) {
            int tokKind = getToken(i).kind;
            if (tokKind == LEFT_PAREN) {
                // A subquery can start with an arbitrary number of left
                // parentheses.
                continue;
            }
            else if (tokKind == SELECT || tokKind == VALUES) {
                // If the first token we find after all the left parentheses
                // is SELECT or VALUES, it's a subquery.
                retval = true;
                break;
            }
            else {
                // If the first token we find after all the left parentheses
                // is neither SELECT nor VALUES, it's not a subquery.
                break;
            }
        }
        
        return retval;
    }

    /**
     * Check that an opening parenthese AND Subquery are the next tokens.
     * 
     * Identical to subqueryFollows(), but the function can't be used
     * because we don't want to discard the left paren before hand.
     * 
     */
    private boolean leftParenAndSubqueryFollows()
    {
        int i = 1;
        if (getToken(i++).kind != LEFT_PAREN)
            return false;

        for( ; true; ++i)
        {
            int tokKind = getToken(i).kind;
            if (tokKind == LEFT_PAREN) 
            {
                // A subquery can start with an arbitrary number of left
                // parentheses.
                continue;
            }
            else if (tokKind == SELECT || tokKind == VALUES)
            {
                // If the first token we find after all the left parentheses
                // is SELECT or VALUES, it's a subquery.
                return true;
            }
            else 
            {
                // If the first token we find after all the left parentheses
                // is neither SELECT nor VALUES, it's not a subquery.
                return false;
            }
        }
    }

    /**
     * Determine if we are seeing an offsetClause or the identifier OFFSET
     * (Derby does not make it a reserved word).    "n" must be an integer
     * literal or a dynamic parameter specification.
     *
     * @return true if it is an offsetClause.
     */
    private boolean seeingOffsetClause() {
        int nesting = 0;

        // Token number, i == 1: OFFSET
        int i = 2;

        int tokKind = getToken(i).kind;

        // check for integer literal or ? followed by ROW(S)
        if (tokKind == PLUS_SIGN ||
            tokKind == MINUS_SIGN) {

            tokKind = getToken(++i).kind;

            if (tokKind == EXACT_NUMERIC) {

                tokKind = getToken(++i).kind;

                return (tokKind == ROW ||
                                tokKind == ROWS);
            }
        } 
        else if (tokKind == EXACT_NUMERIC ||
                 tokKind == QUESTION_MARK) {

            tokKind = getToken(++i).kind;

            return (tokKind == ROW ||
                            tokKind == ROWS);
        }

        return false;
    }

    /**
     * Determine whether the next sequence of tokens can be the beginning
     * of a rowValueConstructorList. A rowValueConstructorList is a comma-
     * separated list of expressions enclosed in parentheses. This presents
     * special problems, because an expression be nested within an
     * arbitrary number of parentheses. To determine whether a left
     * parenthesis introduces a rowValueConstructorList or an expression,
     * we need to find the closing parenthesis, and determine whether
     * the next token is a comma.
     *
     * For example, the following is a rowValueConstructorList:
     *
     *  (((1)), 2)
     *
     * and the following is just an expression:
     *
     *  (((1)))
     *
     * @return TRUE iff the next set of tokens is the beginning of a subquery.
     */
    private boolean rowValueConstructorListFollows() {
        boolean retval = false;

        // A rowValueConstructorList starts with a left parenthesis
        if (getToken(1).kind == LEFT_PAREN) {
            // Keep track of the nesting of parens while looking ahead
            int nesting = 1;
            for (int i = 2; true; i++) {
                int tokKind = getToken(i).kind;

                // Special case for NULL/DEFAULT because they are not allowed in
                // a parenthesized expression, so (null)/(default) must be seen
                // as a rowValueConstructorList with one element.
                if (i == 2 && (tokKind == NULL || tokKind == _DEFAULT)) {
                    retval = true;
                    break;
                }

                // (SELECT ... ) shouldn't be considered a row-constructor
                if (tokKind == SELECT)
                    return false;

                // There must be a COMMA at nesting level 1 (i.e. outside of
                // the first expression) for it to be a rowValueConstructorList
                if (nesting == 1 && tokKind == COMMA) {
                    retval = true;
                    break;
                }

                // If we run out of tokens before finding the last closing
                // parenthesis, it's not a rowValueConstructorList (it's
                // probably a syntax error, in fact)
                if (tokKind == EOF) {
                    break;
                }

                // Increase the nesting for each (, and decrease it for each )
                if (tokKind == LEFT_PAREN) {
                    nesting++;
                }
                else if (tokKind == RIGHT_PAREN) {
                    nesting--;
                }

                // Don't look any farther than the last closing parenthesis
                if (nesting == 0) {
                    break;
                }
            }
        }

        return retval;
    }


    /**
     * Determine whether the next token is the beginning of a propertyList(). 
     * A properties list is the comment "--derby-properties" followed by a 
     * dot-separated list, followed by an =, followed by a value all on that 
     * comment line. This means that the comment should start with the word
     * "derby-properties".
     *
     * @return TRUE iff the next token is derby-properties 
     */
    private boolean derbyPropertiesListFollows() {
        return getToken(1).kind == DERBYDASHPROPERTIES;
    }

    /**
     * Determine whether the next sequence of tokens can be the beginning
     * of a newInvocation(). A newInvocation() begins with the word "new"
     * followed by a dot-separated list of identifiers, followed
     * by a left parenthesis.
     *
     * @param startToken Token to look for new at
     *
     * @return TRUE iff the next set of tokens is the beginning of a newInvocation().
     */
    private boolean newInvocationFollows(int startToken) {
        boolean retval = false;

        // newInvocation() starts with the word "new"
        if (getToken(startToken).kind == NEW) {
            // Look at every other token. Ignore the identifiers, because
            // they are hard to test for.
            for (int i = 2 + startToken; true; i += 2) {
                int tokKind = getToken(i).kind;

                // If we find a left parenthesis without any intervening
                // cruft, we have found a newInvocation()
                if (tokKind == LEFT_PAREN) {
                    retval = true;
                    break;
                }
                else if (tokKind != PERIOD) {
                    // Anything other than a PERIOD is "cruft"
                    break;
                }
            }
        }

        return retval;
    }

    /**
     * Determine whether the next sequence of tokens is a class name
     *
     * @return TRUE iff the next set of tokens is the Java class name
     */
    private boolean javaClassFollows() {
        boolean retval = false;

        // Look at every other token. Ignore the identifiers, because
        // they are hard to test for.
        for (int i = 2; true; i += 2) {
            int tokKind = getToken(i).kind;

            // If we find a '::' without any intervening
            // cruft, we have found a javaClass
            if (tokKind == DOUBLE_COLON) {
                retval = true;
                break;
            }
            else if (tokKind != PERIOD) {
                // Anything other than a PERIOD is "cruft"
                break;
            }
        }

        return retval;
    }

    /**
     * Determine whether the next sequence of tokens can be the beginning
     * of a FROM newInvocation(). A FROM newInvocation() begins with the words "from new"
     * followed by a dot-separated list of identifiers, followed
     * by a left parenthesis.
     *
     * @return TRUE iff the next set of tokens is the beginning of a FROM newInvocation().
     */
    private boolean fromNewInvocationFollows() {
        // FROM newInvocation() starts with the words "from new"
        return (getToken(1).kind == FROM && newInvocationFollows(2));
    }

    /**
     * Determine whether the next sequence of tokens can be the beginning
     * of a joinedTableExpression(). A joinedTableExpression() begins
     * with one of:
     *
     *  JOIN
     *  INNER JOIN
     *  CROSS JOIN
     *  LEFT OUTER JOIN
     *  RIGHT OUTER JOIN
     *  FULL OUTER JOIN
     *  NATURAL [ { RIGHT | LEFT } [ OUTER ] | INNER ] JOIN
     *
     * @return TRUE iff the next set of tokens is the beginning of a joinedTableExpression().
     */
    private boolean joinedTableExpressionFollows() {
        boolean retval = false;

        int tokKind1 = getToken(1).kind;
        int tokKind2 = getToken(2).kind;

        if (tokKind1 == JOIN) {
            retval = true;
        }
        else if (tokKind1 == INNER && tokKind2 == JOIN) {
            retval = true;
        }
        else if (tokKind1 == CROSS && tokKind2 == JOIN) {
            retval = true;
        }
        else if (tokKind1 == NATURAL) {
            retval = true;
        }
        else if ((tokKind1 == LEFT || tokKind1 == RIGHT || tokKind1 == FULL) && tokKind2 == OUTER) {
            if (getToken(3).kind == JOIN) {
                retval = true;
            }
        }
        else if ((tokKind1 == LEFT || tokKind1 == RIGHT || tokKind1 == FULL) && tokKind2 == JOIN) {
            retval = true;
        }
        else if (hasFeature(SQLParserFeature.MYSQL_HINTS) && tokKind1 == STRAIGHT_JOIN) {
            retval = true;
        }

        return retval;
    }

    /**
     * Determine whether the next sequence of tokens can be the beginning
     * of another element in a PROPERTY list. These elements are of the
     * form:
     *
     * COMMA dot.separated.list = ...
     *
     * Look for the COMMA, the dots in the dot-separated list, and the =
     *
     * @return TRUE iff the next set of tokens is the beginning of a 
     *                          another element in a PROPERTY list.
     */
    private boolean anotherPropertyFollows() {
        boolean retval = false;

        // Element must start with COMMA
        if (getToken(1).kind == COMMA) {
            // Rest of element is dot-separated list with = at end
            int i = 3;
            int tokKind;
            do {
                tokKind = getToken(i).kind;

                // If we've found nothing but PERIODs until the EQUALS_OPERATOR
                // it is the beginning of another property list element.
                if (tokKind == EQUALS_OPERATOR) {
                    retval = true;
                    break;
                }

                i += 2;
            } while (tokKind == PERIOD);
        }

        return retval;
    }

    private boolean ansiTrimSpecFollows() {
        switch (getToken(2).kind) {
        case LEADING:
        case TRAILING:
        case BOTH:
            return true;
        default:
            return false;
        }
    }
        
    /**
     * Determine whether the next sequence of tokens can be the beginning
     * of a remainingPredicate() rule.
     *
     * @return TRUE iff the next set of tokens is the beginning of a
     *               remainingPredicate()
     */
    private boolean remainingPredicateFollows() {
        boolean retval = false;

        switch (getToken(1).kind) {
        case EQUALS_OPERATOR:
        case NOT_EQUALS_OPERATOR:
        case NOT_EQUALS_OPERATOR2:
        case LESS_THAN_OPERATOR:
        case GREATER_THAN_OPERATOR:
        case LESS_THAN_OR_EQUALS_OPERATOR:
        case GREATER_THAN_OR_EQUALS_OPERATOR:
        case IN:
        case LIKE:
        case BETWEEN:
        case DUMMY:
            retval = true;
            break;

        case NOT:
            switch (getToken(2).kind) {
            case IN:
            case LIKE:
            case BETWEEN:
            case DUMMY:
                retval = true;
            }
            break;
        }

        return retval;
    }

    /**
     * Determine whether the next sequence of tokens can be the beginning
     * of a escapedValueFunction().
     *
     * We check only for the punctuation here, because identifiers are
     * very hard to check for in semantic lookahead.
     *
     * @return TRUE iff the next set of tokens is the beginning of a
     *               escapedValueFunction()
     */
    private boolean escapedValueFunctionFollows() {
        if (getToken(1).kind != LEFT_BRACE) {
            return false;
        }
        return getToken(2).kind == FN;
    }

    // TODO: Need to make this less dependent on engine.

    /**
     * List of JDBC escape functions that map directly onto a function
     * in the SYSFUN schema.
    */
    private static final String[] ESCAPED_SYSFUN_FUNCTIONS = {
        "ACOS", "ASIN", "ATAN", "ATAN2", "COS", "SIN", "TAN", "PI",
        "DEGREES", "RADIANS", "EXP", "LOG", "LOG10", "CEILING", "FLOOR",
        "SIGN", "RAND", "COT" 
    };
             
    /**
         Convert a JDBC escaped function name to a function
         name in the SYSFUN schema. Returns null if no such
         function exists.
    */  
    private String getEscapedSYSFUN(String name) {
        name = SQLToIdentifierCase(name);

        for (int i = 0; i < ESCAPED_SYSFUN_FUNCTIONS.length; i++) {
            if (ESCAPED_SYSFUN_FUNCTIONS[i].equals(name))
                return name;
        }
        return null;
    }

    /* Is this a keyword to GRANT / REVOKE. */
    private boolean isPrivilegeKeywordExceptTrigger(int tokenKind) {
        return (tokenKind == SELECT ||
                        tokenKind == DELETE ||
                        tokenKind == INSERT ||
                        tokenKind == UPDATE ||
                        tokenKind == REFERENCES ||
                        tokenKind == EXECUTE ||
                        tokenKind == USAGE ||
                        tokenKind == ALL);
    }

    /**
     * Determine whether the next sequence of tokens represents one of
     * the common (built-in) datatypes.
     *
     * @param checkFollowingToken true if additonal token for NATIONAL
     *              or LONG should be checked
     * @return TRUE iff the next set of tokens names a common datatype
     */
    private boolean commonDatatypeName(boolean checkFollowingToken) {
        return commonDatatypeName(1, checkFollowingToken);
    }

    /**
     * Determine whether the next sequence of tokens represents 
     * a datatype (could be a common datatype or a schema qualified UDT name).
     *
     * @return TRUE iff the next set of tokens names a datatype
     */
    private boolean dataTypeCheck(int start) {
        if (commonDatatypeName(start, false)) { 
            return true; 
        }

        boolean retval = true;

        switch (getToken(start).kind) {
        case COMMA:
        case LEFT_PAREN:
        case RIGHT_PAREN:
            retval = false;
            break;
        }

        return retval;
    }

    /**
     * Determine whether a sequence of tokens represents one of
     * the common (built-in) datatypes.
     *
     * @param checkFollowingToken true if additonal token for NATIONAL
     *              or LONG should be checked
     * @param start starting token index of the sequence
     * @return TRUE iff the next set of tokens names a common datatype
     */
    private boolean commonDatatypeName(int start, boolean checkFollowingToken) {
        boolean retval = false;

        switch (getToken(start).kind) {
        case CHARACTER:
        case CHAR:
        case VARCHAR:
        case NVARCHAR:
        case NCHAR:
        case BIT:
        case NUMERIC:
        case DECIMAL:
        case DEC:
        case INTEGER:
        case MEDIUMINT:
        case TINYINT:
        case INT:
        case SMALLINT:
        case LONGINT:
        case FLOAT:
        case REAL:
        case DATE:
        case TIME:
        case TIMESTAMP:
        case BOOLEAN:
        case DOUBLE:
        case BLOB:
        case CLOB:
        case NCLOB:
        case TEXT:
        case MEDIUMBLOB:
        case MEDIUMTEXT:
        case TINYBLOB:
        case TINYTEXT:
        case LONGBLOB:
        case LONGTEXT:
        case BINARY: // LARGE OBJECT
        case XML:
        case INTERVAL:
        case DATETIME:
        case YEAR:
            retval = true;
            break;

        case LONG:
            if (checkFollowingToken) {
                switch (getToken(start+1).kind) {
                case VARCHAR:
                case NVARCHAR:
                case BINARY:
                case VARBINARY:
                case BIT:
                    retval = true;
                    break;
                }
                break;
            }
            else {
                retval = true;
                break;
            }

        case NATIONAL:
            if (checkFollowingToken) {
                switch (getToken(start+1).kind) {
                case CHAR:
                case CHARACTER:
                    retval = true;
                    break;
                }
                break;
            }
            else {
                retval = true;
                break;
            }
        }

        return retval;
    }

    /*
     * Generate a multiplicative operator node, if necessary.
     *
     * If there are two operands, generate the multiplicative operator
     * that corresponds to the multiplicativeOperator parameter.    If there
     * is no left operand, just return the right operand.
     *
     * @param leftOperand The left operand, null if no operator
     * @param rightOperand The right operand
     * @param multiplicativeOperator An identifier from BinaryOperatorNode
     *              telling what operator to generate.
     *
     * @return The multiplicative operator, or the right operand if there is
     *              no operator.
     *
     * @exception StandardException Thrown on error
     */

    private ValueNode multOp(ValueNode leftOperand, ValueNode rightOperand,
                             BinaryOperatorNode.OperatorType multiplicativeOperator) 
            throws StandardException {
        if (leftOperand == null) {
            return rightOperand;
        }

        switch (multiplicativeOperator) {
        case MOD:
            return (ValueNode)nodeFactory.getNode(NodeTypes.MOD_OPERATOR_NODE,
                                                  leftOperand,
                                                  rightOperand,
                                                  parserContext);
        case TIMES:
            return (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_TIMES_OPERATOR_NODE,
                                                  leftOperand,
                                                  rightOperand,
                                                  parserContext);
        case DIV:
            return (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_DIV_OPERATOR_NODE,
                                                  leftOperand,
                                                  rightOperand,
                                                  parserContext);
        case DIVIDE:
            return (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_DIVIDE_OPERATOR_NODE,
                                                  leftOperand,
                                                  rightOperand,
                                                  parserContext);
        case CONCATENATE:
            return (ValueNode)nodeFactory.getNode(NodeTypes.CONCATENATION_OPERATOR_NODE,
                                                  leftOperand,
                                                  rightOperand,
                                                  parserContext);

        default:
            assert false : "Unexpected multiplicative operator " + multiplicativeOperator;
            return null;
        }
    }

    /**
     * Makes a new unnamed ParameterNode and chains it onto parameterList.
     *
     * @return the new unnamed parameter.
     *
     * @exception StandardException
     */
    private ParameterNode makeParameterNode(int number) throws StandardException {
        ParameterNode parm = (ParameterNode)
            nodeFactory.getNode(NodeTypes.PARAMETER_NODE,
                                number,
                                null,
                                parserContext);

        if (parameterList != null)
            parameterList.add(parm);
        return parm;
    }

    /**
     * Make string to be parsed from digits token and optional sign.
     */
    private String getNumericString(Token tok, String sign) {
        // Cannot just concatentate and parse because leading + is not
        // accepted by Java parsers. Cannot parse and negate because
        // Long.MIN_VALUE does not have a long negative.
        String num = tok.image;
        if ("-".equals(sign))
            num = sign.concat(num);
        return num;
    }

    /**
     * Translate a String containing a number into the appropriate type
     * of Numeric node.
     *
     * @param num the string containing the number
     * @param intsOnly accept only Integers (not Decimal)
     *
     * @exception Exception Thrown on error
     */
    NumericConstantNode getNumericNode(String num, boolean intsOnly) 
            throws StandardException {
        // First try Integer.
        try {
            return (NumericConstantNode)nodeFactory.getNode(NodeTypes.INT_CONSTANT_NODE,
                                                            new Integer(num),
                                                            parserContext);
        }
        catch (NumberFormatException nfe) {
        }

        // Then Long.
        try {
            return (NumericConstantNode)nodeFactory.getNode(NodeTypes.LONGINT_CONSTANT_NODE,
                                                            new Long(num),
                                                            parserContext);
        }
        catch (NumberFormatException nfe) {
            if (intsOnly) {
                throw nfe;
            }
        }

        // Then Decimal.
        return (NumericConstantNode)nodeFactory.getNode(NodeTypes.DECIMAL_CONSTANT_NODE,
                                                        num,
                                                        parserContext);
    }

    // TODO: Make this less dependent on implementation.

    /**
     * Translate a token for the name of a built-in aggregate to a String
     * containing an aggregate name.
     */
    private static String aggName(Token token) {
        String retval = null;

        switch (token.kind) {
        case MAX:
            retval = "MAX";
            break;

        case AVG:
            retval = "AVG";
            break;

        case MIN:
            retval = "MIN";
            break;

        case SUM:
            retval = "SUM";
            break;

        case COUNT:
            retval = "COUNT";
            break;

        case GROUP_CONCAT:
            retval = "GROUP_CONCAT";
            break;
        default:
            assert false : "Unexpected token type in aggName: " + token.kind;
            break;
        }

        return retval;
    }

    /**
     * Translate a token for the name of a built-in aggregate to an
     * aggregate definition class.
     */
    private static String aggClass(Token token) {
        String retval = null;

        switch (token.kind) {
        case MAX:
        case MIN:
            retval = "MaxMinAggregateDefinition";
            break;

        case AVG:
        case SUM:
            retval = "SumAvgAggregateDefinition";
            break;

        case COUNT:
            retval = "CountAggregateDefinition";
            break;

        case GROUP_CONCAT:
            retval = "GroupConcatAggregateDefinition";
            break;
        default:
            assert false : "Unexpected token type in aggClass: " + token.kind;
            break;
        }

        return retval;
    }

    /**
     * Get a DELETE node given the pieces.
     *
     * @exception StandardException
     */
    StatementNode getDeleteNode(FromTable fromTable, TableName tableName,
                                ValueNode whereClause,
                                ResultColumnList returningList)
            throws StandardException {
        FromList fromList = (FromList)nodeFactory.getNode(NodeTypes.FROM_LIST,
                                                          parserContext);

        fromList.addFromTable(fromTable);

        SelectNode resultSet = (SelectNode)nodeFactory.getNode(NodeTypes.SELECT_NODE,
                                                               null,
                                                               null, /* AGGREGATE list */
                                                               fromList, /* FROM list */
                                                               whereClause, /* WHERE clause */
                                                               null, /* GROUP BY list */
                                                               null, /* having clause */
                                                               null, /* window list */
                                                               parserContext);

        StatementNode retval = (StatementNode)nodeFactory.getNode(NodeTypes.DELETE_NODE,
                                                                  tableName,
                                                                  resultSet,
                                                                  returningList,
                                                                  parserContext);

        return retval;
    }
    
    /**
     * Get an UPDATE node given the pieces.
     *
     * @exception StandardException
     */
    StatementNode getUpdateNode(FromTable fromTable, TableName tableName,
                                ResultColumnList setClause, ValueNode whereClause, 
                                ResultColumnList returningList)
            throws StandardException {
        FromList fromList = (FromList)nodeFactory.getNode(NodeTypes.FROM_LIST,
                                                          parserContext);

        fromList.addFromTable(fromTable);

        SelectNode resultSet = (SelectNode)nodeFactory.getNode(NodeTypes.SELECT_NODE,
                                                               setClause,
                                                               null,
                                                               fromList, /* FROM list */
                                                               whereClause, /* WHERE clause */
                                                               null, /* GROUP BY list */
                                                               null, /* having clause */
                                                               null, /* window list */
                                                               parserContext);

        StatementNode retval =
            (StatementNode)nodeFactory.getNode(NodeTypes.UPDATE_NODE,
                                               tableName,
                                               resultSet,
                                               returningList,
                                               parserContext);

        return retval;
    }

    /**
     * Generate a trim operator node
     * @param trimSpec one of Leading, Trailing or Both.
     * @param trimChar the character to trim. Can be null in which case it defaults
     * to ' '.
     * @param trimSource expression to be trimmed.
     */
    ValueNode getTrimOperatorNode(BinaryOperatorNode.OperatorType trimType,
                                  ValueNode trimChar,
                                  ValueNode trimSource) 
            throws StandardException {
        if (trimChar == null) {
            trimChar = (CharConstantNode)nodeFactory.getNode(NodeTypes.CHAR_CONSTANT_NODE,
                                                             " ",
                                                             parserContext);
        }
        return (ValueNode)nodeFactory.getNode(NodeTypes.TRIM_OPERATOR_NODE,
                                              trimSource, // left
                                              trimChar,   // right
                                              trimType,
                                              parserContext);
    }

    /**
     * Get one of the several types of create alias nodes.
     *
     * @param aliasName The name of the alias
     * @param fullStaticMethodName The full path/method name
     * @param aliasSpecificInfo Information specific to the type of alias being created.
     * @param aliasType The type of alias to create
     *
     * @return A CreateAliasNode matching the given parameters
     *
     * @exception StandardException Thrown on error
     */
    StatementNode getCreateAliasNode(Object aliasName, String fullStaticMethodName,
                                     Object aliasSpecificInfo, AliasInfo.Type aliasType,
                                     Boolean createOrReplace)
            throws StandardException {

        StatementNode aliasNode = (StatementNode)
            nodeFactory.getCreateAliasNode(aliasName,
                                           fullStaticMethodName,
                                           aliasSpecificInfo,
                                           aliasType,
                                           createOrReplace,
                                           parserContext);

        return aliasNode;
    }

    /** Create a node for the drop alias/procedure call. */
    StatementNode dropAliasNode(TableName aliasName, AliasInfo.Type type, ExistenceCheck cond) throws StandardException {

        StatementNode stmt = (StatementNode)nodeFactory.getNode(NodeTypes.DROP_ALIAS_NODE,
                                                                aliasName,
                                                                type,
                                                                cond,
                                                                parserContext);

        return stmt;
    }

    /**
     * Get a substring node from
     *          - the string
     *          - the start position
     *          - the length
     *          - a boolean values for specifying the kind of substring function
     * @exception StandardException  Thrown on error
     */
    ValueNode getSubstringNode(ValueNode stringValue, ValueNode startPosition,
                               ValueNode length, Boolean boolVal) 
            throws StandardException {
        return (ValueNode)nodeFactory.getNode(NodeTypes.SUBSTRING_OPERATOR_NODE,
                                              stringValue,
                                              startPosition,
                                              length,
                                              TernaryOperatorNode.OperatorType.SUBSTRING,
                                              null,
                                              parserContext);
    }

    ValueNode getJdbcIntervalNode(int intervalType) throws StandardException {
        return (ValueNode)nodeFactory.getNode(NodeTypes.INT_CONSTANT_NODE,
                                              intervalType,
                                              parserContext);
    }

    /**
     * Construct a TableElementNode of type
     * NodeTypes.MODIFY_COLUMN_DEFAULT_NODE.
     *
     * @param defaultNode the new default value node
     * @param columnName    the name of the column to be altered
     * @param autoIncrementInfo autoincrement information collected, if any.
     *
     * @return the new node constructed
     * @exception StandardException standard error policy
     */
    TableElementNode wrapAlterColumnDefaultValue(ValueNode defaultNode,
                                                 String columnName,
                                                 long[] autoIncrementInfo) 
            throws StandardException {

        if (autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] == 0) {
            autoIncrementInfo = null;
        }
        return (TableElementNode)nodeFactory.getNode(NodeTypes.MODIFY_COLUMN_DEFAULT_NODE,
                                                     columnName,
                                                     defaultNode,
                                                     null,
                                                     autoIncrementInfo,
                                                     parserContext);
    }

    /**
     * Construct a new join node.
     *
     * @param leftRSN the left side of the join
     * @param rightRSN the right side of the join
     * @param onClause the ON clause, or null if there is no ON clause
     * @param usingClause the USING clause, or null if there is no USING clause
     * @param joinType the type of the join (one of the constants INNERJOIN,
     *        LEFTOUTERJOIN or RIGHTOUTERJOIN in JoinNode)
     * @return a new join node
     */
    private JoinNode newJoinNode(ResultSetNode leftRSN, ResultSetNode rightRSN,
                                 ValueNode onClause, ResultColumnList usingClause,
                                 JoinNode.JoinType joinType)
            throws StandardException {
        switch(joinType) {
        case INNER:
            return (JoinNode)nodeFactory.getNode(NodeTypes.JOIN_NODE,
                                                 leftRSN,
                                                 rightRSN,
                                                 onClause,
                                                 usingClause,
                                                 null,
                                                 null,
                                                 null,
                                                 parserContext);

        case LEFT_OUTER:
            return (JoinNode)nodeFactory.getNode(NodeTypes.HALF_OUTER_JOIN_NODE,
                                                 leftRSN,
                                                 rightRSN,
                                                 onClause,
                                                 usingClause,
                                                 Boolean.FALSE,
                                                 null,
                                                 parserContext);

        case RIGHT_OUTER:
            return (JoinNode)nodeFactory.getNode(NodeTypes.HALF_OUTER_JOIN_NODE,
                                                 leftRSN,
                                                 rightRSN,
                                                 onClause,
                                                 usingClause,
                                                 Boolean.TRUE,
                                                 null,
                                                 parserContext);

        case FULL_OUTER:
            return (JoinNode)nodeFactory.getNode(NodeTypes.FULL_OUTER_JOIN_NODE,
                                                 leftRSN,
                                                 rightRSN,
                                                 onClause,
                                                 usingClause,
                                                 null,
                                                 parserContext);

        case STRAIGHT:
            {
                Properties joinOrderStrategyProperties = new Properties();
                joinOrderStrategyProperties.setProperty("STRAIGHT", "TRUE");
                return (JoinNode)nodeFactory.getNode(NodeTypes.JOIN_NODE,
                                                     leftRSN,
                                                     rightRSN,
                                                     onClause,
                                                     usingClause,
                                                     null,
                                                     null,
                                                     joinOrderStrategyProperties,
                                                     parserContext);
            }

        default:
            assert false : "Unexpected joinType: " + joinType;
            return null;
        }
    }

    // TODO: What is this about?
    private boolean isTableValueConstructor(ResultSetNode expression) {
        return expression instanceof RowResultSetNode ||
            (expression instanceof UnionNode && ((UnionNode)expression).tableConstructor());
    }

    /* Common default argument pattern. */
    TableName qualifiedName() throws ParseException, StandardException {
        return qualifiedName(NodeTypes.TABLE_NAME);
    }

    ValueNode additiveExpression() throws ParseException, StandardException {
        return additiveExpression(null, null);
    }

    boolean groupConstructFollows(int tokenKind) {
        return hasFeature(SQLParserFeature.GROUPING) &&
            getToken(1).kind == tokenKind;
    }

    boolean unsignedFollows() {
        return hasFeature(SQLParserFeature.UNSIGNED) &&
            getToken(1).kind == UNSIGNED;
    }

    boolean indexHintFollows(int offset) {
        if (!hasFeature(SQLParserFeature.MYSQL_HINTS))
            return false;
        int kind1 = getToken(offset).kind;
        int kind2 = getToken(offset+1).kind;
        return (((kind1 == USE) || (kind1 == IGNORE) || (kind1 == FORCE)) &&
                ((kind2 == INDEX) || (kind2 == KEY)));
    }

    boolean straightJoinFollows() {
        return hasFeature(SQLParserFeature.MYSQL_HINTS) &&
            getToken(1).kind == STRAIGHT_JOIN;
    }

    boolean infixModFollows() {
        if (!hasFeature(SQLParserFeature.INFIX_MOD))
            return false;
        switch(getToken(1).kind) {
        case MOD:
        case PERCENT:   return true;
        default:        return false;
        }
    }

    boolean parensFollow()
    {
        if (!hasFeature(SQLParserFeature.MYSQL_COLUMN_AS_FUNCS))
           return false;

        if (getToken(1).kind == LEFT_PAREN && getToken(2).kind == RIGHT_PAREN)
            return true;
        return false;
    }

    boolean infixBitFollows() {
        if (!hasFeature(SQLParserFeature.INFIX_BIT_OPERATORS))
            return false;
        switch(getToken(1).kind) {
        case AMPERSAND:
        case VERTICAL_BAR:
        case CARET:
        case DOUBLE_LESS:
        case DOUBLE_GREATER:
            return true;
        default:
            return false;
        }
    }

    boolean unaryBitFollows() {
        if (!hasFeature(SQLParserFeature.INFIX_BIT_OPERATORS))
            return false;
        switch(getToken(1).kind) {
        case TILDE:
            return true;
        default:        
            return false;
        }
    }

    // This LOOKAHEAD is required because a + or - sign can come
    // before any expression, and also can be part of a literal. If it
    // comes before a number, we want it to be considered part of the
    // literal, because the literal() rule knows how to handle the
    // minimum value for an int without changing it to a long.
    boolean unaryArithmeticFollows() {
        switch (getToken(1).kind) {
        case PLUS_SIGN:
        case MINUS_SIGN:
            break;
        default:
            return false;
        }
        switch (getToken(2).kind) {
        case EXACT_NUMERIC:
        case APPROXIMATE_NUMERIC:
            return false;
        default:
            return true;
        }
    }

    boolean simpleLiteralInListFollows() {
        int tkpos = 1;
        switch (getToken(tkpos).kind) {
        case SINGLEQUOTED_STRING:
        case EXACT_NUMERIC:
        case APPROXIMATE_NUMERIC:
        case TRUE:
        case FALSE:
        case NULL:
        case HEX_STRING:
            break;
        case DATE:
        case TIME:
        case TIMESTAMP:
            tkpos++;
            switch (getToken(tkpos).kind) {
            case SINGLEQUOTED_STRING:
                break;
            default:
                return false;
            }
            break;
        case PLUS_SIGN:
        case MINUS_SIGN:
            tkpos++;
            switch (getToken(tkpos).kind) {
            case EXACT_NUMERIC:
            case APPROXIMATE_NUMERIC:
                break;
            default:
                return false;
            }
            break;
        default:
            return false;
        }
        tkpos++;
        switch (getToken(tkpos).kind) {
        case COMMA:
        case RIGHT_PAREN:
            break;
        default:
            return false;
        }
        return true;
    }

    boolean mysqlIntervalFollows() {
        if (!hasFeature(SQLParserFeature.MYSQL_INTERVAL))
            return false;
        switch (getToken(1).kind) {
        case MICROSECOND:
        case WEEK:
        case QUARTER:
        case SECOND_MICROSECOND:
        case MINUTE_MICROSECOND:
        case MINUTE_SECOND:
        case HOUR_MICROSECOND:
        case HOUR_SECOND:
        case HOUR_MINUTE:
        case DAY_MICROSECOND:
        case DAY_SECOND:
        case DAY_MINUTE:
        case DAY_HOUR:
        case YEAR_MONTH:
            return true;
        default:
            return false;
        }
    }

    /**
     * check if the next token  is an alter-table action
     * (ie., ADD, DROP, ALTER, UPDATE, RENAME
     */
    boolean notAlterActionFollows()
    {
        switch(getToken(1).kind)
        {
            case ADD:
            case DROP:
            case ALTER:
            case UPDATE:
            case RENAME:
                return false;
            default:
                return true;
         }
    }

    void setParserContext(SQLParserContext parserContext) {
        this.parserContext = parserContext;
        this.nodeFactory = parserContext.getNodeFactory();
    }

    StatementNode parseStatement(String statementSQLText, 
                                 List<ParameterNode> parameterList)
            throws ParseException, StandardException {
        this.statementSQLText = statementSQLText;
        this.parameterList = parameterList;
        this.parameterNumber = 0;
        return Statement();
    }

    List<StatementNode> parseStatements(String statementSQLText)
            throws ParseException, StandardException {
        List<StatementNode> result = new ArrayList<StatementNode>();
        this.statementSQLText = statementSQLText;
        StatementList(result);
        return result;
    }
}

PARSER_END(SQLGrammar)

TOKEN_MGR_DECLS :
{
    void CommonTokenAction(Token t) {
        t.beginOffset = input_stream.getBeginOffset();
        t.endOffset = input_stream.getEndOffset();
    }

    int commentNestingDepth = 0;
}

SKIP :
{ /* white space */
    " "
| "\t"
| "\n"
| "\r"
}

MORE :
{
    "/*" : IN_BRACKETED_COMMENT
}

<IN_BRACKETED_COMMENT> MORE :
{
    "/*" { commentNestingDepth = 1; } : IN_NESTED_BRACKETED_COMMENT
}

<IN_BRACKETED_COMMENT> SKIP :
{
    "*/" : DEFAULT
}

<IN_NESTED_BRACKETED_COMMENT> MORE :
{
    "/*" { commentNestingDepth++; }
}

<IN_NESTED_BRACKETED_COMMENT> MORE :
{
    "*/"
    { commentNestingDepth--; SwitchTo(commentNestingDepth == 0 ? IN_BRACKETED_COMMENT : IN_NESTED_BRACKETED_COMMENT); }
}

<IN_BRACKETED_COMMENT,IN_NESTED_BRACKETED_COMMENT> MORE :
{
    < ~[] >
}

SKIP :
{ /* comments */
    "--" : IN_COMMENT
}

<IN_COMMENT> SKIP :
{ /* white space */
    " "
| "\t"
}

    /* Check if the comment characters -- are followed by DERBY-PROPERTIES token. 
     *
     * If yes, then this comment is providing user-supplied optimizer
     * overrides. There should be keyname=value [,keyname=value] pairs after
     * -- DERBY-PROPERTIES otherwise throw an exception. These optimier
     * overrides should be used in correct context only, otherwise, the
     * parser will throw an exception.
     *
     * If this comment does not start with DERBY-PROPERTOIES, then it is just
     * a regular comment. Skip the comment and move on to the next line.
     */
<IN_COMMENT> MORE [IGNORE_CASE]:
{
    "D" : LOOKFOR_DE
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_D : (~["D"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DE> MORE [IGNORE_CASE]:
{
    "E" : LOOKFOR_DER
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DE : (~["E"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DER> MORE [IGNORE_CASE]:
{
    "R" : LOOKFOR_DERB
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DER : (~["R"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERB> MORE [IGNORE_CASE]:
{
    "B" : LOOKFOR_DERBY
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERB : (~["B"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBY> MORE [IGNORE_CASE]:
{
    "Y" : LOOKFOR_DERBYDASH
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBY : (~["Y"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASH> MORE [IGNORE_CASE]:
{
    "-" : LOOKFOR_DERBYDASHP
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBYDASH : (~["-"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHP> MORE [IGNORE_CASE]:
{
    "P" : LOOKFOR_DERBYDASHPR
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBYDASHP : (~["P"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPR> MORE [IGNORE_CASE]:
{
    "R" : LOOKFOR_DERBYDASHPRO
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBYDASHPR : (~["R"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPRO> MORE [IGNORE_CASE]:
{
    "O" : LOOKFOR_DERBYDASHPROP
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBYDASHPRO : (~["O"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROP> MORE [IGNORE_CASE]:
{
    "P" : LOOKFOR_DERBYDASHPROPE
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBYDASHPROP : (~["P"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPE> MORE [IGNORE_CASE]:
{
    "E" : LOOKFOR_DERBYDASHPROPER
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBYDASHPROPE : (~["E"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPER> MORE [IGNORE_CASE]:
{
    "R" : LOOKFOR_DERBYDASHPROPERT
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBYDASHPROPER : (~["R"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPERT> MORE [IGNORE_CASE]:
{
    "T" : LOOKFOR_DERBYDASHPROPERTI
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBYDASHPROPERT : (~["T"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPERTI> MORE [IGNORE_CASE]:
{
    "I" : LOOKFOR_DERBYDASHPROPERTIE
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBYDASHPROPERTI : (~["I"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPERTIE> MORE [IGNORE_CASE]:
{
    "E" : LOOKFOR_DERBYDASHPROPERTIES
|
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_DERBYDASHPROPERTIE : (~["E"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPERTIES> TOKEN [IGNORE_CASE] :
{        
    <DERBYDASHPROPERTIES : "DERBYDASHPROPERTIES"> 
}

    /*
     * Once we find comment starting with -- DERBY-PROPERTIES, we want
     * to switch from SKIP mode to the TOKEN mode in the parser so the
     * rest of the characters on the comment line can be treated as part
     * of one big token so we can get keyname=value pairs from that
     * token. The reason for treating them as one big token is that the
     * existing code in parser allows newline characters between
     * individual token but with optimizer overrides, all the properties
     * have to be specified on the -- DERBY-PROPERTIES comment line.
     */
<LOOKFOR_DERBYDASHPROPERTIES> TOKEN [IGNORE_CASE]:
{
    "S" { matchedToken.kind = DERBYDASHPROPERTIES; } : PROPERTIES_LIST
}

// We found -- DERBY-PROPERTIE? where ? is a character other than S
// and hence we should the rest of the characters on this line as a
// regular comment
<LOOKFOR_DERBYDASHPROPERTIES> SKIP :
{
    <("\n"|"\r"|"\r\n")?> : DEFAULT
|
    <NOT_PROPERTIES : (~["S","s"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<IT_IS_NOT_DERBYPROPERTIES_COMMENT> SKIP :
{
    <SINGLE_LINE_SQLCOMMENT: (~["\n","\r"])* ("\n"|"\r"|"\r\n")?> : DEFAULT
}

// Found -- DERBY-PROPERTIES. 
// Treat rest of the characters on the line as one big token and then
// fetch keyname=value pairs from that token.
<PROPERTIES_LIST> TOKEN :
{
    <CHECK_PROPERTIES: (~["\n","\r"])* ("\n"|"\r"|"\r\n")?> : DEFAULT
}

/* This list should contain only and all SQL92 keywords that are
 * reserved.    Reserved keywords can be used as identifiers in the
 * language only as delimited identifiers.
 */
/* LOCAL is not a reserved word as most other databases do not enforce it. 
 * LOCAL is not used at all in this grammar.
 */
// NOTE: If you add a keyword, then you must add it to reservedKeyword() as well.
TOKEN [IGNORE_CASE] :
{ /* SQL92 reserved Keywords */
  <ADD: "add">
| <ALL: "all">
| <ALLOCATE: "allocate">
| <ALTER: "alter">
| <AND: "and">
| <ANY: "any">
| <ARE: "are">
| <AS: "as">
| <ASC: "asc">
| <ASSERTION: "assertion">
| <AT: "at">
| <AUTHORIZATION: "authorization">
| <AVG: "avg">
| <BEGIN: "begin">
| <BETWEEN: "between">
| <BINARY: "binary">
| <BIT: "bit">
| <BOTH: "both">
| <BY: "by">
| <CASCADE: "cascade">
| <CASCADED: "cascaded">
| <CASE: "case">
| <CAST: "cast">
| <CHAR: "char">
| <CHARACTER: "character">
| <CHARACTER_LENGTH: "character_length">
| <CHAR_LENGTH: "char_length">
| <CHECK: "check">
| <CLOSE: "close">
| <COALESCE: "coalesce">
| <COLLATE: "collate">
| <COLLATION: "collation">
| <COLUMN: "column">
| <COMMIT: "commit">
| <CONNECT: "connect">
| <CONNECTION: "connection">
| <CONSTRAINT: "constraint">
| <CONSTRAINTS: "constraints">
| <CONTINUE: "continue">
| <CONVERT: "convert">
| <CORRESPONDING: "corresponding">
| <COUNT: "count">
| <CREATE: "create">
| <CROSS: "cross">
| <CURRENT: "current">
| <CURRENT_DATE: "current_date">
| <CURRENT_TIME: "current_time">
| <CURRENT_TIMESTAMP: "current_timestamp">
| <CURRENT_USER: "current_user">
| <CURSOR: "cursor">
| <D: "d">
| <DEALLOCATE: "deallocate">
| <DEC: "dec">
| <DECIMAL: "decimal">
| <DECLARE: "declare">
| <_DEFAULT: "default">
| <DEFERRABLE: "deferrable">
| <DEFERRED: "deferred">
| <DELETE: "delete">
| <DESC: "desc">
| <DESCRIBE: "describe">
| <DIAGNOSTICS: "diagnostics">
| <DISCONNECT: "disconnect">
| <DISTINCT: "distinct">
| <DOUBLE: "double">
| <DROP: "drop">
| <ELSE: "else">
| <END: "end">
| <ENDEXEC: "end-exec">
| <ESCAPE: "escape">
| <EXCEPT: "except">
| <EXCEPTION: "exception">
| <EXEC: "exec">
| <EXECUTE: "execute">
| <EXISTS: "exists">
| <EXTERNAL: "external">
| <FALSE: "false">
| <FETCH: "fetch">
| <FIRST: "first">
| <FLOAT: "float">
| <FOR: "for">
| <FOREIGN: "foreign">
| <FOUND: "found">
| <FROM: "from">
| <FULL: "full">
| <FUNCTION: "function">
| <GET: "get">
| <GLOBAL: "global">
| <GO: "go">
| <GOTO: "goto">
| <GRANT: "grant">
| <GROUP: "group">
| <GROUP_CONCAT: "group_concat">
| <HAVING: "having">
| <HOUR: "hour">
| <IDENTITY: "identity">
| <IF: "if">
| <IMMEDIATE: "immediate">
| <IN: "in">
| <INDEX: "index">
| <INDICATOR: "indicator">
| <INITIALLY: "initially">
| <INNER: "inner">
| <INPUT: "input">
| <INSENSITIVE: "insensitive">
| <INSERT: "insert">
| <INT: "int">
| <INTEGER: "integer">
| <INTERSECT: "intersect">
| <INTO: "into">
| <IS: "is">
| <ISOLATION: "isolation">
| <JOIN: "join">
| <KEY: "key">
| <LAST: "last">
| <LEADING: "leading">
| <LEFT: "left">
| <LIKE: "like">
| <LOWER: "lower">
| <MATCH: "match">
| <MAX: "max">
| <MIN: "min">
| <MINUTE: "minute">
| <MODULE: "module">
| <NATIONAL: "national">
| <NATURAL: "natural">
| <NCHAR: "nchar">
| <NEXT: "next">
| <NO: "no">
| <NOT: "not">
| <NULL: "null">
| <NULLIF: "nullif">
| <NUMERIC: "numeric">
| <OCTET_LENGTH: "octet_length">
| <OF: "of">
| <ON: "on">
| <ONLY: "only">
| <OPEN: "open">
| <OPTION: "option">
| <OR: "or">
| <ORDER: "order">
| <OUTER: "outer">
| <OUTPUT: "output">
| <OVERLAPS: "overlaps">
| <PAD: "pad">
| <PARTIAL: "partial">
| <PARTITION: "partition">
| <PREPARE: "prepare">
| <PRESERVE: "preserve">
| <PRIMARY: "primary">
| <PRIOR: "prior">
| <PRIVILEGES: "privileges">
| <PROCEDURE: "procedure">
| <PUBLIC: "public">
| <READ: "read">
| <REAL: "real">
| <REFERENCES: "references">
| <RELATIVE: "relative">
| <RESTRICT: "restrict">
| <REVOKE: "revoke">
| <RIGHT: "right">
| <ROLLBACK: "rollback">
| <ROWS: "rows">
| <SCHEMA: "schema">
| <SCROLL: "scroll">
| <SECOND: "second">
| <SELECT: "select">
| <SESSION: "session">
| <SESSION_USER: "session_user">
| <SET: "set">
| <SMALLINT: "smallint">
| <SOME: "some">
| <SPACE: "space">
| <SQL: "sql">
| <SQLCODE: "sqlcode">
| <SQLERROR: "sqlerror">
| <SQLSTATE: "sqlstate">
| <SUBSTRING: "substring">
| <SUM: "sum">
| <SYSTEM_USER: "system_user">
| <T: "t">
| <TABLE: "table">
| <TEMPORARY: "temporary">
| <TIMEZONE_HOUR: "timezone_hour">
| <TIMEZONE_MINUTE: "timezone_minute">
| <TO: "to">
| <TRANSACTION: "transaction">
| <TRANSLATE: "translate">
| <TRANSLATION: "translation">
| <TRAILING: "trailing">
| <TRIM: "trim">
| <TRUE: "true">
| <TS: "ts">
| <UNION: "union">
| <UNIQUE: "unique">
| <UNKNOWN: "unknown">
| <UPDATE: "update">
| <UPPER: "upper">
| <USER: "user">
| <USING: "using">
| <VALUE: "value">
| <VALUES: "values">
| <VARBINARY: "varbinary">
| <VARCHAR: "varchar">
| <VARYING: "varying">
| <VIEW: "view">
| <WHENEVER: "whenever">
| <WHERE: "where">
| <WINDOW: "window">
| <WITH: "with">
| <WORK: "work">
| <WRITE: "write">
| <YEAR: "year">
}

/* This list should contain only and all SQL92 keywords that are
 * non-reserved.    Non-reserved keywords can be used as identifiers in
 * the language.
 */
// NOTE: If you add a keyword, then you must add it to nonReservedKeyword() as well.
TOKEN [IGNORE_CASE] :
{ /* SQL92 non-reserved Keywords */
  <ABS: "abs">
| <ABSVAL: "absval">
| <ACTION: "action">
| <ALWAYS: "always">
| <BLOB: "blob">
| <C: "c">
| <CALLED: "called">
| <CHARACTERISTICS: "characteristics">
| <CLOB: "clob">
| <COBOL: "cobol">
| <COMMITTED: "committed">
| <CONCAT: "concat">
| <CONTAINS: "contains">
| <CYCLE: "cycle">
| <DATA: "data">
| <DATE: "date">
| <DATETIME: "datetime">
| <DAY: "day">
| <DEFINER: "definer">
| <DETERMINISTIC: "deterministic">
| <DIV: "div">
| <DUMMY: "dummy">
| <DYNAMIC: "dynamic">
| <EXTRACT: "extract">
| <FORTRAN: "fortran">
| <GENERATED: "generated">
| <IDENTITY_VAL_LOCAL: "identity_val_local">
| <INCREMENT: "increment">
| <INITIAL: "initial">
| <INOUT: "inout">
| <INTERVAL: "interval">
| <INVOKER: "invoker">
| <LANGUAGE: "language">
| <LARGE: "large">
| <LENGTH: "length">
| <LEVEL: "level">
| <LOCKS: "locks">
| <LOCKSIZE: "locksize">
| <LOGGED: "logged">
| <MAXVALUE: "maxvalue">
| <MINVALUE: "minvalue">
| <MOD: "mod">
| <MODIFIES: "modifies">
| <MODIFY: "modify">
| <MONTH: "month">
| <_MORE: "more">
| <MUMPS: "mumps">
| <NAME: "name">
| <NCLOB: "nclob">
| <NULLABLE: "nullable">
| <NULLS: "nulls">
| <NUMBER: "number">
| <OBJECT: "object">
| <OFFSET: "offset">
| <PASCAL: "pascal">
| <PLI: "pli">
| <POSITION: "position">
| <PRECISION: "precision">
| <RELEASE: "release">
| <REPEATABLE: "repeatable">
| <RESTART: "restart">
| <RETURNS: "returns">
| <ROLLUP: "rollup">
| <ROW: "row">
| <SAVEPOINT: "savepoint">
| <SCALE: "scale">
| <SECURITY: "security">
| <SEPARATOR: "separator">
| <SERIALIZABLE: "serializable">
| <SQL_TSI_FRAC_SECOND: "sql_tsi_frac_second">
| <SQL_TSI_SECOND: "sql_tsi_second">
| <SQL_TSI_MINUTE: "sql_tsi_minute">
| <SQL_TSI_HOUR: "sql_tsi_hour">
| <SQL_TSI_DAY: "sql_tsi_day">
| <SQL_TSI_WEEK: "sql_tsi_week">
| <SQL_TSI_MONTH: "sql_tsi_month">
| <SQL_TSI_QUARTER: "sql_tsi_quarter">
| <SQL_TSI_YEAR: "sql_tsi_year">
| <START: "start">
| <STATEMENT: "statement">
| <SYNONYM: "synonym">
| <THEN: "then">
| <TIME: "time">
| <TIMESTAMP: "timestamp">
| <TIMESTAMPADD: "timestampadd">
| <TIMESTAMPDIFF: "timestampdiff">
| <TRUNCATE: "truncate">
| <TYPE: "type">
| <UNCOMMITTED: "uncommitted">
| <USAGE: "usage">
| <WHEN: "when">
}

/* This list should contain non-SQL92 keywords that are reserved.
 *
 * NOTE: XML, XMLPARSE, XMLSERIALIZE, and XMLEXISTS are considered
 * reserved words to comply with the SQL/XML (2003) standard, section
 * 5.1.  Similarly, XMLQUERY is a reserved word per SQL/XML (2006).
 */
// NOTE: If you add a keyword, then you must add it to reservedKeyword() as well.
TOKEN [IGNORE_CASE] :
{ /* Additional non-SQL92 reserved keywords */
  <BOOLEAN: "boolean">
| <CALL: "call">
| <CURDATE: "curdate">
| <CURRENT_ROLE: "current_role">
| <CURRENT_SCHEMA: "current_schema">
| <CURTIME: "curtime">
| <DATABASE: "database">
| <GET_CURRENT_CONNECTION: "getCurrentConnection">
| <GROUPING: "grouping">
| <EXPLAIN: "explain">
| <LIMIT: "limit">
| <LONG: "long">
| <LTRIM: "ltrim">
| <NONE: "none">
| <OVER: "over">
| <RETURNING: "returning">
| <ROLE: "role">
| <ROWNUMBER: "row_number">
| <RTRIM: "rtrim">
| <STRAIGHT_JOIN: "straight_join">
| <SUBSTR:  "substr">
| <XML:  "xml">
| <XMLEXISTS:    "xmlexists">
| <XMLPARSE:    "xmlparse">
| <XMLQUERY:    "xmlquery">
| <XMLSERIALIZE:    "xmlserialize">
| <Z_ORDER_LAT_LON: "z_order_lat_lon">
}

/* This list should contain non-SQL92 keywords that are not reserved.
 *
 * NOTE: CONTENT, DOCUMENT, STRIP, WHITESPACE and PASSING are
 * considered NON- reserved words to comply with the SQL/XML (2003)
 * standard, section 5.1.    Similarly, EMPTY, RETURNING, and SEQUENCE
 * are all considered NON-reserved words per SQL/XML (2006).    PRESERVE
 * is also listed as non-reserved in the SQL/XML spec, but since that
 * word is already reserved, we leave it alone.
 */
// NOTE: If you add a keyword, then you must add it to nonReservedKeyword() as well.
TOKEN [IGNORE_CASE] :
{ /* Additional non-SQL92 non-reserved keywords */
  <AFTER: "after">
| <BEFORE: "before">
| <BRIEF: "brief">
| <BTREE: "btree">
| <CLASS: "class">
| <COMPRESS: "compress">
| <CONTENT: "content">
| <COPY: "copy">
| <CS: "cs">
| <CSV: "csv">
| <CURSORS: "cursors">
| <DAY_HOUR: "day_hour">
| <DAY_MICROSECOND: "day_microsecond">
| <DAY_MINUTE: "day_minute">
| <DAY_SECOND: "day_second">
| <DB2SQL: "db2sql">
| <DEFRAGMENT: "defragment">
| <DELIMITER: "delimiter">
| <DIRTY: "dirty">
| <DOCUMENT: "document">
| <EACH: "each">
| <EMPTY: "empty">
| <ENCODING: "encoding">
| <EXCLUSIVE: "exclusive">
| <FN: "fn">
| <FORCE: "force">
| <FORMAT: "format">
| <FULL_TEXT: "full_text">
| <HEADER: "header">
| <HOUR_MICROSECOND: "hour_microsecond">
| <HOUR_MINUTE: "hour_minute">
| <HOUR_SECOND: "hour_second">
| <IGNORE: "ignore">
| <IN_MEMORY: "in_memory">
| <INPLACE: "inplace">
| <INTERRUPT: "interrupt">
| <JAVA: "java">
| <KILL: "kill">
| <LCASE: "lcase">
| <LOCATE: "locate">
| <LOCK: "lock">
| <LONGBLOB: "longblob">
| <LONGINT: "bigint">
| <LONGTEXT: "longtext">
| <MEDIUMBLOB: "mediumblob">
| <MEDIUMINT: "mediumint">
| <MEDIUMTEXT: "mediumtext">
| <MESSAGE_LOCALE: "message_locale">
| <METHOD: "method">
| <MICROSECOND: "microsecond">
| <MINUTE_MICROSECOND: "minute_microsecond">
| <MINUTE_SECOND: "minute_second">
| <MODE: "mode">
| <MYSQL_DUMP: "mysql_dump">
| <NEW: "new">
| <NEW_TABLE: "new_table">
| <NVARCHAR: "nvarchar"> 
| <OFF: "off">
| <OJ: "oj">
| <OLD: "old">
| <OLD_TABLE: "old_table">
| <OUT: "out">
| <PARAMETER: "parameter">
| <PASSING: "passing">
| <PROPERTIES: "properties">
| <PURGE: "purge">
| <QUARTER: "quarter">
| <_QUOTE: "quote">
| <READS: "reads">
| <REF: "ref">
| <REFERENCING: "referencing">
| <RENAME: "rename">
| <REPLACE: "replace">
| <RESET: "reset">
| <RESULT: "result">
| <RETAIN: "retain">
| <RR: "rr">
| <RS: "rs">
| <SECOND_MICROSECOND: "second_microsecond">
| <SERVER: "server">
| <SEQUENCE: "sequence">
| <SEQUENTIAL: "sequential">
| <SETS: "sets">
| <SHARE: "share">
| <SHUTDOWN: "shutdown">
| <SPECIFIC: "specific">
| <SQLID: "sqlid">
| <SQRT: "sqrt">
| <STABILITY: "stability">
| <STATISTICS: "statistics">
| <STDIN: "stdin">
| <STDOUT: "stdout">
| <STRIP: "strip">
| <STYLE: "style">
| <TEXT:  "text">
| <TINYBLOB: "tinyblob">
| <TINYINT: "tinyint">
| <TINYTEXT: "tinytext">
| <TRIGGER: "trigger">
| <TRUNCATE_END: "truncate_end">
| <UCASE: "ucase">
| <UNSIGNED: "unsigned">
| <UR: "ur">
| <USE: "use">
| <VERBOSE: "verbose">
| <WEEK: "week">
| <WHITESPACE: "whitespace">
| <YEAR_MONTH: "year_month">
}

TOKEN :
{ /* Operators and punctuation */
  <PERCENT: "%">
| <AMPERSAND: "&">
| <CARET: "^">
| <VERTICAL_BAR: "|">
| <TILDE: "~">
| <QUOTE: "'">
| <LEFT_BRACE: "{">
| <RIGHT_BRACE: "}">
| <LEFT_PAREN: "(">
| <RIGHT_PAREN: ")">
| <ASTERISK: "*">
| <PLUS_SIGN: "+">
| <COMMA: ",">
| <MINUS_SIGN: "-">
| <PERIOD: ".">
| <SOLIDUS: "/">
| <COLON: ":">
| <DOUBLE_COLON: "::">
| <SEMICOLON: ";">
| <LESS_THAN_OPERATOR: "<">
| <LESS_THAN_OR_EQUALS_OPERATOR: "<=">
| <EQUALS_OPERATOR: "=">
| <NOT_EQUALS_OPERATOR: "<>">
| <NOT_EQUALS_OPERATOR2: "!=">
| <GREATER_THAN_OPERATOR: ">">
| <GREATER_THAN_OR_EQUALS_OPERATOR: ">=">
| <QUESTION_MARK: "?">
| <UNDERSCORE: "_">
| <LEFT_BRACKET: "[">
| <RIGHT_BRACKET: "]">
| <DOUBLE_LESS: "<<">
| <DOUBLE_GREATER: ">>">
| <FIELD_REFERENCE: "->">
| <ASTERISK_ASTERISK: "**">
}

TOKEN :
{
  <CONCATENATION_OPERATOR: "||"> 
  { if (parser.hasFeature(SQLParserFeature.INFIX_LOGICAL_OPERATORS))
        matchedToken.kind = OR; }
| <DOUBLE_AMPERSAND: "&&">
  { if (parser.hasFeature(SQLParserFeature.INFIX_LOGICAL_OPERATORS))
        matchedToken.kind = AND; }
}

TOKEN :
{ /* Identifiers */
 <IDENTIFIER: ( <LETTER> ) (<LETTER> | "_" | <DIGIT>)* >
}

TOKEN :
{ /* Postgres-style parameters */
 <DOLLAR_N: ( "$" (<DIGIT>)+ ) >
}

// TODO: These are not used. Are they necessary to bare use work?
TOKEN: { <K: "K" > }
TOKEN: { <M: "M" > }
TOKEN: { <G: "G" > }

TOKEN:
{
    <#LETTER: [
                   "a"-"z",
                   "A"-"Z",
                   "\u00aa",
                   "\u00b5",
                   "\u00ba",
                   "\u00c0" - "\u00d6",
                   "\u00d8" - "\u00f6",
                   "\u00f8" - "\u01f5",
                   "\u01fa" - "\u0217",
                   "\u0250" - "\u02a8",
                   "\u02b0" - "\u02b8",
                   "\u02bb" - "\u02c1",
                   "\u02d0" - "\u02d1",
                   "\u02e0" - "\u02e4",
                   "\u037a",
                   "\u0386",
                   "\u0388" - "\u038a",
                   "\u038c",
                   "\u038e" - "\u03a1",
                   "\u03a3" - "\u03ce",
                   "\u03d0" - "\u03d6",
                   "\u03da",
                   "\u03dc",
                   "\u03de",
                   "\u03e0",
                   "\u03e2" - "\u03f3",
                   "\u0401" - "\u040c",
                   "\u040e" - "\u044f",
                   "\u0451" - "\u045c",
                   "\u045e" - "\u0481",
                   "\u0490" - "\u04c4",
                   "\u04c7" - "\u04c8",
                   "\u04cb" - "\u04cc",
                   "\u04d0" - "\u04eb",
                   "\u04ee" - "\u04f5",
                   "\u04f8" - "\u04f9",
                   "\u0531" - "\u0556",
                   "\u0559",
                   "\u0561" - "\u0587",
                   "\u05d0" - "\u05ea",
                   "\u05f0" - "\u05f2",
                   "\u0621" - "\u063a",
                   "\u0640" - "\u064a",
                   "\u0671" - "\u06b7",
                   "\u06ba" - "\u06be",
                   "\u06c0" - "\u06ce",
                   "\u06d0" - "\u06d3",
                   "\u06d5",
                   "\u06e5" - "\u06e6",
                   "\u0905" - "\u0939",
                   "\u093d",
                   "\u0958" - "\u0961",
                   "\u0985" - "\u098c",
                   "\u098f" - "\u0990",
                   "\u0993" - "\u09a8",
                   "\u09aa" - "\u09b0",
                   "\u09b2",
                   "\u09b6" - "\u09b9",
                   "\u09dc" - "\u09dd",
                   "\u09df" - "\u09e1",
                   "\u09f0" - "\u09f1",
                   "\u0a05" - "\u0a0a",
                   "\u0a0f" - "\u0a10",
                   "\u0a13" - "\u0a28",
                   "\u0a2a" - "\u0a30",
                   "\u0a32" - "\u0a33",
                   "\u0a35" - "\u0a36",
                   "\u0a38" - "\u0a39",
                   "\u0a59" - "\u0a5c",
                   "\u0a5e",
                   "\u0a72" - "\u0a74",
                   "\u0a85" - "\u0a8b",
                   "\u0a8d",
                   "\u0a8f" - "\u0a91",
                   "\u0a93" - "\u0aa8",
                   "\u0aaa" - "\u0ab0",
                   "\u0ab2" - "\u0ab3",
                   "\u0ab5" - "\u0ab9",
                   "\u0abd",
                   "\u0ae0",
                   "\u0b05" - "\u0b0c",
                   "\u0b0f" - "\u0b10",
                   "\u0b13" - "\u0b28",
                   "\u0b2a" - "\u0b30",
                   "\u0b32" - "\u0b33",
                   "\u0b36" - "\u0b39",
                   "\u0b3d",
                   "\u0b5c" - "\u0b5d",
                   "\u0b5f" - "\u0b61",
                   "\u0b85" - "\u0b8a",
                   "\u0b8e" - "\u0b90",
                   "\u0b92" - "\u0b95",
                   "\u0b99" - "\u0b9a",
                   "\u0b9c",
                   "\u0b9e" - "\u0b9f",
                   "\u0ba3" - "\u0ba4",
                   "\u0ba8" - "\u0baa",
                   "\u0bae" - "\u0bb5",
                   "\u0bb7" - "\u0bb9",
                   "\u0c05" - "\u0c0c",
                   "\u0c0e" - "\u0c10",
                   "\u0c12" - "\u0c28",
                   "\u0c2a" - "\u0c33",
                   "\u0c35" - "\u0c39",
                   "\u0c60" - "\u0c61",
                   "\u0c85" - "\u0c8c",
                   "\u0c8e" - "\u0c90",
                   "\u0c92" - "\u0ca8",
                   "\u0caa" - "\u0cb3",
                   "\u0cb5" - "\u0cb9",
                   "\u0cde",
                   "\u0ce0" - "\u0ce1",
                   "\u0d05" - "\u0d0c",
                   "\u0d0e" - "\u0d10",
                   "\u0d12" - "\u0d28",
                   "\u0d2a" - "\u0d39",
                   "\u0d60" - "\u0d61",
                   "\u0e01" - "\u0e2e",
                   "\u0e30",
                   "\u0e32" - "\u0e33",
                   "\u0e40" - "\u0e46",
                   "\u0e81" - "\u0e82",
                   "\u0e84",
                   "\u0e87" - "\u0e88",
                   "\u0e8a",
                   "\u0e8d",
                   "\u0e94" - "\u0e97",
                   "\u0e99" - "\u0e9f",
                   "\u0ea1" - "\u0ea3",
                   "\u0ea5",
                   "\u0ea7",
                   "\u0eaa" - "\u0eab",
                   "\u0ead" - "\u0eae",
                   "\u0eb0",
                   "\u0eb2" - "\u0eb3",
                   "\u0ebd",
                   "\u0ec0" - "\u0ec4",
                   "\u0ec6",
                   "\u0edc" - "\u0edd",
                   "\u0f40" - "\u0f47",
                   "\u0f49" - "\u0f69",
                   "\u10a0" - "\u10c5",
                   "\u10d0" - "\u10f6",
                   "\u1100" - "\u1159",
                   "\u115f" - "\u11a2",
                   "\u11a8" - "\u11f9",
                   "\u1e00" - "\u1e9b",
                   "\u1ea0" - "\u1ef9",
                   "\u1f00" - "\u1f15",
                   "\u1f18" - "\u1f1d",
                   "\u1f20" - "\u1f45",
                   "\u1f48" - "\u1f4d",
                   "\u1f50" - "\u1f57",
                   "\u1f59",
                   "\u1f5b",
                   "\u1f5d",
                   "\u1f5f" - "\u1f7d",
                   "\u1f80" - "\u1fb4",
                   "\u1fb6" - "\u1fbc",
                   "\u1fbe",
                   "\u1fc2" - "\u1fc4",
                   "\u1fc6" - "\u1fcc",
                   "\u1fd0" - "\u1fd3",
                   "\u1fd6" - "\u1fdb",
                   "\u1fe0" - "\u1fec",
                   "\u1ff2" - "\u1ff4",
                   "\u1ff6" - "\u1ffc",
                   "\u207f",
                   "\u2102",
                   "\u2107",
                   "\u210a" - "\u2113",
                   "\u2115",
                   "\u2118" - "\u211d",
                   "\u2124",
                   "\u2126",
                   "\u2128",
                   "\u212a" - "\u2131",
                   "\u2133" - "\u2138",
                   "\u3005",
                   "\u3031" - "\u3035",
                   "\u3041" - "\u3094",
                   "\u309b" - "\u309e",
                   "\u30a1" - "\u30fa",
                   "\u30fc" - "\u30fe",
                   "\u3105" - "\u312c",
                   "\u3131" - "\u318e",
                   "\u4e00" - "\u9fa5",
                   "\uac00" - "\ud7a3",
                   "\uf900" - "\ufa2d",
                   "\ufb00" - "\ufb06",
                   "\ufb13" - "\ufb17",
                   "\ufb1f" - "\ufb28",
                   "\ufb2a" - "\ufb36",
                   "\ufb38" - "\ufb3c",
                   "\ufb3e",
                   "\ufb40" - "\ufb41",
                   "\ufb43" - "\ufb44",
                   "\ufb46" - "\ufbb1",
                   "\ufbd3" - "\ufd3d",
                   "\ufd50" - "\ufd8f",
                   "\ufd92" - "\ufdc7",
                   "\ufdf0" - "\ufdfb",
                   "\ufe70" - "\ufe72",
                   "\ufe74",
                   "\ufe76" - "\ufefc",
                   "\uff21" - "\uff3a",
                   "\uff41" - "\uff5a",
                   "\uff66" - "\uffbe",
                   "\uffc2" - "\uffc7",
                   "\uffca" - "\uffcf",
                   "\uffd2" - "\uffd7",
                   "\uffda" - "\uffdc"
              ]>
}

TOKEN :
{
    <#DIGIT: [
                  "0" - "9",
                  "\u0660" - "\u0669",
                  "\u06f0" - "\u06f9",
                  "\u0966" - "\u096f",
                  "\u09e6" - "\u09ef",
                  "\u0a66" - "\u0a6f",
                  "\u0ae6" - "\u0aef",
                  "\u0b66" - "\u0b6f",
                  "\u0be7" - "\u0bef",
                  "\u0c66" - "\u0c6f",
                  "\u0ce6" - "\u0cef",
                  "\u0d66" - "\u0d6f",
                  "\u0e50" - "\u0e59",
                  "\u0ed0" - "\u0ed9",
                  "\u0f20" - "\u0f29",
                  "\uff10" - "\uff19"
              ]>
}

/* Delimited Identifier - NOTE: this does not allow zero-length identifiers */
TOKEN :
{
  <BACKQUOTED_IDENTIFIER: "`"
    (
      ("``") |
      (~["`"])
    ) +
    "`">
}

MORE :
{
  "\"" { SwitchTo(parser.hasFeature(SQLParserFeature.DOUBLE_QUOTED_STRING) ?
                  IN_DOUBLEQUOTED_STRING : IN_DOUBLEQUOTED_IDENTIFIER); }
}

<IN_DOUBLEQUOTED_IDENTIFIER> TOKEN :
{
  <DOUBLEQUOTED_IDENTIFIER:
    (
      ("\"\"") |
      (~["\""])
    ) +
    "\""> : DEFAULT
}

<IN_DOUBLEQUOTED_STRING> TOKEN :
{
  <DOUBLEQUOTED_STRING:
    (
      ("\"\"") |
      ("\\" ["\u0001" - "\uffdc"]) |
      (~["\"", "\\"])
    ) +
    "\""> : DEFAULT
}

MORE :
{
  "$$" : IN_DOUBLEDOLLAR_STRING
}

<IN_DOUBLEDOLLAR_STRING> TOKEN :
{
  <DOUBLEDOLLAR_STRING: "$$"> : DEFAULT
}

<IN_DOUBLEDOLLAR_STRING> MORE :
{
  <~[]>
}

TOKEN :
{ /* Literals */
  <EXACT_NUMERIC: ( <UINT> ( "." ( <UINT> )? )? | "." <UINT> )>
| <UINT: (["0" - "9"])+ >
| <LENGTH_MODIFIER: ( <UINT> ["K","M","G","k","m","g"] )>
| <SINGLEQUOTED_STRING: "'"
    (
      "''" |
      ~["'"]
    ) *
    "'">
  /* TODO: does not allow multiple ' ... ' sequences with space separators. */
| <HEX_STRING: ["X","x"] "'" (["0"-"9","a"-"f","A"-"F"])*"'">
| <APPROXIMATE_NUMERIC: <EXACT_NUMERIC> ["e","E"] ( ("+" | "-") )? ( ["0" - "9"] )+ >
/*****
    The tokenizer can't handle the date/time literals because
    they are constructed of two tokens with arbitrary whitespace between them.
    INTERVAL_LITERAL will also have to be upgraded at some point.
| <DATE_LITERAL: "DATE" "'" <DATE_VALUE> "'" >
| <#DATE_VALUE: <UINT> "-" <UINT> "-" <UINT> >
| <TIME_LITERAL: "TIME" "'" <TIME_VALUE> ( <TIMEZONE_INTERVAL> ) ? "'" >
| <#TIME_VALUE: <UINT> ":" <UINT> ":" <SECONDS_VALUE> >
| <#TIMEZONE_INTERVAL: ("+" | "-") <UINT> ":" <UINT> >
| <TIMESTAMP_LITERAL: "TIMESTAMP" "'" <DATE_VALUE> " " <TIME_VALUE> ( <TIMEZONE_INTERVAL> ) ? "'" >
| <INTERVAL_LITERAL: "INTERVAL" "'" (["+","-"])? <INTERVAL_STRING> <INTERVAL_QUALIFIER> >
| <#INTERVAL_STRING: "'" ( <YEAR_MONTH_LITERAL> | <DAY_TIME_LITERAL> ) "'" >
| <#INTERVAL_QUALIFIER: <SINGLE_DATETIME_FIELD> | ( <START_FIELD> <TO> <END_FIELD> ) >
| <#SINGLE_DATETIME_FIELD: <NON_SECOND_DATETIME_FIELD> ( <LEFT_PAREN> <UINT> <RIGHT_PAREN> ) ? >
| <#START_FIELD: <NON_SECOND_DATETIME_FIELD> ( <LEFT_PAREN> <UINT> <RIGHT_PAREN> ) ? >
| <#END_FIELD: <NON_SECOND_DATETIME_FIELD> >
| <#NON_SECOND_DATETIME_FIELD: <YEAR> | <MONTH> | <DAY> | <HOUR> | <MINUTE> >
| <#YEAR_MONTH_LITERAL: (<UINT> | ( <UINT> "-" ) )? <UINT> >
| <#DAY_TIME_LITERAL:    ( <DAY_TIME_INTERVAL> | <TIME_INTERVAL> ) >
| <#DAY_TIME_INTERVAL: <UINT> ( " " <UINT> ( ":" <UINT> ( ":" <SECONDS_VALUE> ) ? ) ? ) ? >
| <#SECONDS_VALUE: <UINT> ( "." ( <UINT> ) ? ) ? >
| <#TIME_INTERVAL: <UINT> ( ":" <UINT> ( ":" <SECONDS_VALUE> ) ? ) ?
| <UINT> ( ":" <SECONDS_VALUE> ) ?
| <SECONDS_VALUE> >
*****/
}

StatementNode
Statement() throws StandardException :
{
    StatementNode statementNode;
}
{
    statementNode = StatementPart(null) <EOF>
    {
        return statementNode;
    }
}

void
StatementList(List<StatementNode> list) throws StandardException :
{
    Token[] tokenHolder = new Token[1];
}
{
    statementListElement(list, tokenHolder)
    ( <SEMICOLON> [ statementListElement(list, tokenHolder) ] )*
    <EOF>
}

void
statementListElement(List<StatementNode> list, Token[] tokenHolder) throws StandardException :
{
    StatementNode statementNode;
    parameterNumber = 0;
}
{
    statementNode = StatementPart(tokenHolder)
    {
        statementNode.setBeginOffset(tokenHolder[0].beginOffset);
        statementNode.setEndOffset(getToken(0).endOffset);
        list.add(statementNode);
    }
}

StatementNode 
proceduralStatement(Token[] tokenHolder) throws StandardException : 
{
    StatementNode statementNode;
    tokenHolder[0] = getToken(1); // Remember preceding token.
}       
{       
(
    statementNode = insertStatement() 
| 
    statementNode = preparableUpdateStatement() 
| 
    statementNode = preparableDeleteStatement() 
| 
    statementNode = preparableSelectStatement() 
| 
    statementNode = callStatement()
)
    {
        return statementNode;
    }        
}

StatementNode
StatementPart(Token[] tokenHolder) throws StandardException :
{
    StatementNode statementNode;
    if (tokenHolder != null) {
        tokenHolder[0] = getToken(1); // Remember preceding token.
    }
}
{
    /*
     * The present method of invoking the parser is
     * via JDBC, which uses preparable SQL statements only.
     * the only place this makes a difference from other
     * flavors of SQL (direct SQL, embedded SQL, dynamic SQL)
     * is in the select and positioned update/delete statements,
     * and in whether transaction and connection statements are
     * allowed.
     *
     * When it becomes necessary to differentiate, we should
     * define a way to put the parser into different modes
     * (preparable SQL, dynamic SQL, direct SQL, embedded SQL, etc.)
     * and have it accept/reject statements based on the mode
     * it is in.
     */
(
    statementNode = spsRenameStatement() 
|
    statementNode = lockStatement()
|
    statementNode = createStatements()
|
    statementNode = dropStatements()
|
    statementNode = spsAlterStatement()
|
    statementNode = preparableSQLDataStatement()
|
    statementNode = cursorStatement()
|
    statementNode = executeStatement()
|
    statementNode = spsSetStatement()
|
    statementNode = truncateStatement()
|
    statementNode = grantStatement()
|
    statementNode = revokeStatement()
|
    statementNode = explainStatement()
|
    statementNode = transactionControlStatement()
|
    statementNode = copyStatement()
)
    {
        return statementNode;
    }
}

ExistenceCheck
createCondition() throws StandardException :
{
}
{
    LOOKAHEAD ( {getToken(1).kind == IF} )
    <IF>
    <NOT> <EXISTS>
    {
        return ExistenceCheck.IF_NOT_EXISTS;
    }
|
    {
        return ExistenceCheck.NO_CONDITION;
    }
}

ExistenceCheck
dropCondition() throws StandardException :
{
}
{
    LOOKAHEAD ( {getToken(1).kind == IF} )
    <IF>
    <EXISTS>
    {
        return ExistenceCheck.IF_EXISTS;
    }
|
    {
        return ExistenceCheck.NO_CONDITION;
    }
}

StatementNode
createStatements() throws StandardException :
{
    StatementNode statementNode;
    Token beginToken;
    Boolean createOrReplace = Boolean.FALSE;
}
{
    beginToken = <CREATE> 
    [ LOOKAHEAD ( { getToken(1).kind == OR &&
                    getToken(2).kind == REPLACE &&
                  ( getToken(3).kind == SYNONYM || 
                    getToken(3).kind == PROCEDURE ||
                    getToken(3).kind == FUNCTION ||
                    getToken(3).kind == TYPE ) })
      <OR> <REPLACE> { createOrReplace = Boolean.TRUE; } ]
(
    statementNode = schemaDefinition() 
|
    statementNode = viewDefinition(beginToken)
|
    statementNode = triggerDefinition()
|
    statementNode = synonymDefinition(createOrReplace) 
|
    statementNode = roleDefinition() 
|
    statementNode = sequenceDefinition()
|
    statementNode = tableDefinition()
|
    statementNode = procedureDefinition(createOrReplace)
|        
    statementNode = functionDefinition(createOrReplace)
|
    statementNode = udtDefinition(createOrReplace)
|
    statementNode = indexDefinition()
)
    {
        return statementNode;
    }
}

StatementNode
dropStatements() throws StandardException :
{
    StatementNode statementNode;
}
{
    <DROP>
(
    statementNode = dropSchemaStatement() 
|
    statementNode = dropTableStatement() 
|
    statementNode = dropIndexStatement() 
|
    statementNode = dropAliasStatement() 
|
    statementNode = dropViewStatement() 
|
    statementNode = dropTriggerStatement() 
|
    statementNode = dropRoleStatement() 
|
    statementNode = dropSequenceStatement()
|
    statementNode = dropGroupStatement()
)
    {
        return statementNode;
    }
}

StatementNode
spsAlterStatement() throws StandardException :
{
    StatementNode statementNode;
}
{
    <ALTER>
(
    statementNode = alterStatement()
)
    {
        return statementNode;
    }
}

StatementNode
spsSetStatement() throws StandardException :
{
    StatementNode statementNode;
}
{
    LOOKAHEAD ( { getToken(1).kind == SET && getToken(2).kind != CURRENT } )
    <SET>
    (
        statementNode = setIsolationStatement() 
    |
        statementNode = setSchemaStatement() 
    |
        statementNode = setMessageLocaleStatement() 
    |
        statementNode = setRoleStatement()
    |
        statementNode = setTransactionStatement()
    |
        statementNode = setConfigurationStatement()
    )
    {
        return statementNode;
    }
|
    LOOKAHEAD ( { getToken(1).kind == SET && getToken(2).kind == CURRENT } )
    <SET>
    (
        statementNode = setSchemaStatement() 
    |
        statementNode = setIsolationStatement()
    )
    {
        return statementNode;
    }
}
        
/*
 * preparableSQLDataStatement differs from directSQLDataStatement in
 * that it supports positioned update and delete and a preparable
 * select (with FOR UPDATE) instead of a direct select (without FOR
 * UPDATE)
 */
StatementNode
preparableSQLDataStatement() throws StandardException :
{
    StatementNode    dmlStatement;
}
{
    // TODO: Ignoring temporary table declarations for now.
(
    dmlStatement = preparableDeleteStatement()
|
    dmlStatement = preparableSelectStatement()
|
    dmlStatement = insertStatement()
|
    dmlStatement = preparableUpdateStatement()
|
    dmlStatement = callStatement()
/*
|
    dmlStatement = savepointStatement()
*/
)
    {
        return dmlStatement;
    }
}

// This may be a search or positioned delete statement.
StatementNode
preparableDeleteStatement() throws StandardException :
{
    StatementNode qtn;
}
{
    <DELETE> qtn = deleteBody()
    {
        return qtn;
    }
}

StatementNode
deleteBody() throws StandardException :
{
    JavaToSQLValueNode javaToSQLNode = null;
    String correlationName = null;
    TableName tableName = null;
    ValueNode whereClause = null;
    FromTable fromTable = null;
    QueryTreeNode retval;
    Properties targetProperties = null;
    Token whereToken = null;
    ResultColumnList returningList = null;
}
{
    LOOKAHEAD( { fromNewInvocationFollows() } )
    <FROM> javaToSQLNode = newInvocation()
    [ whereToken = <WHERE> whereClause = whereClause(whereToken) ]
    {
        fromTable = (FromTable)nodeFactory.getNode(NodeTypes.FROM_VTI,
                                                   javaToSQLNode.getJavaValueNode(),
                                                   (String)null,
                                                   null,
                                                   (Properties)null,
                                                   parserContext); 

        return getDeleteNode(fromTable, tableName, whereClause, returningList);
    }
|
    <FROM> tableName = qualifiedName() 
    [ 
        LOOKAHEAD( { (getToken(1).kind != EOF) && (getToken(1).kind != SEMICOLON) && 
        		(getToken(1).kind != WHERE) &&
        		(getToken(1).kind != RETURNING) &&  
                                     !derbyPropertiesListFollows() } )
        [ <AS> ] correlationName = identifier() 
    ]
    [ targetProperties = propertyList(false) <CHECK_PROPERTIES> ]
    [ 
        whereToken = <WHERE>
        (
            // Decide between CURRENT in Java class name and CURRENT in CURRENT OF.
            LOOKAHEAD( { (getToken(1).kind == CURRENT) &&    (getToken(2).kind == OF) } )    
            fromTable = currentOfClause(correlationName) 
        |
            whereClause = whereClause(whereToken)
        )
    ]
    [ <RETURNING> returningList = selectList() ]
    {
        /* Fabricate a ResultSetNode (SelectNode) under the DeleteNode.
         * For a searched delete, The FromList is simply the table that we
         * are deleting from.
         * (NOTE - we mark the table as the one that we are deleting
         * from.)    For a positioned delete, the FromList is a
         * CurrentOfNode holding the cursor name.    The select list will be
         * null for now.    We will generate it at bind time, in keeping
         * with the design decision that the parser's output should look
         * like the language.
         */
        if (fromTable == null)
            fromTable = (FromTable)nodeFactory.getNode(NodeTypes.FROM_BASE_TABLE,
                                                       tableName,
                                                       correlationName,
                                                       FromBaseTable.UpdateOrDelete.DELETE,
                                                       parserContext);

        if (targetProperties != null) {
            ((FromBaseTable)fromTable).setTableProperties(targetProperties);
        }

        return getDeleteNode(fromTable, tableName, whereClause, returningList);
    }
}

FromTable
currentOfClause( String correlationName ) throws StandardException :
{
    String cursorName = null;
}
{
    <CURRENT> <OF> cursorName = identifier()
    { 
        return (FromTable)nodeFactory.getNode(NodeTypes.CURRENT_OF_NODE,
                                              correlationName,
                                              cursorName,
                                              null,
                                              parserContext);
    }
}


/*
 *  The preparable select statement is a superset of the
 *  directSelectStatementMultipleRows in that it allows both the
 *  preparable single row select statement (a query expression that
 *  returns one row, although it is also handled like a cursor) and
 *  the preparable multiple row select statement, which allows not
 *  only an order by clause but also a for update clause.
 */
CursorNode
preparableSelectStatement() throws StandardException :
{
    ResultSetNode queryExpression;
    List<String> updateColumns = new ArrayList<String>();
    CursorNode.UpdateMode forUpdateState = CursorNode.UpdateMode.UNSPECIFIED;
    IsolationLevel isolationLevel = IsolationLevel.UNSPECIFIED_ISOLATION_LEVEL;
    CursorNode retval;
    OrderByList orderCols = null;
    ValueNode[] offsetAndFetchFirst = new ValueNode[2];
}
{
    queryExpression = queryExpression(null, NO_SET_OP) 
    [ orderCols = orderByClause() ]
    ( offsetOrFetchFirstClause(offsetAndFetchFirst) )*
    [ <FOR> forUpdateState = forUpdateClause(updateColumns) ]
    [ isolationLevel = atIsolationLevel() ]
    {
        // Note: if ORDER BY is specified, the FOR UPDATE clause must be
        // READ ONLY or empty, and the cursor is implicitly READ_ONLY.

        retval = (CursorNode)nodeFactory.getNode(NodeTypes.CURSOR_NODE,
                                                 "SELECT",
                                                 queryExpression,
                                                 null,
                                                 orderCols,
                                                 offsetAndFetchFirst[0],
                                                 offsetAndFetchFirst[1],
                                                 forUpdateState,
                                                 (forUpdateState == CursorNode.UpdateMode.READ_ONLY ? null : updateColumns),
                                                 parserContext);

        /* Set the isolation levels for the scans if specified */
        if (isolationLevel != IsolationLevel.UNSPECIFIED_ISOLATION_LEVEL) {
            retval.setScanIsolationLevel(isolationLevel);
        }

        return retval;
    }
}

StatementNode
insertStatement() throws StandardException :
{
    StatementNode insertNode;
    QueryTreeNode targetTable;
}
{
    <INSERT> <INTO> targetTable = targetTable()
        insertNode = insertColumnsAndSource(targetTable)
    {
        return insertNode;
    }
}

QueryTreeNode
targetTable() throws StandardException :
{
    JavaToSQLValueNode javaToSQLNode;
    TableName tableName;
}
{
    // NOTE: this rule has to come first in order to avoid making NEW a reserved word.
    LOOKAHEAD( { newInvocationFollows(1) } )
    javaToSQLNode = newInvocation()
    {
        return nodeFactory.getNode(NodeTypes.FROM_VTI,
                                   javaToSQLNode.getJavaValueNode(),
                                   null,
                                   null,
                                   (Properties)null,
                                   parserContext); 
    }
|
    tableName = qualifiedName() 
    {
        return tableName;
    }
}

StatementNode
preparableUpdateStatement() throws StandardException :
{
    StatementNode qtn;
}
{
    <UPDATE> qtn = updateBody()
    {
        return qtn;
    }
}

StatementNode
updateBody() throws StandardException :
{
    ResultColumnList columnList;
    String correlationName = null;
    JavaToSQLValueNode javaToSQLNode = null;
    TableName tableName = null;
    ValueNode whereClause = null;
    FromTable fromTable = null;
    Properties targetProperties = null;
    Token whereToken = null;
    ResultColumnList returningList = null;
}
{
    LOOKAHEAD( { newInvocationFollows(1) } ) 
    javaToSQLNode = newInvocation()
    <SET> columnList = setClauseList()
    [ whereToken = <WHERE> whereClause = whereClause(whereToken) ]
    {
        fromTable = (FromTable)nodeFactory.getNode(NodeTypes.FROM_VTI,
                                                   javaToSQLNode.getJavaValueNode(),
                                                   (String)null,
                                                   null,
                                                   (Properties)null,
                                                   parserContext); 

        return getUpdateNode(fromTable, tableName, columnList, whereClause, returningList);
    }
|
    tableName = qualifiedName()
    [
        LOOKAHEAD( { (getToken(1).kind != SET) && !derbyPropertiesListFollows() } )
        [ <AS> ] correlationName = identifier() 
    ]
    [ targetProperties = propertyList(false) <CHECK_PROPERTIES> ] 
    <SET> columnList = setClauseList()
    [ 
        whereToken = <WHERE>
        (
            whereClause = whereClause(whereToken) 
        |
            fromTable = currentOfClause(correlationName)
        )
    ]
    [ <RETURNING> returningList = selectList() ]
    {
        /* Fabricate a ResultSetNode (SelectNode) under the UpdateNode.
         * For a searched update,
         * The FromList is simply the table that we are updating.
         * For a positioned update,
         * the FromList is a CurrentOfNode holding the cursor name.
         * (NOTE - we mark the table as the one that we are updating.)
         * The select list is the columns in the SET clause.    At bind time,
            * we will prepend the CurrentRowLocation() in keeping with the design 
         * decision that the parser's output should look like the language.
         */
        if (fromTable == null)
            fromTable = (FromTable)nodeFactory.getNode(NodeTypes.FROM_BASE_TABLE,
                                                       tableName,
                                                       correlationName,
                                                       FromBaseTable.UpdateOrDelete.UPDATE,
                                                       parserContext);

        if (targetProperties != null) {
            ((FromBaseTable)fromTable).setTableProperties(targetProperties);
        }
        return getUpdateNode(fromTable, tableName, columnList, whereClause, returningList);
    }
}

StatementNode
callStatement() throws StandardException :
{
    StatementNode retval;
}
{
(
    retval = bareCallStatement() 
|
    <LEFT_BRACE> retval = bareCallStatement() <RIGHT_BRACE>
)
    {
        return retval;
    }
}

StatementNode
bareCallStatement() throws StandardException :
{
    ParameterNode returnParam;
    ValueNode value;
    ResultSetNode resultSetNode;
}
{
    <CALL> value = primaryExpression()
    {
        if (! (value instanceof JavaToSQLValueNode) ||
            ! (((JavaToSQLValueNode) value).getJavaValueNode() instanceof MethodCallNode)) {
            throw new StandardException("Invalid call statement");
        }

        StatementNode callStatement = (StatementNode)
            nodeFactory.getNode(NodeTypes.CALL_STATEMENT_NODE,
                                value,
                                parserContext);

        return callStatement;
    }

|    
    // ? = CALL method()
    returnParam = dynamicParameterSpecification()
    <EQUALS_OPERATOR> <CALL> resultSetNode = rowValueConstructor(null)
    {
        // Validate that we have something that is an appropriate call statement.
        ResultColumnList rcl = resultSetNode.getResultColumns();

        // We can have only 1 return value/column.
        if (rcl == null || rcl.size() > 1) {
            throw new StandardException("Invalid call statement");
        }

        // We must have a method call node.
        value = rcl.get(0).getExpression();
        if (! (value instanceof JavaToSQLValueNode) ||
            ! (((JavaToSQLValueNode) value).getJavaValueNode() instanceof MethodCallNode)) {
            throw new StandardException("Invalid call statement");
        }

        // wrap the row result set in a cursor node
        StatementNode cursorNode = (StatementNode)
            nodeFactory.getNode(NodeTypes.CURSOR_NODE,
                                "SELECT",
                                resultSetNode,
                                null,
                                null,
                                null,
                                null,
                                CursorNode.UpdateMode.READ_ONLY,
                                null,
                                parserContext);

        // Set the 0th param to be a RETURN param.
        returnParam.setReturnOutputParam(value);

        parserContext.setReturnParameterFlag();

        return cursorNode;
    }
}

ValueNode primaryExpression() throws StandardException :
{
    ValueNode value = null;
}
{
    LOOKAHEAD( { getToken(2).kind == PERIOD && getToken(4).kind == LEFT_PAREN } )
    value = routineInvocation()
    {
        return value;
    }
|
    value = primaryExpressionXX()
    {
        return value;
    }
}

StatementNode
savepointStatement() throws StandardException :
{
    String savepointName = null;
    SavepointNode.StatementType savepointStatementType;
    Boolean[] savepointStatementClauses = new Boolean[SAVEPOINT_NCLAUSES];
}
{
(
    <SAVEPOINT> savepointName = identifier() 
    ( savepointStatementClause(savepointStatementClauses) )+
    {
        //ON ROLLBACK RETAIN CURSORS is only supported case *** TODO: fix this ***
        if (savepointStatementClauses[SAVEPOINT_RETAIN_CURSORS] == null)
            throw new StandardException("Missing required ON ROLLBACK RETAIN CURSORS");
        savepointStatementType = SavepointNode.StatementType.SET;
    }
|
    <ROLLBACK> [ <WORK> ] <TO> <SAVEPOINT> [ savepointName = identifier() ]
    {
        savepointStatementType = SavepointNode.StatementType.ROLLBACK;
    }
|
    <RELEASE> [ <TO> ] <SAVEPOINT> savepointName = identifier()
    {
        savepointStatementType = SavepointNode.StatementType.RELEASE;
    }
    )
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.SAVEPOINT_NODE,
                                                  savepointName,
                                                  savepointStatementType,
                                                  parserContext);
    }
}

void savepointStatementClause(Boolean[] savepointStatementClauses) 
        throws StandardException :
{
    int clausePosition;
}
{
(
    <UNIQUE> { clausePosition = SAVEPOINT_UNIQUE; }
|
    <ON> <ROLLBACK> <RETAIN> ( clausePosition = LocksOrCursors() )
)
    {
        // Check for repeated clause
        if (savepointStatementClauses[clausePosition] != null) {
            String which = SAVEPOINT_CLAUSE_NAMES[clausePosition];
            throw new StandardException("Repeated " + which + " clause");
        }
                
        savepointStatementClauses[clausePosition] = Boolean.TRUE;
    }
}

int
LocksOrCursors() :
{
}
{
    <LOCKS>
    {
        return SAVEPOINT_RETAIN_LOCKS;
    }
|
    <CURSORS>
    {
        return SAVEPOINT_RETAIN_CURSORS;
    }
}

StatementNode
transactionControlStatement() throws StandardException :
{
    TransactionControlNode.Operation transactionOperation;
}
{
    (
        <BEGIN>
        {
            transactionOperation = TransactionControlNode.Operation.BEGIN;
        }
    |
        <COMMIT>
        {
            transactionOperation = TransactionControlNode.Operation.COMMIT;
        }
    |
        <ROLLBACK>
        {
            transactionOperation = TransactionControlNode.Operation.ROLLBACK;
        }
    ) [ <WORK> | <TRANSACTION> ]
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.TRANSACTION_CONTROL_NODE,
                                                  transactionOperation,
                                                  parserContext);
    }
}

StatementNode
globalTemporaryTableDeclaration() throws StandardException :
{
    TableName tableName;
    TableElementList tableElementList;
    Boolean[] declareTableClauses = new Boolean[TEMPORARY_TABLE_NCLAUSES];
}
{ 
    <DECLARE> <GLOBAL> <TEMPORARY> <TABLE> tableName = qualifiedName()
    tableElementList = tableElementList()
    ( declareTableClause(declareTableClauses) ) +
    {
        // NOT LOGGED is mandatory
        if (declareTableClauses[TEMPORARY_TABLE_NOT_LOGGED] == null)
            throw new StandardException("Missing required NOT LOGGED");
        // if ON COMMIT behavior not explicitly specified in DECLARE command, resort to default ON COMMIT DELETE ROWS
        if (declareTableClauses[TEMPORARY_TABLE_ON_COMMIT] == null)
            declareTableClauses[TEMPORARY_TABLE_ON_COMMIT] = Boolean.TRUE;
        // if ON ROLLBACK behavior not explicitly specified in DECLARE command, resort to default ON ROLLBACK DELETE ROWS
        if (declareTableClauses[TEMPORARY_TABLE_ON_ROLLBACK] == null)
            declareTableClauses[TEMPORARY_TABLE_ON_ROLLBACK] = Boolean.TRUE;
        return (StatementNode)nodeFactory.getNode(NodeTypes.CREATE_TABLE_NODE,
                                                  tableName,
                                                  tableElementList,
                                                  (Properties)null,
                                                  (Boolean)declareTableClauses[1],
                                                  (Boolean)declareTableClauses[2],
                                                  parserContext);
    }
}

void declareTableClause(Boolean[] declareTableClauses) throws StandardException :
{
    int clausePosition;
    Boolean clauseValue;
}
{
(
    <NOT> <LOGGED> 
    { 
        clausePosition = TEMPORARY_TABLE_NOT_LOGGED; 
        clauseValue = Boolean.TRUE;
    }
|
    LOOKAHEAD( { getToken(1).kind == ON && getToken(2).kind == COMMIT } )
    <ON> <COMMIT> ( clauseValue = onCommit() ) <ROWS> 
    {
        clausePosition = TEMPORARY_TABLE_ON_COMMIT;
    } 
|
    LOOKAHEAD( { getToken(1).kind == ON && getToken(2).kind == ROLLBACK } )
    <ON> <ROLLBACK> <DELETE> <ROWS>
    { 
        clausePosition = TEMPORARY_TABLE_ON_ROLLBACK; 
        clauseValue = Boolean.TRUE;
    }
)
    {
        // Check for repeated clause.
        if (declareTableClauses[clausePosition] != null) {
            String which = TEMPORARY_TABLE_CLAUSE_NAMES[clausePosition];
            throw new StandardException("Repeated " + which + " clause");
        }
        declareTableClauses[clausePosition] = clauseValue;
    }
}

Boolean
onCommit() :
{}
{
    <PRESERVE>
    {
        return Boolean.FALSE;
    }
|
    <DELETE>
    {
        return Boolean.TRUE;
    }
}

TableElementList
tableElementList() throws StandardException :
{
    TableElementList tableElementList =
                    (TableElementList)nodeFactory.getNode(NodeTypes.TABLE_ELEMENT_LIST,
                                                          parserContext);
}
{
    <LEFT_PAREN> tableElement(tableElementList)
    ( <COMMA> tableElement(tableElementList) )* 
    <RIGHT_PAREN>
    {
        return tableElementList;
    }
}

void
tableElement(TableElementList tableElementList) throws StandardException :
{
}
{
    columnDefinition(tableElementList) | tableConstraintDefinition(tableElementList)
    {
        return ;
    }
}

boolean
columnDefinition(TableElementList tableElementList) throws StandardException :
{
    DataTypeDescriptor[] typeDescriptor = new DataTypeDescriptor[1];
    ValueNode defaultNode = null;
    String columnName;
    long[] autoIncrementInfo = new long[4]; // *** TODO: constant ***
    String collation = null;
}
{
    columnName = identifier() 
    ( typeDescriptor[0] = dataTypeDDL() )
    [ defaultNode = defaultAndConstraints(typeDescriptor, tableElementList, columnName,
                                          autoIncrementInfo)
      [ collation = collateClause() { typeDescriptor[0] = new DataTypeDescriptor(typeDescriptor[0], CharacterTypeAttributes.forCollation(null, collation)); } ]
    ]
    {
        // Only pass autoincrement info for autoincrement columns
        if (autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] == 0) {
            autoIncrementInfo = null;
        }
        
        tableElementList.addTableElement((TableElementNode) nodeFactory.getNode(
                                                            NodeTypes.COLUMN_DEFINITION_NODE,
                                                            columnName,
                                                            defaultNode,
                                                            typeDescriptor[0],
                                                            autoIncrementInfo,
                                                            parserContext));
        return autoIncrementInfo != null;
    }
}

ValueNode
defaultAndConstraints(DataTypeDescriptor[] typeDescriptor,
                      TableElementList tableElementList,
                      String columnName,
                      long[] autoIncrementInfo) throws StandardException :
{
    ValueNode defaultNode = null;
}
{
    // Compatible with DB2 syntax.
    columnConstraintDefinition(typeDescriptor, tableElementList, columnName)
    ( columnConstraintDefinition(typeDescriptor, tableElementList, columnName) )*
    [ defaultNode = defaultClause(autoIncrementInfo, columnName) 
        ( columnConstraintDefinition(typeDescriptor, tableElementList, columnName) )* ]
    {
        return defaultNode;
    }
|
    defaultNode = defaultClause(autoIncrementInfo, columnName)
    ( columnConstraintDefinition(typeDescriptor, tableElementList, columnName) )*
    {
        return defaultNode;
    }
}

DataTypeDescriptor
dataTypeDDL() throws StandardException :
{
    DataTypeDescriptor typeDescriptor;
}
{
    LOOKAHEAD( { commonDatatypeName(false) } )
    typeDescriptor = dataTypeCommon()
    {
        return typeDescriptor;
    }
|
    LOOKAHEAD ( { getToken(1).kind != GENERATED } )
    typeDescriptor = javaType()
    {
        return typeDescriptor;
    }
}

DataTypeDescriptor
catalogType() throws StandardException :
{
    DataTypeDescriptor typeDescriptor;
}
{
    typeDescriptor = dataTypeDDL()
    {
        return typeDescriptor;          // NOTE: Used to be .getCatalogType()
    }
}

DataTypeDescriptor
dataTypeCast() throws StandardException :
{
    DataTypeDescriptor typeDescriptor;
}
{
    // This LOOKAHEAD is required because the names of the built-in
    // datatypes are not reserved words.
    LOOKAHEAD( { commonDatatypeName(true) } )
    typeDescriptor = dataTypeCommon()
    {
        return typeDescriptor;
    }
|
    typeDescriptor = javaType()
    {
        return typeDescriptor;
    }
}

DataTypeDescriptor
dataTypeCommon() throws StandardException :
{
    DataTypeDescriptor typeDescriptor;
    boolean checkCS = false;
    CharacterTypeAttributes characterAttributes = null;
}
{
(
    /* TODO: Ignoring decimal, numeric, long *** Not sure what that refers to. */

    ( LOOKAHEAD( { getToken(2).kind != LARGE } )
      typeDescriptor = characterStringType() 
    )
    characterAttributes = characterTypeAttributes()
|
    ( LOOKAHEAD( { getToken(3).kind != LARGE } )
      typeDescriptor = nationalCharacterStringType()
    )
    characterAttributes = characterTypeAttributes()
|
    typeDescriptor = numericType()
|
    typeDescriptor = datetimeType()
|
    typeDescriptor = intervalType()
|
    <BOOLEAN>
    {
        typeDescriptor = new DataTypeDescriptor(TypeId.BOOLEAN_ID, true);
    }
|
    typeDescriptor = longType()
|
    typeDescriptor = LOBType()
|
    typeDescriptor = XMLType()
)
    {
        if (characterAttributes != null)
            typeDescriptor = new DataTypeDescriptor(typeDescriptor, characterAttributes);
        return typeDescriptor;
    }
}

DataTypeDescriptor
characterStringType() throws StandardException :
{
    int length = DEFAULT_STRING_COLUMN_LENGTH;
    Token varyingToken = null;
    int type;
}
{
(
    (
        <VARCHAR> length = charLength()
    )
    {
        type = Types.VARCHAR;
    }
|
    charOrCharacter()
    (
        // Length is optional for CHARACTER, not for plain CHARACTER VARYING
        varyingToken = <VARYING> length = charLength() 
    |
        [ length = charLength() ]
    )
    {
        // If the user says CHARACTER VARYING, it's really VARCHAR
        type = (varyingToken == null ? Types.CHAR : Types.VARCHAR);
    }
)
    [ type = forBitData(type) ]
    {
        DataTypeDescriptor charDTD = DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);
        return charDTD;
    }
}

void
charOrCharacter() :
{}
{
    <CHAR> | <CHARACTER>
}

int
charLength() throws StandardException :
{
    int length;
}
{
    <LEFT_PAREN> length = length() <RIGHT_PAREN>
    {
        return length;
    }
}

int
forBitData(int charType) :
{}
{
    <FOR> <BIT> <DATA>
    {
        switch (charType) {
        case Types.CHAR:
            charType = Types.BINARY;
            break;
        case Types.VARCHAR:
            charType = Types.VARBINARY;
            break;
        case Types.LONGVARCHAR:
            charType = Types.LONGVARBINARY;
            break;
        }
        return charType;
    }
}

DataTypeDescriptor
nationalCharacterStringType() throws StandardException :
{
    DataTypeDescriptor  dataTypeDescriptor;
    int length = DEFAULT_STRING_COLUMN_LENGTH;
    String type = null;
    Token varyingToken = null;
}
{
(
    <NATIONAL> charOrCharacter() 
    (
        // Length is optional for NATIONAL CHARACTER , not for NATIONAL CHARACTER VARYING
        varyingToken = <VARYING> length = charLength() 
    |
        [ length = charLength() ]
    )
    {
        // If the user says NATIONAL CHARACTER VARYING, it's really NATIONALVARCHAR
        type = (varyingToken == null ? TypeId.NATIONAL_CHAR_NAME :
                        TypeId.NATIONAL_VARCHAR_NAME);
    }
|
    <NCHAR> 
    (
        // Length is optional for NCHAR, not for NCHAR VARYING
        varyingToken = <VARYING> length = charLength() 
    | [ length = charLength() ]
    )
    {
        // If the user says NCHAR VARYING, it's really NATIONALVARCHAR
        type = (varyingToken == null ? TypeId.NATIONAL_CHAR_NAME : 
                TypeId.NATIONAL_VARCHAR_NAME);

    }
|
    <NVARCHAR> 
    (
        length = charLength()
    )
    {
        type = TypeId.NATIONAL_VARCHAR_NAME;
    }
)
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);
    } 
}

CharacterTypeAttributes 
characterTypeAttributes()  throws StandardException :
{
    TableName characterSet = null;
    String collation = null;
    CharacterTypeAttributes characterAttributes = null;
}
{
    [ <CHARACTER> <SET> characterSet = qualifiedName() { characterAttributes = CharacterTypeAttributes.forCharacterSet(characterSet.toString()); } ]
    [ collation = collateClause() { characterAttributes = CharacterTypeAttributes.forCollation(characterAttributes, collation); } ]
    {
        return characterAttributes;
    }
}

DataTypeDescriptor
LOBType() throws StandardException :
{
    int length = 0x80000000-1;      // default to 2GB-1 if no length specified
    String type;
    CharacterTypeAttributes characterAttributes;
}
{
(
    <BLOB> [ length = lengthAndModifier() ]
    {
        type = TypeId.BLOB_NAME;
    }
|
    <CLOB> [ length = lengthAndModifier() ]
    {
        type = TypeId.CLOB_NAME;
    }
|
    <TEXT> [ length = lengthAndModifier() ]
    {
        type = TypeId.TEXT_NAME;
    }
|
    <NCLOB> length = lengthAndModifier()
    {
        type = TypeId.NCLOB_NAME;
    }
|
    <BINARY> <LARGE> <OBJECT> [ length = lengthAndModifier() ]
    {
        type = TypeId.BLOB_NAME;
    }
|
    charOrCharacter() <LARGE> <OBJECT> [ length = lengthAndModifier() ]
    {
        type = TypeId.CLOB_NAME;
    }
|
    <NATIONAL> <CHARACTER> <LARGE> <OBJECT> length = lengthAndModifier()
    {
        type = TypeId.NCLOB_NAME;
    }
|
    <TINYBLOB> [ length = lengthAndModifier() ]
    {
        type = TypeId.TINYBLOB_NAME;
    }
|
    <TINYTEXT> [ length = lengthAndModifier() ]
    {
        type = TypeId.TINYTEXT_NAME;
    }
|
    <MEDIUMBLOB> [ length = lengthAndModifier() ]
    {
        type = TypeId.MEDIUMBLOB_NAME;
    }
|
    <MEDIUMTEXT> [ length = lengthAndModifier() ]
    {
        type = TypeId.MEDIUMTEXT_NAME;
    }
|
    <LONGBLOB> [ length = lengthAndModifier() ]
    {
        type = TypeId.LONGBLOB_NAME;
    }
|
    <LONGTEXT> [ length = lengthAndModifier() ]
    {
        type = TypeId.LONGTEXT_NAME;
    }
)
    characterAttributes = characterTypeAttributes()
    {
        DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);
        if (characterAttributes != null)
            dtd = new DataTypeDescriptor(dtd, characterAttributes);
        return dtd;
    }
}

DataTypeDescriptor
numericType() throws StandardException :
{
    DataTypeDescriptor typeDescriptor;
    Token unsignedToken = null;
}
{
(
    typeDescriptor = exactNumericType()
|
    typeDescriptor = approximateNumericType()
)
    [ LOOKAHEAD( { unsignedFollows() })
      unsignedToken = <UNSIGNED> ]
    {
        if (unsignedToken != null)
            return typeDescriptor.getUnsigned();
        else
            return typeDescriptor;
    }
}

DataTypeDescriptor
exactNumericType() throws StandardException :
{
    int precision = DEFAULT_DECIMAL_PRECISION;
    int scale = DEFAULT_DECIMAL_SCALE;
    int type = Types.DECIMAL;
    String typeStr = "DECIMAL";
    int maxWidth;
    DataTypeDescriptor dtd = null;
}
{
(
    <NUMERIC> 
    {
        type = Types.NUMERIC;
        typeStr = "NUMERIC";
    }
|
    <DECIMAL> | <DEC> 
)
    [ <LEFT_PAREN> precision = precision() [ <COMMA> scale = scale() ] <RIGHT_PAREN> ]
    {
        if ((precision <= 0) || 
                (precision > MAX_DECIMAL_PRECISION_SCALE)) {
            throw new StandardException("Invalid precision: " + precision);
        } 
        else if ((scale < 0) || 
                         (scale > MAX_DECIMAL_PRECISION_SCALE)) {
            throw new StandardException("Invalid scale: " + scale);
        }
        else if (scale > precision) {
            throw new StandardException("Scale is greater than precision: " + 
                                                                     scale + " > " + precision);
        }
        /*
        ** If we have a decimal point, need to count it
        ** towards maxwidth.    Max width needs to account
        ** for the possible leading '0' and '-' and the
        ** decimal point.    e.g., DEC(1,1) has a maxwidth
        ** of 4 (to handle "-0.1").
        */
        maxWidth = DataTypeDescriptor.computeMaxWidth(precision, scale);
        return getType(type, precision, scale, maxWidth);
    }
|
    dtd = exactIntegerType()
    {
        return dtd;
    }
}

DataTypeDescriptor
exactIntegerType() throws StandardException :
{}
{
    ( <INTEGER> | <INT> )
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER);
    }
|
    <MEDIUMINT>
    {
        return DataTypeDescriptor.MEDIUMINT;
    }
|
    <TINYINT>
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TINYINT);
    }
|
    <SMALLINT>
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.SMALLINT);
    }
|
    <LONGINT>
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BIGINT);
    }
}

DataTypeDescriptor
approximateNumericType() throws StandardException :
{
    int type = 0, scale = 0, width = 0;
    int prec = -1;
    DataTypeDescriptor dts = null;
}
{
    <FLOAT> [ <LEFT_PAREN> prec = precision() <RIGHT_PAREN> ]
    {
        /*
            When not specified, default is DOUBLE_PRECISION
         */
        if (prec == -1)
            prec = TypeId.DOUBLE_PRECISION;

        if (prec > 0 && prec <= TypeId.REAL_PRECISION) {
            type = Types.REAL;
            prec = TypeId.REAL_PRECISION;
            scale = TypeId.REAL_SCALE;
            width = TypeId.REAL_MAXWIDTH;
        }
        else if (prec > TypeId.REAL_PRECISION &&
                 prec <= TypeId.DOUBLE_PRECISION) {
            type = Types.DOUBLE;
            prec = TypeId.DOUBLE_PRECISION;
            scale = TypeId.DOUBLE_SCALE;
            width = TypeId.DOUBLE_MAXWIDTH;
        }
        else
            throw new StandardException("Invalid floating point precision: " + prec);

        /*
            REMIND: this is a slight hack, in that an exact reading of
            the InformationSchema requires that the type the user typed
            in be visible to them in the InformationSchema views. But
            most implementations use synonyms or mappings at some point,
            and this is one of those places, for us.
         */
        return getType(type, prec, scale, width);
    }
| 
    <REAL>
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.REAL);
    }
|
    dts = doubleType()
    {
        return dts;
    }
}

DataTypeDescriptor
doubleType() throws StandardException :
{}
{
    ( LOOKAHEAD( { getToken(2).kind == PRECISION } ) 
        <DOUBLE> <PRECISION> 
    | <DOUBLE> 
    )
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE);
    }
}

DataTypeDescriptor
longType() throws StandardException :
{
    DataTypeDescriptor dataTypeDescriptor;
}
{
    <LONG> dataTypeDescriptor = longSubType()
    {
        return dataTypeDescriptor;
    }
}


DataTypeDescriptor
longSubType() throws StandardException :
{
    int lvcType = Types.LONGVARCHAR;
}
{
    <VARCHAR> [ lvcType = forBitData(lvcType) ]
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(lvcType);
    }
|
    <NVARCHAR> 
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(TypeId.NATIONAL_LONGVARCHAR_NAME);
    }
}

DataTypeDescriptor
XMLType() throws StandardException :
{
    DataTypeDescriptor value;
}
{
    <XML>
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.SQLXML);
    }
}

/*
 * Parse the XML keywords DOCUMENT and CONTENT.  We don't support
 * CONTENT yet, so we throw an appropriate error if we see it.
 *
 */
void
xmlDocOrContent() throws StandardException :
{}
{
    LOOKAHEAD( { (getToken(1).kind != DOCUMENT) && (getToken(1).kind != CONTENT) } )
    {
        // TODO: Is this needed?
        throw new StandardException("Not DOCUMENT or CONTENT");
    }
|
    LOOKAHEAD( { getToken(1).kind == CONTENT } ) 
    <CONTENT>
    {
        // TODO: Fix this by returning a proper value.
        throw new StandardException("CONTENT not supported yet");
    }
|
    LOOKAHEAD( { getToken(1).kind == DOCUMENT } ) 
    <DOCUMENT>
    {
        return;
    }
}

DataTypeDescriptor
javaType() throws StandardException :
{
    TableName typeName;
}
{
    typeName = qualifiedName()
    {
        return getJavaClassDataTypeDescriptor(typeName);
    }
}

// A Java dot-separated list.
String
javaDSL() :
{
    String dotSeparatedList;
}
{
    dotSeparatedList = caseSensitiveIdentifierPlusReservedWords()
        ( dotSeparatedList = javaDSLNameExtender(dotSeparatedList) )*
    {
        return dotSeparatedList;
    }
}

String
javaClassName() :
{
    String javaClassName;
}
{
    javaClassName = javaDSL()
    {
        return javaClassName;
    }
}

String
javaDSLNameExtender(String dotSeparatedList)    :
{
    String extender;
}
{
    <PERIOD> extender = caseSensitiveIdentifierPlusReservedWords()
    {
        return dotSeparatedList + "." + extender;
    }
}

int
lengthAndModifier() throws StandardException :
{
    Token tok;
    Token tokmod = null;
}
{
    <LEFT_PAREN> 
    // We have essentially 3 different ways of specifying the length of a LOB.
    ( 
        tok = <LENGTH_MODIFIER>         // LOB(33K)
    | 
        tok = <EXACT_NUMERIC> [ tokmod = <IDENTIFIER> ] // LOB(33) or LOB(33 K)
    )
    <RIGHT_PAREN>
    {
        // Collapse cases, whether single token or multiple.
        String s = tok.image;
        if (tokmod != null) s += tokmod.image;
        try {
            char modifier = s.charAt(s.length()-1);
            String number = s.substring(0, s.length()-1); // In case of suffix.
            long mul;
            switch (modifier) {
            case 'G': 
            case 'g':
                mul = 1073741824L;          // 1 Giga
                break;
            case 'M':
            case 'm':
                mul = 1048576L;                 // 1 Mega
                break;
            case 'K':
            case 'k':
                mul = 1024l;                        // 1 Kilo
                break;
            default:
                mul = 1;
                number = s;                         // No letter in end, use whole string.
                break;
            }
            long specifiedLength = Long.parseLong(number) * mul;
            
            // match DB2 limits of 1 to 2147483647
            if ((specifiedLength > 0L) && 
                    (specifiedLength <= Integer.MAX_VALUE)) {
                return (int)specifiedLength;
            }
        }
        catch (NumberFormatException nfe) {
        }
        throw new StandardException("Invalid LOB length:" + s);
    }
}

int
length() throws StandardException :
{
    Token tok;
    int retval;
}
{
    tok = <EXACT_NUMERIC>
    {
        try {
            retval = Integer.parseInt(tok.image);

            if (retval > 0)
                return retval;
        }
        catch (NumberFormatException nfe) {
        }
        throw new StandardException("Invalid column length: " + tok.image);
    }
}

long
exactNumber() throws StandardException :
{
    Token longToken;
    String sign = "";
}
{
    [ sign = sign() ] 
    longToken = <EXACT_NUMERIC>
    {
        try {
            return Long.parseLong(getNumericString(longToken, sign));
        }
        catch (NumberFormatException nfe) {
            throw new StandardException("Invalid integer: " + longToken.image, nfe);
        }
    }
}

int
precision() throws StandardException :
{
    int uintValue;
}
{
    uintValue = uint_value()
    {
        return uintValue;
    }
}

int 
uint_value() throws StandardException :
{
    Token uintToken;
}
{
    /* TODO: What is this comment about? ***
     * Because the parser won't match to UINT, we use EXACT_NUMERIC.
     */
    uintToken = <EXACT_NUMERIC>
    {
        try {
            return Integer.parseInt(uintToken.image);
        } 
        catch (NumberFormatException nfe) {
            throw new StandardException("Invalid integer: " + uintToken.image, nfe);
        }
    }
}

int
scale() throws StandardException :
{
    int uintValue;
}
{
    uintValue = uint_value()
    {
        return uintValue;
    }
}

DataTypeDescriptor
datetimeType() throws StandardException :
{}
{
    <DATE> 
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DATE);
    }
|
    <TIME> 
    {
        // TODO: Not handling TIME (prec) or WITH TIME ZONE / WITHOUT TIME ZONE
        /*
            We do not try to set up a precision for time/timestamp
            values because this field gets mapped to the precision
            field in the JDBC driver that is for the number of
            decimal digits in the value.    Precision for time is
            actually the scale of the seconds value.

            If/when precision for times is supported, we may need
            to migrate the system catalog information to fill in
            the default values appropriately (the default for
            time is 0, fortunately; but for timestamp it is
            actually 9 due to java.sql.Timestamp's precision).
         */
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIME);
    }
|
    <TIMESTAMP> 
    {
        // TODO; Ditto
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIMESTAMP);
    }
|
    <DATETIME> 
    {
        return new DataTypeDescriptor(TypeId.DATETIME_ID, true);
    }
|
    <YEAR> 
    {
        return new DataTypeDescriptor(TypeId.YEAR_ID, true);
    }
}

DataTypeDescriptor
intervalType() throws StandardException :
{
    DataTypeDescriptor typeDescriptor;
}
{
    <INTERVAL> typeDescriptor = intervalQualifier()
    {
        return typeDescriptor;
    }
}

DataTypeDescriptor
intervalQualifier() throws StandardException :
{
    TypeId typeId, otherId = null;
    int[] precAndScale = new int[2];
}
{
    (
        LOOKAHEAD( { (getToken(2).kind == TO) ||
                       ((getToken(2).kind == LEFT_PAREN) && 
                        (getToken(5).kind == TO)) } )
        typeId = intervalStartField(precAndScale) <TO>
        otherId = intervalEndField(precAndScale)
        {
            typeId = TypeId.intervalTypeId(typeId, otherId);
        }
    |
        typeId = intervalSingleField(precAndScale)
    )
    {
        return new DataTypeDescriptor(typeId, precAndScale[0], precAndScale[1],
                                      true, DataTypeDescriptor.intervalMaxWidth(typeId, precAndScale[0], precAndScale[1]));
    }
}

TypeId
intervalStartField(int[] precAndScale) throws StandardException :
{
    TypeId typeId;
    Token prec;
}
{
    typeId = intervalNonSecond()
    [ <LEFT_PAREN> prec = <EXACT_NUMERIC> <RIGHT_PAREN>
      { precAndScale[0] = Integer.parseInt(prec.image); } ]
    {
        return typeId;
    }
}

TypeId
intervalEndField(int[] precAndScale) throws StandardException :
{
    TypeId typeId;
    Token scale;
}
{
    typeId = intervalNonSecond()
    { 
        return typeId;
    }
|
    <SECOND>
    [ <LEFT_PAREN> scale = <EXACT_NUMERIC> <RIGHT_PAREN>
      { precAndScale[1] = Integer.parseInt(scale.image); } ]
    {
        return TypeId.INTERVAL_SECOND_ID;
    }
}

TypeId
intervalSingleField(int[] precAndScale) throws StandardException :
{
    TypeId typeId;
    Token prec = null, scale = null;
}
{
    typeId = intervalNonSecond()
    [ <LEFT_PAREN> prec = <EXACT_NUMERIC> <RIGHT_PAREN>
      { precAndScale[0] = Integer.parseInt(prec.image); } ]
    { 
        return typeId;
    }
|
    <SECOND>
    [ <LEFT_PAREN> prec = <EXACT_NUMERIC> 
      [ <COMMA> scale = <EXACT_NUMERIC> ]
      <RIGHT_PAREN> ]
    {
        if (prec != null)
            precAndScale[0] = Integer.parseInt(prec.image);
        if (scale != null)
            precAndScale[1] = Integer.parseInt(scale.image);
        return TypeId.INTERVAL_SECOND_ID;
    }
}

TypeId
intervalNonSecond() throws StandardException :
{}
{
    <YEAR>
    { return TypeId.INTERVAL_YEAR_ID; }
|
    <MONTH>
    { return TypeId.INTERVAL_MONTH_ID; }
|
    <DAY>
    { return TypeId.INTERVAL_DAY_ID; }
|
    <HOUR>
    { return TypeId.INTERVAL_HOUR_ID; }
|
    <MINUTE>
    { return TypeId.INTERVAL_MINUTE_ID; }
}



void
qualifiedNameList(List<TableName> list) throws StandardException :
{}
{
    qualifiedNameElement(list) 
    ( <COMMA> qualifiedNameElement(list) )*
}

void 
qualifiedNameElement(List<TableName> list) throws StandardException :
{
    TableName qualifiedName = null;
}
{
    qualifiedName = qualifiedName()
    {
        list.add(qualifiedName);
    }
}

TableName
qualifiedName(int nodeType) throws StandardException :
{
//String    catalogName = null;
    String  schemaName = null;
    String  qualifiedId;
    String  firstName = null;
    String  secondName = null;
}
{
    firstName = identifierDeferCheckLength()
    [
        // This LOOKAHEAD is necessary because a selectSublist() can be a
        // qualifiedName.*. Make sure that the token after the PERIOD is
        // not an ASTERISK before committing to this optional element.
        LOOKAHEAD( { getToken(1).kind == PERIOD && getToken(2).kind != ASTERISK } )
        <PERIOD> secondName = identifierDeferCheckLength()
    ]
    {
        if (secondName == null) {
            qualifiedId = firstName;
        }
        else {
            schemaName = firstName;
            qualifiedId = secondName;
        }

        parserContext.checkIdentifierLengthLimit(qualifiedId);
        if (schemaName != null)
            parserContext.checkIdentifierLengthLimit(schemaName);

        return (TableName)nodeFactory.getNode(nodeType,
                                              schemaName,
                                              qualifiedId,
                                              new Integer(lastIdentifierToken.beginOffset),
                                              new Integer(lastIdentifierToken.endOffset),
                                              parserContext);
    }
}

/*
 * We have to be carefull to get the associativity correct. 
 * According to the SQL spec:
 *   <non-join query expression> ::=
 *       <non-join query term>
 *      | <query expression body> UNION [ ALL ] <query term>
 *      | <query expression body> EXCEPT [ ALL ] <query term>
 * Meaning that
 *   t1 UNION ALL t2 UNION t3
 * is equivalent to
 *   (t1 UNION ALL t2) UNION t3
 * However recursive descent parsers want recursion to be on the
 * right, so this kind of associativity is unnatural for our
 * parser. The queryExpression method must know whether it is being
 * called as the right hand side of a set operator to produce a query
 * tree with the correct associativity.
 */
ResultSetNode
queryExpression(ResultSetNode leftSide, int operatorType) throws StandardException :
{
    ResultSetNode term;
}
{
    term = nonJoinQueryTerm(leftSide, operatorType) 
    [ term = unionOrExcept(term) ]
    {
        return term;
    }
}

ResultSetNode
unionOrExcept(ResultSetNode term) throws StandardException :
{
    ResultSetNode expression;
    Token tok = null;
}
{
    <UNION> [ tok = <ALL> | <DISTINCT> ] 
    // TODO: Is this right? DISTINCT doesn't matter to queryExpression?
    expression = queryExpression(term, (tok != null) ? UNION_ALL_OP : UNION_OP)
    {
        if ((tok != null) && (tok.kind == DISTINCT)) { 
            forbidNextValueFor(); 
        }
        return expression;
    }
|
    <EXCEPT> [ tok = <ALL> | <DISTINCT> ] 
    expression = queryExpression(term, (tok != null) ? EXCEPT_ALL_OP : EXCEPT_OP)
    {
        if ((tok != null) && (tok.kind == DISTINCT)) {
            forbidNextValueFor(); 
        }
        return expression;
    }
}

/*
 * Be careful with the associativity of INTERSECT. 
 * According to the SQL spec:
 *   t1 INTERSECT t2 INTERSECT ALL t3
 * is equivalent to
 *   (t1 INTERSECT t2) INTERSECT ALL t3
 * which is not the same as
 *   t1 INTERSECT (t2 INTERSECT ALL t3)
 * See the comment on queryExpression.
 */
ResultSetNode
nonJoinQueryTerm(ResultSetNode leftSide, int operatorType) throws StandardException :
{
    ResultSetNode term;
}
{
    term = nonJoinQueryPrimary() 
    [ term = intersect( term) ]
    {
        switch( operatorType) {
        case NO_SET_OP:
            return term;

        case UNION_OP:
            return (ResultSetNode)nodeFactory.getNode(NodeTypes.UNION_NODE,
                                                      leftSide,
                                                      term,
                                                      Boolean.FALSE,
                                                      Boolean.FALSE,
                                                      null,
                                                      parserContext);

        case UNION_ALL_OP:
            return (ResultSetNode)nodeFactory.getNode(NodeTypes.UNION_NODE,
                                                      leftSide,
                                                      term,
                                                      Boolean.TRUE,
                                                      Boolean.FALSE,
                                                      null,
                                                      parserContext);

        case EXCEPT_OP:
            return (ResultSetNode)nodeFactory.getNode(NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                                                      IntersectOrExceptNode.OpType.EXCEPT,
                                                      leftSide,
                                                      term,
                                                      Boolean.FALSE,
                                                      null,
                                                      parserContext);

        case EXCEPT_ALL_OP:
            return (ResultSetNode)nodeFactory.getNode(NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                                                      IntersectOrExceptNode.OpType.EXCEPT,
                                                      leftSide,
                                                      term,
                                                      Boolean.TRUE,
                                                      null,
                                                      parserContext);

        case INTERSECT_OP:
            return (ResultSetNode)nodeFactory.getNode(NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                                                      IntersectOrExceptNode.OpType.INTERSECT,
                                                      leftSide,
                                                      term,
                                                      Boolean.FALSE,
                                                      null,
                                                      parserContext);

        case INTERSECT_ALL_OP:
            return (ResultSetNode)nodeFactory.getNode(NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                                                      IntersectOrExceptNode.OpType.INTERSECT,
                                                      leftSide,
                                                      term,
                                                      Boolean.TRUE,
                                                      null,
                                                      parserContext);

        default:
            assert false : "Invalid set operator type: " + operatorType;
            return null;
        }
    }
}

ResultSetNode
intersect(ResultSetNode term) throws StandardException :
{
    ResultSetNode expression;
    Token tok = null;
}
{
    <INTERSECT> [ tok = <ALL> | <DISTINCT> ] 
    expression = nonJoinQueryTerm(term, (tok != null) ? INTERSECT_ALL_OP : INTERSECT_OP)
    {
        if ((tok != null) && (tok.kind == DISTINCT)) { 
            forbidNextValueFor(); 
        }
        return expression;
    }
}

ResultSetNode
nonJoinQueryPrimary() throws StandardException :
{
    ResultSetNode    primary;
}
{
    primary = simpleTable()
    {
        return primary;
    }
|
    <LEFT_PAREN> primary = queryExpression(null, NO_SET_OP) <RIGHT_PAREN>
    {
        return primary;
    }
}

ResultSetNode
simpleTable() throws StandardException :
{
    ResultSetNode resultSetNode;
}
{
    resultSetNode = querySpecification()
    {
        return resultSetNode;
    }
|
    resultSetNode = tableValueConstructor()
    {
        return resultSetNode;
    }
}

ResultSetNode
querySpecification() throws StandardException :
{
    ResultColumnList selectList;
    SelectNode selectNode;
    boolean isDistinct = false;
    Token straightJoin = null;
}
{
    <SELECT> 
    [ LOOKAHEAD( { straightJoinFollows() } )
      straightJoin = <STRAIGHT_JOIN> ]
    [ isDistinct = setQuantifier() ]
    [ LOOKAHEAD( { (straightJoin == null) && straightJoinFollows() } )
      straightJoin = <STRAIGHT_JOIN> ]
    selectList = selectList()
    selectNode = tableExpression(selectList)
    {
        if (isDistinct) selectNode.makeDistinct();
        if (straightJoin != null) selectNode.makeStraightJoin();
        return selectNode;
    }
}

boolean
setQuantifier() :
{}
{
    // This LOOKAHEAD is required to distinquish distinct from a class
    // which starts with distinct (e.g., distinct::).
    LOOKAHEAD( { getToken(1).kind == DISTINCT &&
                                 !(getToken(2).kind == PERIOD || getToken(2).kind == DOUBLE_COLON) } )
    <DISTINCT>
    {
        forbidNextValueFor();
        return true;
    }
|
    // This LOOKAHEAD is required to distinquish all from a class which
    // starts with all (e.g., all::).
    LOOKAHEAD( { getToken(1).kind == ALL &&
                                 !(getToken(2).kind == PERIOD || getToken(2).kind == DOUBLE_COLON) } )
    <ALL>
    {
        return false;
    }
}

ResultColumnList
selectList() throws StandardException :
{
    ResultColumn allResultColumn;
    ResultColumnList resultColumns = (ResultColumnList)
        nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                            parserContext);
}
{
    selectColumnList(resultColumns)
    {
        return resultColumns;
    }
}

void
selectColumnList(ResultColumnList resultColumns) throws StandardException :
{}
{
    selectSublist(resultColumns)
    ( <COMMA> selectSublist(resultColumns) )*
}

void
selectSublist(ResultColumnList resultColumns) throws StandardException :
{
    ResultColumn resultColumn;
    ResultColumn allResultColumn;
    TableName tableName;
}
{
    <ASTERISK>
    {
        allResultColumn = (ResultColumn)nodeFactory.getNode(NodeTypes.ALL_RESULT_COLUMN,
                                                            Boolean.FALSE,
                                                            parserContext);
        resultColumns.addResultColumn(allResultColumn);
    }
|
    <ASTERISK_ASTERISK>
    {
        allResultColumn = (ResultColumn)nodeFactory.getNode(NodeTypes.ALL_RESULT_COLUMN,
                                                            Boolean.TRUE,
                                                            parserContext);
        resultColumns.addResultColumn(allResultColumn);
    }
|
    // This LOOKAHEAD is required because both a qualifiedName() and a
    // derivedColumn() can start with an identifier().  So, the two
    // cases we check for are x.* and x.y.*
    // NOTE: It is hard to check for an identifier() using semantic lookahead.
    LOOKAHEAD( { getToken(2).kind == PERIOD &&
                                 (getToken(3).kind == ASTERISK || 
                                    (getToken(4).kind == PERIOD && getToken(5).kind == ASTERISK)) } )
    tableName = qualifiedName() <PERIOD> <ASTERISK>
    {
        allResultColumn = (ResultColumn)nodeFactory.getNode(NodeTypes.ALL_RESULT_COLUMN,
                                                            tableName,
                                                            parserContext);
        resultColumns.addResultColumn(allResultColumn);
    }
|
    resultColumn = derivedColumn(resultColumns)
    {
        resultColumns.addResultColumn(resultColumn);
    }
}

ResultColumn
derivedColumn(ResultColumnList resultColumns) throws StandardException :
{
    ValueNode columnExpression;
    String columnName = null;
}
{
    columnExpression = valueExpression()
    [ columnName = asClause() ]
    { 
        /* If there is no AS clause, and the expression is a simple
         * column, use the name of the column as the result column name.
         */
        if ((columnName == null) && (columnExpression instanceof ColumnReference)) {
            columnName = ((ColumnReference)columnExpression).getColumnName();
        }
        return (ResultColumn)nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                                 columnName,
                                                 columnExpression,
                                                 parserContext);
    }
}

String
asClause() throws StandardException :
{
    String columnName;
}
{
    [ <AS> ] columnName = identifier()
    {
        return columnName;
    }
}

ValueNode
valueExpression() throws StandardException :
{
    ValueNode leftOperand;
}
{
    leftOperand = orExpression(null)
    ( <OR> leftOperand = orExpression(leftOperand) )*
    {
        return leftOperand;
    }
}
    
ValueNode
orExpression(ValueNode farLeftOperand) throws StandardException :
{
    ValueNode leftOperand;
}
{
    leftOperand = andExpression(null)
    ( <AND> leftOperand = andExpression(leftOperand))*
    {
        if (farLeftOperand == null) {
            return leftOperand;
        }
        else {
            return (ValueNode)nodeFactory.getNode(NodeTypes.OR_NODE,
                                                  farLeftOperand,
                                                  leftOperand,
                                                  parserContext);
        }
    }
}

ValueNode
andExpression(ValueNode farLeftOperand) throws StandardException :
{
    Token notToken = null;
    ValueNode test;
}
{
    // This LOOKAHEAD is required to tell that NOT is not part of a class name.
    [ LOOKAHEAD( { getToken(1).kind == NOT && 
                                     !(getToken(2).kind == PERIOD || getToken(2).kind == DOUBLE_COLON) } )
        notToken = <NOT> ]
    test = isSearchCondition() 
    {
        /* Put any NOT on top of test */
        if (notToken != null) {
            test = (ValueNode)nodeFactory.getNode(NodeTypes.NOT_NODE,
                                                  test,
                                                  parserContext);
        }
        if (farLeftOperand != null) {
            test = (ValueNode)nodeFactory.getNode(NodeTypes.AND_NODE,
                                                  farLeftOperand,
                                                  test,
                                                  parserContext);
        }
        return test;
    }
}

ValueNode
isSearchCondition() throws StandardException :
{
    ValueNode result;
    ValueNode booleanPrimary;
    Token isToken = null;
    Token notToken = null;
    ValueNode truthValue = null;
}
{
    booleanPrimary = booleanPrimary()
    [ isToken = <IS> [ notToken = <NOT> ] truthValue = truthValue() ]
    {
        if (isToken != null) {
            if (truthValue == null)
                result = (ValueNode)nodeFactory.getNode(NodeTypes.IS_NULL_NODE,
                                                        booleanPrimary,
                                                        parserContext);
            else
                result = (ValueNode)nodeFactory.getNode(NodeTypes.IS_NODE,
                                                        booleanPrimary,
                                                        truthValue,
                                                        parserContext);
            /* Put any NOT on top of the tree */
            if (notToken != null) {
                result = (ValueNode)nodeFactory.getNode(NodeTypes.NOT_NODE,
                                                        result,
                                                        parserContext);
            }
        }
        else { 
            result = booleanPrimary; 
        }
        return result;
    }
}

ValueNode truthValue() throws StandardException :
{
    Boolean value;
}
{
(
    <NULL> { return null; }
|
    <TRUE> { value = Boolean.TRUE; }
|
    <FALSE> { value = Boolean.FALSE; }
|
    <UNKNOWN> { value = null; }
)
    {
        return (ValueNode)
            nodeFactory.getNode(NodeTypes.BOOLEAN_CONSTANT_NODE, 
                                value, 
                                parserContext);
    }
}

ValueNode
booleanPrimary() throws StandardException :
{
    ValueNode primary;
    ValueNode searchCondition;
}
{
    primary = predicate()
    {
        return  primary;
    }
}

ValueNode
predicate() throws StandardException :
{
    ValueNode value;
}
{
(
     LOOKAHEAD( {rowValueConstructorListFollows()} )
     value = rowCtor(new int[] {0})
|
     value = additiveExpression() 
|
     value = existsExpression()
)
    (
        // This LOOKAHEAD is necessary because remainingPredicate() can
        // start with NOT, and what follows a predicate() can also start
        // with NOT.
        LOOKAHEAD( { remainingPredicateFollows() } )
        value = remainingPredicate(value)
    )*
    {
        return value;
    }
/*
** RESOLVE: overlapsExpression commented out for the time being to avoid
** a left recursion.    An OVERLAPS expression is defined as taking row
** constructors as parameters.  A row constructor contains a valueExpression
** as its first element, so it can't return be the first element in a
** valueExpression.
|
    overlapsExpression()
    {
        return null;
    }
*/
}

ValueNode
remainingPredicate(ValueNode value) throws StandardException :
{
    Token notToken = null;
}
{
    value = remainingNonNegatablePredicate(value)
    {
        return value;
    }
|
    [ notToken = <NOT> ] value = remainingNegatablePredicate(value)
    {
        /* Put any NOT on top of the tree */
        if (notToken != null) {
            value = (ValueNode)nodeFactory.getNode(NodeTypes.NOT_NODE,
                                                   value,
                                                   parserContext);
        }
        return value;
    }
}

ValueNode 
remainingNonNegatablePredicate(ValueNode leftOperand) throws StandardException :
{
    BinaryOperatorNode.OperatorType operator;
    SubqueryNode.SubqueryType subqueryType;
    String javaClassName;
    Token tok = null;
    ValueNode tree = null;
    ValueNode likePattern;
    ValueNode betweenLeft;
    ValueNode betweenRight;
}
{
    operator = compOp()
    (
        // This LOOKAHEAD is required to tell ALL, ANY or SOME from a
        // class which starts with these words (e.g., ALL::)
        LOOKAHEAD( { (getToken(1).kind == ALL || getToken(1).kind == ANY || 
                                    getToken(1).kind == SOME)
                                     && getToken(2).kind == LEFT_PAREN } )
        (
            subqueryType = quantifier(operator)
            <LEFT_PAREN> leftOperand = tableSubquery(subqueryType, leftOperand) <RIGHT_PAREN>
        )
        |
        (
//            leftOperand = rowCtor()
  //          |
            leftOperand = additiveExpression(leftOperand, operator)
        )
    )
    {
        return leftOperand;
    }
}

ValueNode 
remainingNegatablePredicate(ValueNode leftOperand) throws StandardException :
{
    ValueNode tree = null;
    ValueNode likePattern;
    ValueNode betweenLeft;
    ValueNode betweenRight;
    ValueNode escapeValue = null;
}
{
    <DUMMY> tree = rowCtor(new int[]{0})
    {
        return tree;
    }
|
    <IN> tree = inPredicateValue(leftOperand)
    {
        return tree;
    }
|
    <LIKE> likePattern = additiveExpression()
    [
        <ESCAPE> escapeValue = additiveExpression() 
    |
        <LEFT_BRACE> <ESCAPE> escapeValue = additiveExpression() <RIGHT_BRACE>
    ]
    {
        tree = (ValueNode)nodeFactory.getNode(NodeTypes.LIKE_OPERATOR_NODE,
                                              leftOperand,
                                              likePattern,
                                              escapeValue,
                                              parserContext);
        
        return tree;
    }
|
    <BETWEEN> betweenLeft = additiveExpression() 
            <AND> betweenRight = additiveExpression()
    {
        ValueNodeList betweenList = (ValueNodeList)
            nodeFactory.getNode(NodeTypes.VALUE_NODE_LIST,
                                parserContext);
        betweenList.addValueNode(betweenLeft);
        betweenList.addValueNode(betweenRight);
        tree = (ValueNode)nodeFactory.getNode(NodeTypes.BETWEEN_OPERATOR_NODE,
                                              leftOperand,
                                              betweenList,
                                              parserContext);
        
        return tree;
    }
}

BinaryOperatorNode.OperatorType
compOp() throws StandardException :
{}
{
    <EQUALS_OPERATOR>
    {
        return BinaryOperatorNode.OperatorType.EQ;
    }
|
    <NOT_EQUALS_OPERATOR>
    {
        return BinaryOperatorNode.OperatorType.NE;
    }
|
    <NOT_EQUALS_OPERATOR2>
    {
        return BinaryOperatorNode.OperatorType.NE;
    }
|
    <LESS_THAN_OPERATOR>
    {
        return BinaryOperatorNode.OperatorType.LT;
    }
|
    <GREATER_THAN_OPERATOR>
    {
        return BinaryOperatorNode.OperatorType.GT;
    }
|
    <LESS_THAN_OR_EQUALS_OPERATOR>
    {
        return BinaryOperatorNode.OperatorType.LE;
    }
|
    <GREATER_THAN_OR_EQUALS_OPERATOR>
    {
        return BinaryOperatorNode.OperatorType.GE;
    }
}

ValueNode
additiveExpression(ValueNode farLeftOperand, BinaryOperatorNode.OperatorType compOp) 
        throws StandardException :
{
    ValueNode leftOperand;
    BinaryOperatorNode.OperatorType operator;
    String collation = null;
}
{
    leftOperand = multiplicativeExpression(null, null)
    ( operator = additiveOperator()
      leftOperand = multiplicativeExpression(leftOperand, operator) 
    )*
    [ collation = collateClause() ]
    {
        if (farLeftOperand != null) {
            int nodeType;
            switch (compOp) {
            case EQ:
                nodeType = NodeTypes.BINARY_EQUALS_OPERATOR_NODE;
                break;

            case NE:
                nodeType = NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE;
                break;

            case LT:
                nodeType = NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE;
                break;

            case GT:
                nodeType = NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE;
                break;

            case LE:
                nodeType = NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE;
                break;

            case GE:
                nodeType = NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE;
                break;

            default:
                assert false : "Unknown comparison operator " + compOp;
                nodeType = 0;
                break;
            }
            leftOperand = (ValueNode)nodeFactory.getNode(nodeType,
                                                         farLeftOperand,
                                                         leftOperand,
                                                         parserContext);
        }
        if (collation != null)
            leftOperand = (ValueNode)nodeFactory.getNode(NodeTypes.EXPLICIT_COLLATE_NODE,
                                                         leftOperand,
                                                         collation,
                                                         parserContext);
        return leftOperand;
    }
}

BinaryOperatorNode.OperatorType
additiveOperator() throws StandardException :
{
    BinaryOperatorNode.OperatorType operator;
}
{    
    <PLUS_SIGN> 
    {
        return BinaryOperatorNode.OperatorType.PLUS;
    }
|
    <MINUS_SIGN>
    {
        return BinaryOperatorNode.OperatorType.MINUS;
    }
|
    LOOKAHEAD( { infixBitFollows() } )
    operator = infixBitOperator()
    {
        return operator;
    }
}

BinaryOperatorNode.OperatorType
infixBitOperator() throws StandardException :
{
}
{    
    <AMPERSAND>
    {
        return BinaryOperatorNode.OperatorType.BITAND;
    }
|
    <VERTICAL_BAR>
    {
        return BinaryOperatorNode.OperatorType.BITOR;
    }
|
    <CARET>
    {
        return BinaryOperatorNode.OperatorType.BITXOR;
    }
|
    <DOUBLE_LESS>
    {
        return BinaryOperatorNode.OperatorType.LEFT_SHIFT;
    }
|
    <DOUBLE_GREATER>
    {
        return BinaryOperatorNode.OperatorType.RIGHT_SHIFT;
    }
}

ValueNode
multiplicativeExpression(ValueNode farLeftOperand,
                         BinaryOperatorNode.OperatorType additiveOperator) 
        throws StandardException :
{
    ValueNode leftOperand;
    BinaryOperatorNode.OperatorType multOp;
}
{
    leftOperand = unaryExpression(null, null)
    ( multOp = multiplicativeOperator()
        leftOperand = unaryExpression(leftOperand, multOp) 
    )*
    {
        if (farLeftOperand == null)
            return leftOperand;

        switch (additiveOperator) {
        case PLUS:
            return (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_PLUS_OPERATOR_NODE,
                                                  farLeftOperand,
                                                  leftOperand,
                                                  parserContext);

        case MINUS:
            return (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_MINUS_OPERATOR_NODE,
                                                  farLeftOperand,
                                                  leftOperand,
                                                  parserContext);

        case BITAND:
        case BITOR:
        case BITXOR:
        case LEFT_SHIFT:
        case RIGHT_SHIFT:
            return (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_BIT_OPERATOR_NODE,
                                                  additiveOperator,
                                                  farLeftOperand,
                                                  leftOperand,
                                                  parserContext);

        default:
            assert false : "Unexpected operator value of " + additiveOperator;
            return null;
        }
    }
}

BinaryOperatorNode.OperatorType
multiplicativeOperator() throws StandardException :
{}
{
    LOOKAHEAD ( {infixModFollows()} )
    (<MOD> | <PERCENT>)
    {
        return BinaryOperatorNode.OperatorType.MOD;
    }
|
    LOOKAHEAD ({divOperatorFollows()})
    <DIV>
    {
        return BinaryOperatorNode.OperatorType.DIV;
    }
|
    <ASTERISK> 
    {
        return BinaryOperatorNode.OperatorType.TIMES;
    }
|
    <SOLIDUS>
    {
        return BinaryOperatorNode.OperatorType.DIVIDE;
    }
|
    <CONCATENATION_OPERATOR>
    {
        return BinaryOperatorNode.OperatorType.CONCATENATE;
    }
}

ValueNode
unaryExpression(ValueNode farLeftOperand,
                BinaryOperatorNode.OperatorType multiplicativeOperator) 
        throws StandardException :
{
    ValueNode value;
    String sign = null;
}
{
    [
    (
        LOOKAHEAD( { unaryArithmeticFollows() } )
        sign = sign()
    |
        LOOKAHEAD( { unaryBitFollows() })
        sign = unaryBitOperator()
    )
    ]
    value = primaryExpression()
    {
        if ("-".equals(sign)) {
            value = (ValueNode)nodeFactory.getNode(NodeTypes.UNARY_MINUS_OPERATOR_NODE,
                                                   value,
                                                   parserContext);
        }
        else if ("+".equals(sign)) {
            value = (ValueNode)nodeFactory.getNode(NodeTypes.UNARY_PLUS_OPERATOR_NODE,
                                                   value,
                                                   parserContext);
        }
        else if ("~".equals(sign)) {
            value = (ValueNode)nodeFactory.getNode(NodeTypes.UNARY_BITNOT_OPERATOR_NODE,
                                                   value,
                                                   parserContext);
        }
        else {
            assert (sign == null) : "Unknown unary operator '" + sign + "'";
        }
        return multOp(farLeftOperand, value, multiplicativeOperator);
    }
}

String
sign() :
{
    Token s;
}
{
    s = <PLUS_SIGN>
    {
        return s.image;
    }
|
    s = <MINUS_SIGN>
    {
        return s.image;
    }
}

String
unaryBitOperator() :
{
    Token s;
}
{
    s = <TILDE>
    {
        return s.image;
    }
}

ValueNode
primaryExpressionXX() throws StandardException :
{
    ValueNode value;
}
{
    value = primary()
    ( value = nonStaticMethodCallOrFieldAccess(value) )*    
    {
        return value;
    }
}

ValueNode
nonStaticMethodCallOrFieldAccess(ValueNode receiver) throws StandardException :
{
    ValueNode value;
}
{
    value = nonStaticMethodInvocation(receiver)
    {
        return value;
    }
}

ValueNode
nonStaticMethodInvocation(ValueNode receiver) throws StandardException :
{
    List<ValueNode> parameterList = new ArrayList<ValueNode>();
    MethodCallNode methodNode;
    ParameterNode parameterNode;
}
{
    LOOKAHEAD( { getToken(3).kind == LEFT_PAREN } )
    ( <FIELD_REFERENCE> | <PERIOD> )
    methodNode = methodName(receiver) 
    methodCallParameterList(parameterList)
    {
        /*
        ** ? parameters are not allowed for the receiver --
        ** unless the receiver is standing in for a named parameter,
        ** whose type is therefore known.
        */
        if (receiver instanceof ParameterNode) {
            throw new StandardException("Parameter not allowed for method receiver");
        }
        methodNode.addParms(parameterList);

        /*
        ** Assume this is being returned to the SQL domain.  If it turns
        ** out that this is being returned to the Java domain, we will
        ** get rid of this node.
        */
        return (ValueNode)nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                              methodNode,
                                              parserContext);
    }
|
    <PERIOD> methodNode = methodName(receiver)
    {
        /*
        ** ? parameters are not allowed for the receiver --
        ** unless the receiver is standing in for a named parameter,
        ** whose type is therefore known.
        */
        if (receiver instanceof ParameterNode) {
            throw new StandardException("Parameter not allowed for method receiver");
        }

        methodNode.addParms(parameterList);

        /*
        ** Assume this is being returned to the SQL domain.  If it turns
        ** out that this is being returned to the Java domain, we will
        ** get rid of this node.
        */
        return (ValueNode)nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                              methodNode,
                                              parserContext);
    }
}

MethodCallNode
methodName(ValueNode receiver) throws StandardException :
{
    String methodName;
}
{
    /*
    ** NOTE: allowing a delimited identifier as a method name is necessary,
    ** because Java is case-sensitive.  But this also allows identifiers that
    ** do not match Java syntax.    This will probably not cause a problem
    ** in later phases, like binding and code generation.
    */
    methodName = caseSensitiveIdentifierPlusReservedWords()
    {
        return (MethodCallNode)nodeFactory.getNode(NodeTypes.NON_STATIC_METHOD_CALL_NODE,
                                                   methodName,
                                                   receiver,
                                                   parserContext);
    }
}

MethodCallNode
staticMethodName(String javaClassName) throws StandardException :
{
    String methodName;
}
{
    /*
    ** NOTE: allowing a delimited identifier as a method name is necessary,
    ** because Java is case-sensitive.  But this also allows identifiers that
    ** do not match Java syntax.    This will probably not cause a problem
    ** in later phases, like binding and code generation.
    */
    methodName = caseSensitiveIdentifierPlusReservedWords()
    {
        return (MethodCallNode)nodeFactory.getNode(NodeTypes.STATIC_METHOD_CALL_NODE,
                                                   methodName,
                                                   javaClassName,
                                                   parserContext);
    }
}

void
methodParameter(List<ValueNode> parameterList) throws StandardException :
{
    ValueNode parameter;
}
{
    parameter = valueExpression()
    {
        parameterList.add(parameter);
    }
}

ValueNode
primary() throws StandardException :
{
    String javaClassName;
    ValueNode value;
}
{
    // This LOOKAHEAD is required to tell a Java class from a identifier.
    LOOKAHEAD( { javaClassFollows() } )
    value = staticClassReference()
    {
        return value;
    }
|
    value = valueExpressionPrimary()
    {
        return value;
    }
}

ValueNode
staticClassReference() throws StandardException :
{
    String javaClassName;
    ValueNode value;
}
{
    javaClassName = javaClass() <DOUBLE_COLON> 
        value = staticClassReferenceType(javaClassName)
    {
        return value;
    }
}

ValueNode
staticClassReferenceType(String javaClassName) throws StandardException :
{
    ValueNode value;
}
{
    // This LOOKAHEAD is required to tell method from field reference.
    LOOKAHEAD( { (getToken(2).kind == LEFT_PAREN) } )
    value = staticMethodInvocation(javaClassName) 
    {
        return value;
    }
|
    value = staticClassFieldReference(javaClassName) 
    {
        return value;
    }
}

ValueNode
staticClassFieldReference(String javaClassName) throws StandardException :
{
    String fieldName;
}
{
    fieldName = caseSensitiveIdentifierPlusReservedWords() 
    {
        return (ValueNode)
            nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                nodeFactory.getNode(NodeTypes.STATIC_CLASS_FIELD_REFERENCE_NODE,
                                                    javaClassName,
                                                    fieldName,
                                                    nextToLastTokenDelimitedIdentifier,
                                                    parserContext),
                                parserContext);
    }
}

ExtractOperatorNode.Field
nonSecondDatetimeField() :
{}
{
    <YEAR> 
    {
        return ExtractOperatorNode.Field.YEAR;
    }
|
    <MONTH> 
    {
        return ExtractOperatorNode.Field.MONTH;
    }
|
    <DAY> 
    {
        return ExtractOperatorNode.Field.DAY;
    }
|
    <HOUR> 
    {
        return ExtractOperatorNode.Field.HOUR;
    }
|
    <MINUTE>
    {
        return ExtractOperatorNode.Field.MINUTE;
    }
}

ValueNode
escapedValueFunction() throws StandardException :
{
    ValueNode value;
    ValueNode str1;
    ValueNode str2;
    ValueNode startPosition;
    ValueNode length = null;
}
{
    value = miscBuiltinsCore(true)
    {
        return value;
    }
|
    /* CURDATE() is an escaped function supported by JCC 2.2 or higher */
    <CURDATE> <LEFT_PAREN> <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                              CurrentDatetimeOperatorNode.Field.DATE,
                                              parserContext);
    }
|
    /* CURTIME() is an escaped function supported by JCC 2.2 or higher */
    <CURTIME> <LEFT_PAREN> <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                              CurrentDatetimeOperatorNode.Field.TIME,
                                              parserContext);
    }
|
    /* Escaped function CONCAT(string1, string2) */
    <CONCAT> <LEFT_PAREN> str1 = additiveExpression() 
    <COMMA> str2 = additiveExpression() 
    <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CONCATENATION_OPERATOR_NODE,
                                              str1,
                                              str2,
                                              parserContext);
    }
|
    /* Method versions of USER special registers are ODBC remnants.
     * Only supported when escaped.
     */
    value = userNode() <LEFT_PAREN> <RIGHT_PAREN>
    {
        return value;
    }
|       
    LOOKAHEAD( { getEscapedSYSFUN(getToken(1).image) != null } )
    value = escapedSYSFUNFunction()
    {
        return value;
    }
}

ValueNode
escapedSYSFUNFunction() throws StandardException :
{
    List<ValueNode> parameterList = new ArrayList<ValueNode>();
    Token tok;
}
{
    tok = <IDENTIFIER> methodCallParameterList(parameterList)
    {
        String sysFunName = getEscapedSYSFUN(tok.image);
            
        TableName functionName = (TableName)nodeFactory.getNode(NodeTypes.TABLE_NAME,
                                                                IBM_SYSTEM_FUN_SCHEMA_NAME,
                                                                sysFunName,
                                                                new Integer(0),
                                                                new Integer(0),
                                                                parserContext);
         
        MethodCallNode methodNode = (MethodCallNode)nodeFactory.getNode(NodeTypes.STATIC_METHOD_CALL_NODE,
                                                                        functionName,
                                                                        null,
                                                                        parserContext);

        methodNode.addParms(parameterList);

        /*
        ** Assume this is being returned to the SQL domain.  If it turns
        ** out that this is being returned to the Java domain, we will
        ** get rid of this node.
        */
        return (ValueNode)nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                              methodNode,
                                              parserContext);
    }
}

ValueNode
timestampArithmeticFuncion() throws StandardException :
{
    DataTypeDescriptor intervalTypeDesc;
    ValueNode intervalType;
    ValueNode tstamp1;
    ValueNode tstamp2;
    ValueNode interval;
    int[] factors = new int[] { 1, 1 };
}
{
    <TIMESTAMPADD> <LEFT_PAREN> intervalTypeDesc = jdbcIntervalTypeDescriptor(factors) 
    <COMMA> interval = additiveExpression()
    <COMMA> tstamp1 = additiveExpression() 
    <RIGHT_PAREN>
    {
        interval = (ValueNode)nodeFactory.getNode(NodeTypes.CAST_NODE,
                                               interval, intervalTypeDesc,    
                                               parserContext);
        if (factors[0] != 1)
            interval = (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_TIMES_OPERATOR_NODE,
                                                   interval,
                                                   nodeFactory.getNode(NodeTypes.INT_CONSTANT_NODE,
                                                                       Integer.valueOf(factors[0]),
                                                                       parserContext),
                                                   parserContext);
        if (factors[1] != 1)
            interval = (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_DIVIDE_OPERATOR_NODE,
                                                   interval,
                                                   nodeFactory.getNode(NodeTypes.INT_CONSTANT_NODE,
                                                                       Integer.valueOf(factors[1]),
                                                                       parserContext),
                                                   parserContext);
                 
        return (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_PLUS_OPERATOR_NODE,
                                                  tstamp1,
                                                  interval,
                                                  parserContext);
    }
|
    <TIMESTAMPDIFF> <LEFT_PAREN> intervalType = jdbcIntervalType() 
    <COMMA> tstamp1 = additiveExpression() 
    <COMMA> tstamp2 = additiveExpression() 
    <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.TIMESTAMP_DIFF_FN_NODE,
                                              intervalType,
                                              tstamp1,
                                              tstamp2,
                                              TernaryOperatorNode.OperatorType.TIMESTAMPDIFF,
                                              null,
                                              parserContext);
    }
}        
       
ValueNode
jdbcIntervalType() throws StandardException :
{}
{
    (<SQL_TSI_FRAC_SECOND> | <MICROSECOND>)
    {
        return getJdbcIntervalNode(TernaryOperatorNode.FRAC_SECOND_INTERVAL);
    }
|
    (<SQL_TSI_SECOND> | <SECOND>)
    {
        return getJdbcIntervalNode(TernaryOperatorNode.SECOND_INTERVAL);
    }
|
    (<SQL_TSI_MINUTE> | <MINUTE>)
    {
        return getJdbcIntervalNode(TernaryOperatorNode.MINUTE_INTERVAL);
    }
|
    (<SQL_TSI_HOUR> | <HOUR>)
    {
        return getJdbcIntervalNode(TernaryOperatorNode.HOUR_INTERVAL);
    }
|
    (<SQL_TSI_DAY> | <DAY>)
    {
        return getJdbcIntervalNode(TernaryOperatorNode.DAY_INTERVAL);
    }
|
    (<SQL_TSI_WEEK> | <WEEK>)
    {
        return getJdbcIntervalNode(TernaryOperatorNode.WEEK_INTERVAL);
    }
|
    (<SQL_TSI_MONTH> | <MONTH>)
    {
        return getJdbcIntervalNode(TernaryOperatorNode.MONTH_INTERVAL);
    }
|
    (<SQL_TSI_QUARTER> | <QUARTER>)
    {
        return getJdbcIntervalNode(TernaryOperatorNode.QUARTER_INTERVAL);
    }
|
    (<SQL_TSI_YEAR> | <YEAR>)
    {
        return getJdbcIntervalNode(TernaryOperatorNode.YEAR_INTERVAL);
    }
}

DataTypeDescriptor 
jdbcIntervalTypeDescriptor(int[] factors) throws StandardException :
{
    TypeId typeId;
    int prec = 0, scale = 0;
}
{
(
    (<SQL_TSI_FRAC_SECOND> | <MICROSECOND>)
    {   
        typeId = TypeId.INTERVAL_SECOND_ID;
        scale = 6;
        factors[1] = 1000000;
    }
|
    (<SQL_TSI_SECOND> | <SECOND>)
    {
        typeId = TypeId.INTERVAL_SECOND_ID;
    }
|
    (<SQL_TSI_MINUTE> | <MINUTE>)
    {
        typeId = TypeId.INTERVAL_MINUTE_ID;
    }
|
    (<SQL_TSI_HOUR> | <HOUR>)
    {
        typeId = TypeId.INTERVAL_HOUR_ID;
    }
|
    (<SQL_TSI_DAY> | <DAY>)
    {
        typeId = TypeId.INTERVAL_DAY_ID;
    }
|
    (<SQL_TSI_WEEK> | <WEEK>)
    {
        typeId = TypeId.INTERVAL_DAY_ID;
        factors[0] = 7;
    }
|
    (<SQL_TSI_MONTH> | <MONTH>)
    {
        typeId = TypeId.INTERVAL_MONTH_ID;
    }
|
    (<SQL_TSI_QUARTER> | <QUARTER>)
    {
        typeId = TypeId.INTERVAL_MONTH_ID;
        factors[0] = 3;
    }
|
    (<SQL_TSI_YEAR> | <YEAR>)
    {
        typeId = TypeId.INTERVAL_YEAR_ID;
    }
)
    {
        return new DataTypeDescriptor(typeId, prec, scale,
                                      true, DataTypeDescriptor.intervalMaxWidth(typeId, prec, scale));
    }
}

ValueNode
numericValueFunction() throws StandardException :
{
    ValueNode value;
    int field;
}
{
    // NOTE: If you add a new rule here, you must add the appropriate
    // LOOKAHEAD rule to miscBuiltins().
    <ABS> value = absFunction()
    {
        return value;
    }
|
    <ABSVAL> value = absFunction()
    {
        return value;
    }
|
    <SQRT> <LEFT_PAREN> value = additiveExpression() <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.SQRT_OPERATOR_NODE,
                                              value,
                                              parserContext);
    }
|
    <MOD> value = modFunction()
    {
        return value;
    }
|
    <IDENTITY_VAL_LOCAL> <LEFT_PAREN> <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.IDENTITY_VAL_NODE,
                                              parserContext);
    }
}

ValueNode
coalesceFunction(String coalesceOrValue) throws StandardException :
{
    ValueNodeList expressionList = (ValueNodeList)nodeFactory.getNode(NodeTypes.VALUE_NODE_LIST,
                                                                      parserContext);
}
{
    <LEFT_PAREN> coalesceExpression(expressionList)
    ( <COMMA> coalesceExpression(expressionList) )* 
    <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.COALESCE_FUNCTION_NODE,
                                              coalesceOrValue,
                                              expressionList,
                                              parserContext);
    }
}

void
coalesceExpression(ValueNodeList expressionList) throws StandardException :
{
    ValueNode expression;
}
{
    expression = additiveExpression()
    {
        expressionList.addValueNode(expression);
    }
}

ValueNode
absFunction() throws StandardException :
{
    ValueNode value;
}
{
    <LEFT_PAREN> value = additiveExpression() <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.ABSOLUTE_OPERATOR_NODE,
                                              value,
                                              parserContext);
    }
}

ValueNode
modFunction() throws StandardException :
{
    ValueNode int1;
    ValueNode int2;
}
{
    <LEFT_PAREN> int1 = additiveExpression() 
    <COMMA> int2 = additiveExpression() 
    <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.MOD_OPERATOR_NODE,
                                              int1, int2,
                                              parserContext);
    }
}

ExtractOperatorNode.Field
datetimeField() :
{
    ExtractOperatorNode.Field field;
}
{
    field = nonSecondDatetimeField() 
    {
        return field;
    }
|
    <SECOND>
    {
        return ExtractOperatorNode.Field.SECOND;
    }
}

ValueNode
characterValueFunction() throws StandardException :
{
    ValueNode value = null;
    ValueNode str1;
    ValueNode str2;
    Token upperTok = null;
    Token lowerTok = null;
    ValueNode startPosition;
    ValueNode length = null;
}
{
    ( <SUBSTR> | <SUBSTRING> ) <LEFT_PAREN> value = additiveExpression() 
    <COMMA> startPosition = additiveExpression() 
    [ <COMMA> length = additiveExpression() ] 
    <RIGHT_PAREN>
    {
        return getSubstringNode(value, startPosition, length, Boolean.FALSE);
    }
|
    ( upperTok = <UPPER> | lowerTok = <LOWER> ) 
    <LEFT_PAREN> value = additiveExpression() <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.SIMPLE_STRING_OPERATOR_NODE,
                                              value,
                                              (upperTok != null) ? "upper" : "lower",
                                              parserContext);
    }
|
    ( upperTok = <UCASE> | lowerTok = <LCASE> ) 
    <LEFT_PAREN> value = additiveExpression() <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.SIMPLE_STRING_OPERATOR_NODE,
                                              value,
                                              (upperTok != null) ? "upper" : "lower",
                                              parserContext);
    }
|
    value = trimFunction()
    {
        return value;
    }
|
    <LOCATE> <LEFT_PAREN> str1 = additiveExpression() 
    (<COMMA> | <IN>)  str2 = additiveExpression()
    [ <COMMA> value = additiveExpression() ]
    <RIGHT_PAREN>
    {
        // If start is missing, start is equal to 1.
        return (ValueNode)nodeFactory.getNode(NodeTypes.LOCATE_FUNCTION_NODE,
                                              str1,
                                              str2,
                                              (value == null) ? nodeFactory.getNode(NodeTypes.INT_CONSTANT_NODE, 1, parserContext) : value,
                                              TernaryOperatorNode.OperatorType.LOCATE,
                                              null,
                                              parserContext);
    }
|
    <POSITION> <LEFT_PAREN> str1 = additiveExpression() 
    (<COMMA> | <IN>)  str2 = additiveExpression()
    <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.LOCATE_FUNCTION_NODE,
                                              str1,
                                              str2,
                                              nodeFactory.getNode(NodeTypes.INT_CONSTANT_NODE, 1, parserContext),
                                              TernaryOperatorNode.OperatorType.LOCATE,
                                              null,
                                              parserContext);
    }
|
    LOOKAHEAD ( {mysqlLeftRightFuncFollows()} )
    (
        <LEFT> <LEFT_PAREN> str1 = additiveExpression()
        <COMMA> str2 = additiveExpression()
        <RIGHT_PAREN>
        {
            return (ValueNode)nodeFactory.getNode(NodeTypes.LEFT_FN_NODE,
                                                    str1,
                                                    str2,
                                                    parserContext);
        }
    |   
        <RIGHT> <LEFT_PAREN> str1 = additiveExpression()
        <COMMA> str2 = additiveExpression()
        <RIGHT_PAREN>
        {
            return (ValueNode)nodeFactory.getNode(NodeTypes.RIGHT_FN_NODE,
                                                    str1,
                                                    str2,
                                                    parserContext);
        }
    )
}

ValueNode
trimFunction() throws StandardException :
{
    ValueNode source;
    BinaryOperatorNode.OperatorType trimType;

    ValueNode ansiTrimNode;
}
{
    trimType = trimType() <LEFT_PAREN> source = additiveExpression() <RIGHT_PAREN>
    {
        return getTrimOperatorNode(trimType, null, source);
    }
|
    <TRIM> ansiTrimNode = ansiTrim()
    {
        return ansiTrimNode;
    }
}

ValueNode
ansiTrim() throws StandardException  :
{
    BinaryOperatorNode.OperatorType trimType = BinaryOperatorNode.OperatorType.TRIM;
    ValueNode trimChar = null;
    ValueNode trimSource = null;
}
{
    LOOKAHEAD( { ansiTrimSpecFollows() } )
    <LEFT_PAREN> trimType = ansiTrimSpec()
    (
        // LEADING FROM <source>
        LOOKAHEAD( <FROM> )
        <FROM> trimSource = additiveExpression() <RIGHT_PAREN>
    {
        return getTrimOperatorNode(trimType, trimChar, trimSource);
    }
    |
        // LEADING <char> FROM <source>
        trimChar = additiveExpression() 
        <FROM> trimSource = additiveExpression() <RIGHT_PAREN>
    {
        return getTrimOperatorNode(trimType, trimChar, trimSource);
    }
    )
|
    LOOKAHEAD ( { !ansiTrimSpecFollows() } )
    <LEFT_PAREN> trimChar = additiveExpression()
    (
        <FROM> trimSource = additiveExpression() <RIGHT_PAREN>
    {
        return getTrimOperatorNode(trimType, trimChar, trimSource);
    }
    |
        <RIGHT_PAREN>
    {
        // expr was trim(e)-- we assigned e to trimChar but it is really the trimSource
        return getTrimOperatorNode(trimType, null, trimChar);
    }
    )
}

BinaryOperatorNode.OperatorType
ansiTrimSpec() :
{}
{
    <TRAILING>
    {
        return BinaryOperatorNode.OperatorType.RTRIM;
    }
|
    <LEADING>
    {
        return BinaryOperatorNode.OperatorType.LTRIM;
    }
|
    <BOTH>
    {
        return BinaryOperatorNode.OperatorType.TRIM;
    }
}

BinaryOperatorNode.OperatorType
trimType() :
{}
{
    <RTRIM>
    {
        return BinaryOperatorNode.OperatorType.RTRIM;
    }
|
    <LTRIM>
    {
        return BinaryOperatorNode.OperatorType.LTRIM;
    }
}

ValueNode
valueExpressionPrimary() throws StandardException :
{
    ValueNode value;
    int tokKind;
}
{
    // This LOOKAHEAD is required to distinguish a
    // escapedValueFunction() from other escaped clauses. The former
    // always has an FN as its second token.
    LOOKAHEAD( { escapedValueFunctionFollows() } )
    <LEFT_BRACE> <FN> value = escapedValueFunction() <RIGHT_BRACE>
    {
        return value;
    }
|
    LOOKAHEAD( { getToken(2).kind == SCHEMA || getToken(2).kind == SQLID } )
    <CURRENT> (<SCHEMA> | <SQLID>)
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_SCHEMA_NODE,
                                              parserContext);
    }
|
    LOOKAHEAD( { getToken(2).kind == ISOLATION } ) 
    <CURRENT> <ISOLATION>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_ISOLATION_NODE,
                                              parserContext);
    }
|
        // TODO: *** What is this comment about?
    /* Omitted "case_expression" */
    value = valueSpecification()
    {
        return value;
    }
|
    // This LOOKAHEAD is required to distinguish a newInvocation() from
    // an aggregateNode() and a columnReference(). It is necessary because
    // NEW is not a reserved word.
    LOOKAHEAD( { newInvocationFollows(1) } )
    value = newInvocation()
    {
        return value;
    }
|
    // This LOOKAHEAD is required to distinguish an window/aggregate
    // function from miscBuiltins(). Both can start with an identifier.
    LOOKAHEAD( { windowOrAggregateFunctionFollows() } )
    value = windowOrAggregateFunctionNode()
    {
        return value;
    }
|
    // This LOOKAHEAD is required because both miscBuiltins() and
    // columnReference can start with an identifier()
    LOOKAHEAD( { miscBuiltinFollows() } )
    value = miscBuiltins()
    {
        return value;
    }
|
    value = columnReference()
    {
        return value;
    }
|
    <LEFT_PAREN>
    (
        // This LOOKAHEAD is required because a subquery can have
        // queryExpressions nested arbitrarily deep inside of parentheses,
        // so both subquery() and valueExpression() can start with
        // LEFT_PAREN. We disambiguate this case by only considering it
        // to be a subquery if it starts with SELECT or VALUES, which
        // are the first tokens to come after the LEFT_PAREN in a subquery.
        LOOKAHEAD( { getToken(1).kind == SELECT || getToken(1).kind == VALUES } )
        value = subquery(SubqueryNode.SubqueryType.EXPRESSION, null)
    |
        value = valueExpression()
    )
    <RIGHT_PAREN>
    {
        return value;
    }
|
    value = castSpecification()
    {
        return value;
    }
|
    value = nextValueExpression()
    {
        return value;
    }
|
    value = currentValueExpression()
    {
        return value;
    }
}

ValueNode
miscBuiltins() throws StandardException :
{
    ValueNode value;
}
{
    LOOKAHEAD( { miscBuiltinCoreFollows() } )
    value = miscBuiltinsCore(false)
    {
        return value;
    }
|
    value = datetimeValueFunction()
    {
        return value;
    }
|    
    value = routineInvocation()
    {
        return value;
    }
}

ValueNode
miscBuiltinsCore(boolean isJDBCEscape) throws StandardException :
{
    ValueNode value;
}
{
    /* miscBuiltinsCore() are the core system, string and numeric
     * functions.    NOTE: date functions not currently considered core
     * for purposes of the grammar since they can only be escaped when
     * they appear as functions (not special registers).
     */

    // NOTE: If you add a new function here or in one of the called
    // rules, you must add the same token(s) to miscBuiltinCoreFollows().
    <GET_CURRENT_CONNECTION> <LEFT_PAREN> <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                              nodeFactory.getNode(NodeTypes.GET_CURRENT_CONNECTION_NODE, parserContext),
                                              parserContext);
    }
|
    value = numericValueFunction() 
    {
        return value;
    }
|
    value = characterValueFunction()
    {
        return value;
    }
|
    value = dataTypeScalarFunction()
    {
        return value;
    }
|
    <COALESCE> value = coalesceFunction("COALESCE")
    {
        return value;
    }
|
    <VALUE> value = coalesceFunction("VALUE")
    {
        return value;
    }
|
    <LENGTH> <LEFT_PAREN> value = additiveExpression() <RIGHT_PAREN>
    {
        if (isJDBCEscape)
            return (ValueNode)nodeFactory.getNode(NodeTypes.CHAR_LENGTH_OPERATOR_NODE,
                                                  getTrimOperatorNode(BinaryOperatorNode.OperatorType.RTRIM,
                                                                      null,
                                                                      value),
                                                  parserContext);
                                                 
        /*
            TODO: DECIDE wether LENGTH should be OCTET_LENGTH or CHARACTER_LENGTH
                  dependent upon some mode
        */
        return (ValueNode)nodeFactory.getNode(NodeTypes.OCTET_LENGTH_OPERATOR_NODE,
                                              value,
                                              parserContext);
    }
|
    (<CHAR_LENGTH> | <CHARACTER_LENGTH>)<LEFT_PAREN> value = additiveExpression() <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CHAR_LENGTH_OPERATOR_NODE,
                                              value,
                                              parserContext);
    }
|
    <OCTET_LENGTH><LEFT_PAREN> value = additiveExpression() <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.OCTET_LENGTH_OPERATOR_NODE,
                                              value,
                                              parserContext);
    }
|
    value = xmlFunction()
    {
        return value;
    }
}

ValueNode
dataTypeScalarFunction() throws StandardException :
{
    DataTypeDescriptor dts;
    ValueNode value;                            // Converted result
    ValueNode operand;
    int charType;
    int length = -1;
}
{
    // NOTE: If you add a new function here or in one of the called
    // rules, you must add the same token(s) to miscBuiltinCoreFollows().
    value = dateTimeScalarFunction()
    {
        return value;
    }
|
    dts = numericFunctionType() 
    <LEFT_PAREN> operand = additiveExpression() <RIGHT_PAREN>
    {
        value = (ValueNode)nodeFactory.getNode(NodeTypes.CAST_NODE,
                                               operand,
                                               dts,
                                               parserContext);
        ((CastNode)value).setForDataTypeFunction(true);
        ((CastNode)value).setForExternallyGeneratedCASTnode();

        return value;
    }
| 
    charType = charOrVarchar() 
    <LEFT_PAREN> operand = additiveExpression() 
    [ <COMMA> length = length() ] 
    <RIGHT_PAREN>
    {
        value = (ValueNode)nodeFactory.getNode(NodeTypes.CAST_NODE,
                                               operand,
                                               new Integer(charType),
                                               new Integer(length),
                                               parserContext);

        ((CastNode)value).setForDataTypeFunction(true);
        ((CastNode)value).setForExternallyGeneratedCASTnode();
        return value;
    }
}
     
/*
 * This method parses the built-in functions used with the XML datatype.
 */
ValueNode
xmlFunction() throws StandardException :
{
    ValueNode value;
}
{
    <XMLPARSE> <LEFT_PAREN> xmlDocOrContent() value = xmlParseValue() <RIGHT_PAREN>
    {
        return value;
    }
|
    <XMLSERIALIZE> <LEFT_PAREN> value = xmlSerializeValue() <RIGHT_PAREN>
    {
        return value;
    }
|
    <XMLEXISTS> <LEFT_PAREN> value = xmlQueryValue(true) <RIGHT_PAREN>
    {
        return value;
    }
|
    <XMLQUERY> <LEFT_PAREN> value = xmlQueryValue(false) <RIGHT_PAREN>
    {
        return value;
    }
}

/*
 * Syntax is as follows:
 *
 *       XMLPARSE( DOCUMENT <string-value-expression> PRESERVE WHITESPACE )
 *
 * The result of this operation will be an XML value, which can either
 * be used transiently or else can be stored persistently in a table that
 * has an XML column.    For example:
 *
 * ij> CREATE TABLE x_table (id INT, xdoc XML);
 * 0 rows inserted/updated/deleted
 * ij> INSERT INTO x_table VALUES (1, XMLPARSE(DOCUMENT '<simp> doc </simp>'
 * PRESERVE WHITESPACE));
 * 1 row inserted/updated/deleted
 *
 * We only allow XML documents (as opposed to XML content) to be
 * parsed into XML values.  Note that we require the "PRESERVE WHITESPACE"
 * keyword to be explicit; this is because the SQL/XML (2003) spec says that
 * if no whitespace option is given, the default is "STRIP WHITESPACE", which
 * we don't support (yet).
 *
 * By the time we get to this method, the "DOCUMENT" keyword has already
 * been parsed.
 *
 */
ValueNode
xmlParseValue() throws StandardException :
{
    ValueNode value;
    boolean wsOption;
}
{
    value = additiveExpression()
    wsOption = xmlPreserveWhitespace() 
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.XML_PARSE_OPERATOR_NODE,
                                              value,
                                              XMLUnaryOperatorNode.OperatorType.PARSE,
                                              new Object[] {(wsOption ? Boolean.TRUE : Boolean.FALSE)},
                                              parserContext);
    }
}

/*
 * For now, we only support the PRESERVE WHITESPACE option.
 */
boolean
xmlPreserveWhitespace() throws StandardException :
{}
{
    LOOKAHEAD( { (getToken(1).kind != STRIP) || (getToken(1).kind != PRESERVE) } )
    {
        throw new StandardException("Missing required PRESERVE WHITESPACE");
    }
|
    <STRIP> <WHITESPACE>
    { // don't preserve whitespace.
        return false;
    }
|
    <PRESERVE> <WHITESPACE>
    { // must preserve whitespace.
        return true;
    }
}

/*
 * Syntax is as follows:
 *
 *   XMLSERIALIZE( <xml-value-expression> AS <string-data-type> )
 *
 * The result of this operation will be a string value with the type specified
 * by the user.  For example:
 *
 * ij> SELECT id, XMLSERIALIZE(xdoc AS varchar(30)) FROM x_table;
 * ID                   |2
 * ------------------------------------------
 * 1                    |<simp> doc </simp>
 *
 */
ValueNode
xmlSerializeValue() throws StandardException :
{
    ValueNode value;
    DataTypeDescriptor targetType;
}
{
    value = additiveExpression()
    targetType = xmlSerializeTargetType()
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.XML_SERIALIZE_OPERATOR_NODE,
                                              value,
                                              XMLUnaryOperatorNode.OperatorType.SERIALIZE,
                                              new Object[] {targetType},
                                              parserContext);
    }
}

/*
 * Parse the target type of an XMLSERIALIZE operation.
 */
DataTypeDescriptor 
xmlSerializeTargetType() throws StandardException :
{
    DataTypeDescriptor targetType;
}
{
    LOOKAHEAD( { (getToken(1).kind != AS) } )
    {
        throw new StandardException("Missing required AS");
    }
|
    <AS> targetType = dataTypeDDL()
    {
        return targetType;
    }
}

/*
 * This method is used for parsing the XMLEXISTS and XMLQUERY operators
 * (which operator depends on the received boolean parameter).
 *
 * For XMLEXISTS, the syntax is as follows:
 *
 *   XMLEXISTS( <xpath-expression> PASSING BY REF <xml-value-expression> )
 *
 * The result of this operation will be a boolean true/false/unknown value:
 *   -- Unknown if either <xquery-expression> or <xml-value-expression> is null;
 *   -- True if evaluation of the given query expression against the
 *          given xml-value returns at least one node.
 *   -- False otherwise.
 *
 * For example:
 *
 * ij> SELECT id FROM x_table WHERE XMLEXISTS('/simple' PASSING BY REF xdoc);
 * ID
 * -----------
 * 1
 *
 * ====
 *
 * For XMLQUERY, the syntax is as follows:
 *
 *   XMLQUERY( <xquery-expression>
 *          PASSING BY REF <xml-value-expression>
 *          [ RETURNING SEQUENCE [ BY REF ] ]
 *          EMPTY ON EMPTY
 *   )
 *
 * The result of this operation will be an XMLDataValue.
 *
 * For example:
 *
 * ij> SELECT XMLSERIALIZE(
 *           XMLQUERY('/simple' PASSING BY REF xdoc EMPTY ON EMPTY) AS CHAR(100));
 * ID
 * -----------
 * <simp> doc </simp>
 *
 */
ValueNode
xmlQueryValue(boolean existsOnly) throws StandardException :
{
    // The query expression (currently must be an expression
    // supported by Xalan--i.e. XPath only).
    ValueNode xqueryExpr = null;

    // Context item for the query; not required by SQL/XML spec,
    // but required by Derby for now.
    ValueNode xmlValue = null;

    // User-specified default passing mechanism.    Since Derby only
    // supports one type of passing mechanism--BY REF--this value
    // isn't currently used.
    XMLBinaryOperatorNode.PassByType defaultPassingMech = null;

    // TODO: More state: XML node may need to be separate from BinaryOperatorNode.
}
{
    xqueryExpr = additiveExpression()
    <PASSING> defaultPassingMech = xmlPassingMechanism()
    xmlValue = xqVarList()
    (
        LOOKAHEAD( { !existsOnly } )
        [ xqReturningClause() [ xmlPassingMechanism() ] ]
        xqEmptyHandlingClause()
        { /* Right now, we only support one kind of returning clause
             * (RETURNING SEQUENCE) and one kind of handling clause
             * (EMPTY ON EMPTY), so there's nothing more to do here--
             * we just needed to check the syntax.  In the future
             * we may need to add more logic here to support the
             * other options.    Note: if no returning clause is
             * specified, RETURNING SEQUENCE is implied (because
             * that's all we support).
             */
        }
    |
     LOOKAHEAD( { existsOnly } )
     { /* For XMLEXISTS there's nothing more to parse.  
            * This LOOKAHEAD in required in order to tell the parser that
            * we're done parsing and thus it shouldn't look for (nor allow)
            * any more tokens (neither xqReturningClause() nor
            * xqEmptyHandlingClause() is allowed for the XMLEXISTS
            * operator).
            */
     }
    )
    {
        ValueNode vNode = (ValueNode)nodeFactory.getNode((existsOnly
                                                          ? NodeTypes.XML_EXISTS_OPERATOR_NODE
                                                          : NodeTypes.XML_QUERY_OPERATOR_NODE),
                                                         xqueryExpr,
                                                         xmlValue,
                                                         (existsOnly
                                                          ? XMLBinaryOperatorNode.OperatorType.EXISTS
                                                          : XMLBinaryOperatorNode.OperatorType.QUERY),
                                                         parserContext);

        return vNode;
    }
}

/**
 * Parse a list of XML query variables, which can include at most one
 * XML value to be used as the "context item" for the query.    If
 * such a context item was found, return that item; for all other
 * variable declarations we currently throw a "not supported" error
 * because Xalan doesn't allowing binding of variables.
 */

ValueNode 
xqVarList() throws StandardException :
{
    // Placeholder for the XML context item as we parse the
    // argument list.
    ValueNode [] xmlValue = new ValueNode [] { (ValueNode)null };
}
{
    xqVariable(xmlValue)
    ( <COMMA> xqVariable(xmlValue) )*
    {
        return xmlValue[0];
    }
}

/**
 * Parse an XML query variable.  If the argument is an XML value
 * to be used as the "context item" for a query, then store the
 * value in the first slot of the received ValueNode array;
 * otherwise, throw a "not supported" errror (for now).
 */

void 
xqVariable(ValueNode [] xmlVal) throws StandardException :
{
    ValueNode curVal;
    String varName = null;
    XMLBinaryOperatorNode.PassByType passingMech = null;
}
{
    curVal = additiveExpression()
    [
        LOOKAHEAD( { getToken(1).kind == AS } )
        <AS> varName = identifier()
        {
            /* From XQuery 1.0: "The <identifier> I contained in XQV
             * shall be an XML 1.1 NCName."  From XML 1.1:
             *
             *   [4] NCName ::= (Letter | '_') (NCNameChar)*
             *   [5] NCNameChar ::= Letter | Digit | '.' | '-' | '_' |
             *                                      CombiningChar | Extender
             *
             * Since Derby's definition of an "identifier" is a subset
             * of NCName, we just use Derby's definition.    This means
             * that some valid NCNames won't be recognized by Derby--
             * but since the ones we _do_ recognize are all still valid
             * NCNames, we're not breaking any rules.
             */

            /* All of that said, since we use Xalan as the underlying
             * query engine and Xalan doesn't support variable binding,
             * there's no point in letting the user specify variables
             * right now.    So we disallow it.  In the future we'll have
             * to add logic here to store the variables and pass them
             * to the correct operator for binding/execution.
             */
            throw new StandardException("Not implemented yet: PASSING ... AS");
        }
    ]
    (
        [ passingMech = xmlPassingMechanism() ]
        {
            if (varName == null) {
                /* We get here if we just parsed an XML context item.
                 * That said, if we already have one (xmlVal[0] is not
                 * null) then we can't allow second one, per SQL/XML[2006]
                 * (6.17: Syntax Rules:5.b.i): "XMQ shall contain exactly
                 * one <XML query context item> XQCI."
                 */
                if (xmlVal[0] != null) {
                    throw new StandardException("Multiple XML context items");
                }

                xmlVal[0] = curVal;

                /* Note: It's possible that a passing mechanism was
                 * specified for the context item; if so its value is
                 * stored in passingMech.    However, we don't actually
                    * store that passing mechanism anywhere because we
                 * (currently) only support BY REF, so we know what
                    * it has to be.  If we add support for other passing
                    * mechanisms (namely, BY VALUE) in the future, we'll
                    * have to store the passing mechanism provided by
                    * the user and process it at compilation/execution
                 * time.
                 */
            }
        }
    )
    { // By this time we've parsed everything we need so there's nothing
        // more to do.  The reason we're left with this empty block is
        // is that most of the syntax is optional.  We end up here if
        // none of the optional syntax was given, in which case all we
        // need to do is store curVal--and we already did that.
    }
}

/*
 * For now, we only support the BY REF option because
 * that gives us better performance (allows us to avoid
 * performing potentially deep copies of XML nodes).    This
 * means that if the same XML value is passed BY REF into
 * two different XML arguments for a single operator, then
 * every node in the first XML argument must have an
 * identical node in the second XML argument, and the
 * ids for both nodes must be the same.  That said,
 * since we don't support variable binding yet, this
 * becomes a non-issue because we can't pass XML values.
 * In the future, though, we may choose to support the
 * passing/binding of variables (the only reason we
 * don't now is because Xalan doesn't support it) and
 * if we do, BY REF should provide better performance
 * due to lack of deep copying.
 */
XMLBinaryOperatorNode.PassByType
xmlPassingMechanism() throws StandardException :
{}
{
    LOOKAHEAD( { getToken(2).kind == REF })
    <BY> <REF>
    { // pass the XML value by reference
        return XMLBinaryOperatorNode.PassByType.REF;
    }
|
    <BY> <VALUE>
    { // pass a 'copy' of the XML value.
        return XMLBinaryOperatorNode.PassByType.VALUE;
    }
}

/*
 * For now we only support "RETURNING SEQUENCE".    The reason
 * is that this applies to the XMLQUERY operator and the
 * results of evaluating a query expression in Xalan against
 * an XML value can be an arbritary sequence of items--including
 * atomic values.    For simplicity we just return the values
 * as they are, without doing any further work.  SQL/XML[2006]
 * says that if we supported RETURNING CONTENT then we'd have
 * to construct an XQuery document from the results--but we don't
 * do that extra work for now, so we just say that we return
 * SEQUENCE.
 *
 * NOTE: This means that we may not be able to store the results
 * of an XMLQUERY operation into a Derby XML column.    Right now
 * an XML column can only hold valid DOCUMENT nodes, which we
 * we define as an XML value whose serialized form can be parsed
 * by a JAXP DocumentBuilder (because that's what Derby's XMLPARSE
 * operator uses and the result is always a Document node).
 * Internally this means that we can only store a sequence if it
 * contains exactly one org.w3c.dom.Node that is an instance of
 * org.w3c.dom.Document.    If the result of an XMLQUERY operation
 * does not fit this criteria then it will *not* be storable into
 * Derby XML columns.
 */
XMLBinaryOperatorNode.ReturnType
xqReturningClause() throws StandardException :
{}
{
    LOOKAHEAD( { getToken(2).kind == SEQUENCE } )
    <RETURNING> <SEQUENCE>
    { // XMLQUERY should return result as a sequence.
        return XMLBinaryOperatorNode.ReturnType.SEQUENCE;
    }
|
    <RETURNING> <CONTENT>
    { // XMLQUERY should return 'content'.
        return XMLBinaryOperatorNode.ReturnType.CONTENT;
    }
}

/*
 * Defines what the behavior should be when an XMLQUERY operator
 * results in an empty sequence.    For now we just return the
 * empty sequence.
 */
XMLBinaryOperatorNode.OnEmpty
xqEmptyHandlingClause() throws StandardException :
{}
{
    LOOKAHEAD( { getToken(1).kind == EMPTY })
    <EMPTY> <ON> <EMPTY>
    { // XMLQUERY should return an empty sequence when result of
        // the query is an empty sequence (i.e. when there are no
        // results).
        return XMLBinaryOperatorNode.OnEmpty.EMPTY;
    }
|
    <NULL> <ON> <EMPTY>
    { // XMLQUERY should return a null XML value when result of
        // the query is an empty sequence (i.e. when there are no
        // results).
        return XMLBinaryOperatorNode.OnEmpty.NULL;
    }
}

DataTypeDescriptor
numericFunctionType() throws StandardException :

{
    DataTypeDescriptor dts;
}
{
    dts = doubleType()
    {
        return dts;
    }
    |
    dts = exactIntegerType()
    {
        return dts;
    }
}

ValueNode
dateTimeScalarFunction() throws StandardException :
{

    ValueNode value;
    ValueNode timestampNode;
    ExtractOperatorNode.Field field;
}
{
        /*
         * NOTE: If you add a new rule here, you must add the appropriate
         *      LOOKAHEAD rule to miscBuiltins().
         */

    <EXTRACT><LEFT_PAREN> field = datetimeField()
    <FROM> value = additiveExpression()
    <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.EXTRACT_OPERATOR_NODE,
                                              field,
                                              value,
                                              parserContext);
    }
|
    <TIME> <LEFT_PAREN> value = additiveExpression() <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.UNARY_DATE_TIMESTAMP_OPERATOR_NODE,
                                              value,
                                              DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.TIME),
                                              parserContext);
    }
|
    <DATE> <LEFT_PAREN> value = additiveExpression() <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.UNARY_DATE_TIMESTAMP_OPERATOR_NODE,
                                              value,
                                              DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.DATE),
                                              parserContext);
    }
|
    <TIMESTAMP> <LEFT_PAREN> value = additiveExpression() 
    timestampNode = timestampFunctionCompletion(value)
    {
        return timestampNode;
    }
|
    field = datetimeField() 
    <LEFT_PAREN> value = additiveExpression() <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.EXTRACT_OPERATOR_NODE,
                                              field,
                                              value,
                                              parserContext);
    }
|
    value = timestampArithmeticFuncion()
    {
        return value;
    }
}

ValueNode
timestampFunctionCompletion(ValueNode firstArg) throws StandardException :
{
    ValueNode timeValue;
}
{
    <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.UNARY_DATE_TIMESTAMP_OPERATOR_NODE,
                                              firstArg,
                                              DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.TIMESTAMP),
                                              parserContext);
    }
|
    <COMMA> timeValue = additiveExpression() <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.TIMESTAMP_OPERATOR_NODE,
                                              firstArg,
                                              timeValue,
                                              parserContext);
    }
}

Token
booleanLiteral() :
{
    Token tok;
}
{
    tok = <TRUE>
    {
        return tok;
    }
|
    tok = <FALSE>
    {
        return tok;
    }
}

ValueNode
generalValueSpecification() throws StandardException :
{
    ValueNode parm;
}
{
    parm = dynamicParameterSpecification()
    {
        return parm;
    }
|
    parm = userNode()
    {
        return parm;
    }
|
    parm = currentRoleNode()
    {
        return parm;
    }
|
    parm = currentSchemaNode()
    {
        return parm;
    }
}

ValueNode
userNode() throws StandardException :
{}
{
    <USER>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.USER_NODE,
                                              parserContext);
    }
|
    <CURRENT_USER>
    {
        checkOptionalParens();
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_USER_NODE,
                                              parserContext);
    }
|
    <SESSION_USER>
    {
        checkOptionalParens();
        return (ValueNode)nodeFactory.getNode(NodeTypes.SESSION_USER_NODE,
                                              parserContext);
    }
}

ValueNode
currentRoleNode() throws StandardException :
{}
{
    <CURRENT_ROLE>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_ROLE_NODE,
                                              parserContext);
    }
}

ValueNode
currentSchemaNode() throws StandardException :
{}
{
    <CURRENT_SCHEMA>
    {
        checkOptionalParens();
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_SCHEMA_NODE,
                                              parserContext);
    }
}

JavaToSQLValueNode
newInvocation() throws StandardException :
{
    QueryTreeNode    newNode;
    List<ValueNode> parameterList = new ArrayList<ValueNode>();
    String javaClassName;
}
{
    <NEW> javaClassName = javaClassName() methodCallParameterList(parameterList)
    {            
        newNode = nodeFactory.getNode(NodeTypes.NEW_INVOCATION_NODE,
                                      javaClassName,
                                      parameterList,
                                      lastTokenDelimitedIdentifier,
                                      parserContext);

        /*
        ** Assume this is being returned to the SQL domain.  If it turns
        ** out that this is being returned to the Java domain, we will
        ** get rid of this node.
        */
        return (JavaToSQLValueNode)nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                       newNode,
                                                       parserContext);
    }
}

/*
 * Parse a TABLE() constructor that corresponds to an internal
 * VTI invocation.  For example:
 *
 *      TABLE ( <qualifiedName> (arg1, arg2, ...) )
 *
 * where <qualifiedName> is a table name that Derby will map internally
 * to a VTI (ex. "SYSCS_DIAG.SPACE_TABLE").  The list of arguments
 * will then be passed to the VTI when it is invoked (DERBY-2152).
 *
 * An example query where this might occur is as follows:
 *
 *   SELECT * FROM TABLE(SYSCS_DIAG.SPACE_TABLE('APP', 'T1')) x
 *
 * in which case SYSCS_DIAG.SPACE_TABLE will be mapped (internally)
 * to the "org.apache.derby.diag.SpaceTable" diagnostic VTI.    Thus
 * the equivalent call prior to DERBY-2152 would have been:
 *
 *   SELECT * FROM NEW org.apache.derby.diag.SpaceTable('APP', 'T1')) x
 *
 * Note that this latter syntax is still supported.
 */
JavaToSQLValueNode
vtiTableConstruct() throws StandardException :
{
    NewInvocationNode newNode = null;
    QueryTreeNode invocationNode = null;
    List<ValueNode> parameterList = new ArrayList<ValueNode>();
    TableName vtiTableName = null;
    MethodCallNode  methodNode;
}
{
    <TABLE> <LEFT_PAREN> vtiTableName = qualifiedName()
    methodCallParameterList(parameterList)
    <RIGHT_PAREN>
    {
        /* The fact that we pass a NULL table descriptor to the
         * following call is an indication that we are mapping to a
         * VTI table function (i.e. one that accepts arguments).
         * Since we have the table name we do not need to pass in a
         * TableDescriptor--we'll just create one from the table
         * name. See NewInvocationNode for more.
         */
        newNode = (NewInvocationNode)nodeFactory.getNode(NodeTypes.NEW_INVOCATION_NODE,
                                                         vtiTableName,  // TableName
                                                         null,                  // TableDescriptor
                                                         parameterList,
                                                         lastTokenDelimitedIdentifier,
                                                         parserContext);

        if (newNode.isBuiltinVTI()) { 
            invocationNode = newNode; 
        }
        else {
            methodNode = (MethodCallNode)nodeFactory.getNode(NodeTypes.STATIC_METHOD_CALL_NODE,
                                                             vtiTableName,
                                                             null,
                                                             parserContext);
            methodNode.addParms(parameterList);

            invocationNode = methodNode;
        }
        
        /*
        ** Assume this is being returned to the SQL domain.  If it turns
        ** out that this is being returned to the Java domain, we will
        ** get rid of this node.
        */
        return (JavaToSQLValueNode)nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                       invocationNode,
                                                       parserContext);
    }
}

ValueNode
staticMethodInvocation(String javaClassName) throws StandardException :
{
    List<ValueNode> parameterList = new ArrayList<ValueNode>();
    MethodCallNode methodNode;
}
{
    methodNode = staticMethodName(javaClassName) 
    methodCallParameterList(parameterList)
    {
        methodNode.addParms(parameterList);

        /*
        ** Assume this is being returned to the SQL domain.  If it turns
        ** out that this is being returned to the Java domain, we will
        ** get rid of this node.
        */
        return (ValueNode)nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                              methodNode,
                                              parserContext);
    }
}

void
methodCallParameterList(List<ValueNode> parameterList) throws StandardException :
{}
{
    <LEFT_PAREN>
    [ methodParameter(parameterList)
    ( <COMMA> methodParameter(parameterList) )* ]
    <RIGHT_PAREN>
}

ValueNode
routineInvocation() throws StandardException :
{
    List<ValueNode> parameterList = new ArrayList<ValueNode>();
    TableName routineName;
    MethodCallNode methodNode;
}
{
    routineName = qualifiedName()
    methodCallParameterList(parameterList)
    {
        methodNode = (MethodCallNode)nodeFactory.getNode(NodeTypes.STATIC_METHOD_CALL_NODE,
                                                         routineName,
                                                         null,
                                                         parserContext);

        methodNode.addParms(parameterList);

        /*
        ** Assume this is being returned to the SQL domain.  If it turns
        ** out that this is being returned to the Java domain, we will
        ** get rid of this node.
        */
        return (ValueNode)nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                              methodNode,
                                              parserContext);
    }
}

String
javaClass() throws StandardException :
{
    String javaClassName;
}
{
    javaClassName = javaClassName()
    {
        return javaClassName;
    }
}

ValueNode
columnMethodInvocation() throws StandardException :
{
    ValueNode columnReference;
    ValueNode methodNode;
}
{
    columnReference = columnNameForInvocation()
    methodNode = nonStaticMethodInvocation(columnReference)
    {
        return methodNode;
    }
}

ValueNode
columnNameForInvocation() throws StandardException :
{
    String firstName;
    String secondName = null;
    String thirdName = null;
    String columnName = null;
    String tableName = null;
    String schemaName = null;
    TableName tabName = null;
    ValueNode retval;
}
{
    firstName = identifier()
    [
        // This LOOKAHEAD is required because we have the following cases:
        // schema.table.column.method()
        // table.column.method()
        // column.method()
        // 
        // We have to look ahead to ensure that there is at least one more
        // PERIOD after the current one, so that we don't consider the
        // method name to be a table or column name.
        LOOKAHEAD( { getToken(1).kind == PERIOD && getToken(3).kind == PERIOD } )
        <PERIOD> secondName = identifier()
        [
            // See above: we don't want to mistake the method name for a column name.
            LOOKAHEAD( { getToken(1).kind == PERIOD && getToken(3).kind == PERIOD } )
            <PERIOD> thirdName = identifier()
        ]
    ]
    {
        // Figure out what each identifier stands for
        if (thirdName == null) {
            if (secondName == null) {
                // There's only one identifier, so it must be a column name
                columnName = firstName;
            }
            else {
                // There are two identifiers, so they are table and column names
                tableName = firstName;
                columnName = secondName;
            }
        }
        else {
            // There are three identifiers,
            // so they are schema, table, and column names
            schemaName = firstName;
            tableName = secondName;
            columnName = thirdName;
        }

        if (tableName != null) {
            // There is a table name, so get a TableName node
            tabName =
                (TableName)nodeFactory.getNode(NodeTypes.TABLE_NAME,
                                               schemaName,
                                               tableName,
                                               new Integer(nextToLastIdentifierToken.beginOffset),
                                               new Integer(nextToLastIdentifierToken.endOffset),
                                               parserContext);
        }

        // Get the column reference
        retval = (ValueNode)nodeFactory.getNode(NodeTypes.COLUMN_REFERENCE,
                                                columnName,
                                                tabName,
                                                new Integer(lastIdentifierToken.beginOffset),
                                                new Integer(lastIdentifierToken.endOffset),
                                                parserContext);

        return retval;
    }
}

ColumnReference
columnReference() throws StandardException :
{
    String firstName;
    String secondName = null;
    String thirdName = null;
    String columnName = null;
    String tableName = null;
    String schemaName = null;
    TableName tabName = null;
    NestedColumnReference nestedColumn = null;
}
{
    firstName = identifierDeferCheckLength()
    [
        // This LOOKAHEAD is needed to ensure that, if the identifier
        // after the PERIOD is a method name, we don't treat it as part of
        // the column reference.
        LOOKAHEAD( { getToken(1).kind == PERIOD && getToken(3).kind != LEFT_PAREN } )
        <PERIOD> secondName = identifierDeferCheckLength()
        [
            // This LOOKAHEAD is needed to ensure that, if the identifier
            // after the PERIOD is a method name, we
            // don't treat it as part of the column reference.
            LOOKAHEAD( { getToken(1).kind == PERIOD && getToken(3).kind != LEFT_PAREN } )
            <PERIOD> thirdName = identifierDeferCheckLength()
        ]
    ]
    {
        // Figure out what each name stands for
        if (thirdName == null) {
            if (secondName == null) {
                // Only one name, must be column name
                columnName = firstName;
            }
            else {
                // Two names: table.column
                tableName = firstName;
                columnName = secondName;
            }
        }
        else {
            // Three names: schema.table.column
            schemaName = firstName;
            tableName = secondName;
            columnName = thirdName;
        }

        parserContext.checkIdentifierLengthLimit(columnName);
        if (schemaName != null)
            parserContext.checkIdentifierLengthLimit(schemaName);
        if (tableName != null)
            parserContext.checkIdentifierLengthLimit(tableName);

        if (tableName != null) {
            tabName = (TableName)nodeFactory.getNode(NodeTypes.TABLE_NAME,
                                                     schemaName,
                                                     tableName,
                                                     new Integer(nextToLastIdentifierToken.beginOffset),
                                                     new Integer(nextToLastIdentifierToken.endOffset),
                                                     parserContext);
            }
    }

    (
        LOOKAHEAD( { getToken(1).kind == LEFT_BRACKET } )
        {
            nestedColumn =  (NestedColumnReference)nodeFactory.getNode(NodeTypes.NESTED_COLUMN_REFERENCE,
                                                    columnName,
                                                    tabName,
                                                    new Integer(lastIdentifierToken.beginOffset),
                                                    new Integer(lastIdentifierToken.endOffset),
                                                    parserContext);
            nestedColumnPaths(nestedColumn);
            return nestedColumn;

        }

    |

        {
            return (ColumnReference)nodeFactory.getNode(NodeTypes.COLUMN_REFERENCE,
                                                columnName,
                                                tabName,
                                                new Integer(lastIdentifierToken.beginOffset),
                                                new Integer(lastIdentifierToken.endOffset),
                                                parserContext);
        }
    )
}

/*
void
columnReference() throws StandardException :
{}
{
    /*
    **
    ** I re-wrote the above rule because it caused a grammar ambiguitity.
    ** The problem is that we are parsing a dot-separated list of identifiers,
    ** and the grammar doesn't know what the identifiers stand for, but the
    ** syntax assumed that it did.  For example, in schema.table.column,
    ** the grammar doesn't know when it parses the first identifier whether
    ** it will be a catalog name, schema name, table name, or column name.
    **
    ** I think this problem could be solved by increasing the lookahead.
    ** I will try that solution next.    I like that solution better because,
    ** if it works, it will be easier for the grammar to figure out what
    ** each identifier stands for.
    **

    [ <MODULE> <PERIOD> <IDENTIFIER> |
        [ [ [ <IDENTIFIER> <PERIOD> ] <IDENTIFIER> <PERIOD> ] <IDENTIFIER> <PERIOD> ]
    ]
    <IDENTIFIER>
}
*/


void
nestedColumnPaths(NestedColumnReference column) throws StandardException :
{}
{
    <LEFT_BRACKET> nestedColumnPathElement(column) <RIGHT_BRACKET>
    ( <LEFT_BRACKET> nestedColumnPathElement(column) <RIGHT_BRACKET> )*
}

void
nestedColumnPathElement(NestedColumnReference column) throws StandardException :
{
    ValueNode element;
}
{
    element = literal()
    {
        column.addPathElement((ConstantNode)element);
    }
}


OrderByList
orderByClause() throws StandardException :
{
    OrderByList orderCols;
}
{
    <ORDER> <BY> orderCols = sortSpecificationList()
    {
        forbidNextValueFor();
        return orderCols;
    }
}

IsolationLevel
atIsolationLevel() throws StandardException :
{
    IsolationLevel isolationLevel;
}
{
    <WITH> isolationLevel = isolationLevelDB2Abbrev()
    {
        return isolationLevel;
    }
}

OrderByList
sortSpecificationList() throws StandardException :
{ 
    OrderByList orderCols = (OrderByList)nodeFactory.getNode(NodeTypes.ORDER_BY_LIST,
                                                             parserContext); 
}
{
    sortSpecification(orderCols)
    ( <COMMA> sortSpecification(orderCols) )*
    {
        return orderCols;
    }
}

void
sortSpecification(OrderByList orderCols) throws StandardException :
{    OrderByColumn orderCol; }
{
    orderCol = sortKey()
    [ orderingSpecification(orderCol) ] 
    [ nullOrdering(orderCol) ]
    {
        orderCols.addOrderByColumn(orderCol);
    } 
}

OrderByColumn
sortKey() throws StandardException :
{
    ValueNode columnExpression;
} 
{
    columnExpression = additiveExpression()
    {
        return (OrderByColumn)nodeFactory.getNode(NodeTypes.ORDER_BY_COLUMN,
                                                  columnExpression,
                                                  parserContext);
    }
}

void
orderingSpecification(OrderByColumn orderCol) :
{}
{
    <ASC> 
|
    <DESC>
    {
        orderCol.setDescending();
    }
}

/*
 * The data type comparison functions need to know whether NULL values
 * should sort higher than non-NULL values, or lower. The answer to this
 * depends on whether the user specified ASCending or DESCending, and on
 * whether the user specified NULLS FIRST, or NULLS LAST, as follows:
 *
 * +===============+========+========+
 * | ORDER BY says | ASC        | DESC   |
 * +===============+========+========+
 * | NULLS FIRST     | less     | greater|
 * +===============+========+========+
 * | NULLS LAST      | greater| less     |
 * +===============+========+========+
 */
void
nullOrdering(OrderByColumn orderCol) :
{}
{
    LOOKAHEAD( { getToken(2).kind == LAST } )
    <NULLS> <LAST>
    {
        if (!orderCol.isAscending())
            orderCol.setNullsOrderedLow();
    }
|
    <NULLS> <FIRST>
    {
        if (orderCol.isAscending())
            orderCol.setNullsOrderedLow();
    }
}

void 
offsetOrFetchFirstClause(ValueNode[] offsetAndFetchFirst) throws StandardException :
{
    ValueNode value;
}
{
    value = offsetClause()
    {
        if (offsetAndFetchFirst[0] != null)
            throw new StandardException("OFFSET specified more than one");
        offsetAndFetchFirst[0] = value;
    }
|
    value = fetchFirstClause()
    {
        if (offsetAndFetchFirst[1] != null)
            throw new StandardException("FETCH FIRST specified more than one");
        offsetAndFetchFirst[1] = value;
    }
|
    limitClause(offsetAndFetchFirst)
}

ValueNode
offsetClause() throws StandardException :
{
    ValueNode result = null;
}
{
    // Since OFFSET is not yet a reserved keyword, cf. disambiguation
    // look-ahead for it w.r.t. offsetClause in method nonReservedKeyword.
    // This solves the shift/reduce conflict, and allows us to use OFFSET as an
    // identifier in all contexts.
    <OFFSET>
    ( 
        result = intLiteral()
    | 
        result = dynamicParameterSpecification()
    )
    ( <ROW> | <ROWS> )
    {
        return result;
    }
}

ValueNode
fetchFirstClause() throws StandardException :
{
    ValueNode result = null;
}
{
    <FETCH> ( <FIRST> | <NEXT> )
    [ 
        result = intLiteral()
    | 
        result = dynamicParameterSpecification()
    ] 
    ( <ROW> | <ROWS> ) <ONLY>
    {
        // The default number of rows to fetch if the literal is omitted is 1:
        if (result == null)
            result = getNumericNode("1", true);
        return result;
    }
}

void 
limitClause(ValueNode[] offsetAndFetchFirst) throws StandardException :
{
    ValueNode v1, v2 = null;
    Token tok = null;
}
{
    <LIMIT>
    ( 
        v1 = intLiteral()
    | 
        v1 = dynamicParameterSpecification()
    )
    [ ( tok = <COMMA>
            ( 
                v2 = intLiteral()
            | 
                v2 = dynamicParameterSpecification()
            )
        |
            // This LOOKAHEAD is required to distinguish the Derby OFFSET from the MySQL.
            LOOKAHEAD ( { getToken(1).kind == OFFSET && 
                                        getToken(3).kind != ROW &&
                                        getToken(3).kind != ROWS    } )
            tok = <OFFSET>
            ( 
                v2 = intLiteral()
            | 
                v2 = dynamicParameterSpecification()
            )
         ) ]
    {
        if (offsetAndFetchFirst[1] != null)
            throw new StandardException("LIMIT specified more than one");
        if (v2 == null)
            offsetAndFetchFirst[1] = v1;
        else {
            if (offsetAndFetchFirst[0] != null)
                throw new StandardException("LIMIT offset specified more than one");
            if (tok.kind == OFFSET) {
                offsetAndFetchFirst[0] = v2;
                offsetAndFetchFirst[1] = v1;
            }
            else {
                offsetAndFetchFirst[0] = v1;
                offsetAndFetchFirst[1] = v2;
            }
        }
    }
}

CursorNode.UpdateMode
forUpdateClause(List<String> columnList) throws StandardException :
{}
{
    <UPDATE> [ <OF> forUpdateColumnList(columnList) ]
    {
        return CursorNode.UpdateMode.UPDATE;
    }
|
    <READ> <ONLY>
    {
        return CursorNode.UpdateMode.READ_ONLY;
    }
|
    <FETCH> <ONLY>
    {
        return CursorNode.UpdateMode.READ_ONLY;
    }
}

void
forUpdateColumnList(List<String> columnList) throws StandardException :
{
}
{
    forUpdateColumn(columnList) 
    ( <COMMA> forUpdateColumn(columnList) )*
}

void
forUpdateColumn(List<String> columnList) throws StandardException :
{
    String columnName;
}
{
    columnName = identifier()
    {
        columnList.add(columnName);
    }
}

ResultColumnList
setClauseList() throws StandardException :
{
    ResultColumnList    columnList = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                           parserContext);
}
{
    setClause(columnList)
    ( <COMMA> setClause(columnList) )*
    {
        return columnList;
    }
}

void
setClause(ResultColumnList columnList) throws StandardException :
{
    ResultColumn resultColumn;
    ColumnReference columnName;
    ValueNode valueNode;
}
{
    /*
     * SQL92 only wants identifiers here (column names) but JBuilder
     * expects table.column, so we allow the general form.
     */
    columnName = columnReference() <EQUALS_OPERATOR> 
    valueNode = updateSource(columnName.getColumnName())
    {
        resultColumn = (ResultColumn)nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                                         columnName,
                                                         valueNode,
                                                         parserContext);
        columnList.addResultColumn(resultColumn);
    }
}

ValueNode
updateSource(String columnName) throws StandardException :
{
    ValueNode valueNode;
}
{
    valueNode = orExpression(null) 
    {
        return valueNode;
    }
|
    <_DEFAULT>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.DEFAULT_NODE,
                                              columnName,
                                              parserContext);
    }
}

ValueNode
nullSpecification() throws StandardException :
{}
{
    <NULL>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                              parserContext);
    }
}

StatementNode
insertColumnsAndSource(QueryTreeNode targetTable) throws StandardException :
{
    Properties targetProperties = null;
    ResultSetNode queryExpression;
    ResultColumnList columnList = null;
    OrderByList orderCols = null;
    ValueNode[] offsetAndFetchFirst = new ValueNode[2];
    ResultColumnList returningList = null;
}
{
    [
        // This LOOKAHEAD is required because a query expression can
        // be a SELECT or VALUES nested arbitrarily deep in parentheses
        // (which looks like a subquery). So, to be sure that a left
        // parenthesis introduces an insertColumnList(), we have to
        // be sure it doesn't introduce a subquery.
        LOOKAHEAD( { getToken(1).kind == LEFT_PAREN && ! subqueryFollows() } )
        <LEFT_PAREN> columnList = insertColumnList() <RIGHT_PAREN>
    ]
    [ targetProperties = propertyList(false) <CHECK_PROPERTIES>]
    queryExpression = queryExpression(null, NO_SET_OP)
    [ orderCols = orderByClause() ]
    ( offsetOrFetchFirstClause(offsetAndFetchFirst) )*
    [ <RETURNING> returningList = selectList() ] 
    {
        if (orderCols != null && isTableValueConstructor(queryExpression)) {
            // Not allowed by the standard since this is a <contextually typed
            // table value constructor> according SQL 2008, vol2, section 14.11
            // "<insert statement>, SR 17. (I.e. it is not a <subquery> and
            // can't have an ORDER BY).

            throw new StandardException("ORDER BY not allowed");
        }

        if ((offsetAndFetchFirst[0] != null || offsetAndFetchFirst[1] != null) &&
                isTableValueConstructor(queryExpression)) {
            throw new StandardException("Not allowed: " + 
                                         ((offsetAndFetchFirst[0] != null) ? "OFFSET" : "FETCH"));
        }

        return (StatementNode)nodeFactory.getNode(NodeTypes.INSERT_NODE,
                                                  targetTable,
                                                  columnList,
                                                  queryExpression,
                                                  targetProperties,
                                                  orderCols,
                                                  offsetAndFetchFirst[0],
                                                  offsetAndFetchFirst[1],
                                                  returningList,
                                                  parserContext);
    }
    /* RESOLVE: Ignoring default values for now
|
    [ targetProperties = propertyList(false) <CHECK_PROPERTIES>]
    <_DEFAULT> <VALUES>
    {
        return null;
    }
    */
}

ResultColumnList
insertColumnList() throws StandardException :
{
    ResultColumnList    columnList = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                           parserContext);
}
{
    columnQualifiedNameList(columnList)
    {
        return columnList;
    }
}

void
columnQualifiedNameList(ResultColumnList columnList) throws StandardException :
{}
{
    columnQualifiedNameItem(columnList) 
    ( <COMMA> columnQualifiedNameItem(columnList) )*
}

void
columnQualifiedNameItem(ResultColumnList columnList) throws StandardException :
{
    ColumnReference columnRef;
    ResultColumn resultColumn;
}
{
    /*
     * SQL92 only wants identifiers here (column names) but JBuilder
     * expects table.column, so we allow the general form.
     */
    columnRef = columnReference()
    {
        /*
        ** Store the column names for the result columns in the
        ** result column list.  We don't know yet what valueNodes
        ** should be hooked up to each result column, so set that
        ** to null for now.
        */
        resultColumn = (ResultColumn)nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                                         columnRef,
                                                         null,
                                                         parserContext);
        columnList.addResultColumn(resultColumn);
    }
}

ResultSetNode
rowValueConstructor(ResultSetNode leftRSN) throws StandardException :
{
    ResultColumnList resultColumns = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                           parserContext);
}
{
(
    // This LOOKAHEAD is required because a rowValueConstructorList is
    // nested in parentheses, and each element of the list can also be
    // nested in an arbitrary number of parentheses.
    LOOKAHEAD( { rowValueConstructorListFollows() } )
    <LEFT_PAREN> rowValueConstructorList(resultColumns) <RIGHT_PAREN>
|
    rowValueConstructorElement(resultColumns)
)
    {
        /* If leftRSN is null, simply return the newRSN.
        * Else verify thst the number of columns is the same in both RSNs' RCLs.
        * If leftRSN is already a list, add to it.
        * Else make a new list with both.
        */
        RowResultSetNode newRSN = (RowResultSetNode)
            nodeFactory.getNode(NodeTypes.ROW_RESULT_SET_NODE,
                                resultColumns,
                                null,
                                parserContext);
        if (leftRSN == null)
            return newRSN;

        if (leftRSN.getResultColumns().size() !=
            newRSN.getResultColumns().size()) {
            throw new StandardException("Row value size is different");
        }

        RowsResultSetNode rows;
        if (leftRSN instanceof RowsResultSetNode)
            rows = (RowsResultSetNode)leftRSN;
        else
            rows = (RowsResultSetNode)
                nodeFactory.getNode(NodeTypes.ROWS_RESULT_SET_NODE,
                                    leftRSN,
                                    parserContext);
        rows.addRow(newRSN);
        return rows;
    }
}

void
rowValueConstructorElement(ResultColumnList resultColumns) throws StandardException :
{
    ValueNode value;
}
{
    LOOKAHEAD( { simpleLiteralInListFollows() } )
    value = literal()
    {
        resultColumns.addResultColumn(
            (ResultColumn)nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                              null,
                                              value,
                                              parserContext));
    }
|
    value = orExpression(null)
    {
        resultColumns.addResultColumn(
            (ResultColumn)nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                              null,
                                              value,
                                              parserContext));
    }
|
    <_DEFAULT>
    {
        resultColumns.addResultColumn(
            (ResultColumn)nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                              null,
                                              nodeFactory.getNode(NodeTypes.DEFAULT_NODE,
                                                                  null, parserContext),
                                              parserContext));
    }
|
    {
        throw new StandardException("VALUES is empty");
    }
}

void
rowValueConstructorList(ResultColumnList resultColumns) throws StandardException :
{}
{
    rowValueConstructorElement(resultColumns)
    ( <COMMA> rowValueConstructorElement(resultColumns) )*
}


SubqueryNode
tableSubquery(SubqueryNode.SubqueryType subqueryType, ValueNode leftOperand) throws StandardException :
{
    SubqueryNode subqueryNode;
}
{
    subqueryNode = subquery(subqueryType, leftOperand)
    {
        return subqueryNode;
    }
}

SubqueryNode
subquery(SubqueryNode.SubqueryType subqueryType, ValueNode leftOperand) throws StandardException :
{
    ResultSetNode queryExpression;
    SubqueryNode subqueryNode;
    OrderByList orderCols = null;
    ValueNode[] offsetAndFetchFirst = new ValueNode[2];
}
{
    queryExpression = queryExpression(null, NO_SET_OP)
    [ orderCols = orderByClause() ]
    ( offsetOrFetchFirstClause(offsetAndFetchFirst) )*
    {
        subqueryNode = (SubqueryNode)nodeFactory.getNode(NodeTypes.SUBQUERY_NODE,
                                                         queryExpression,
                                                         subqueryType,
                                                         leftOperand,
                                                         orderCols,
                                                         offsetAndFetchFirst[0],
                                                         offsetAndFetchFirst[1],
                                                         parserContext);
        return subqueryNode;
    }
}

ValueNode
inPredicateValue(ValueNode leftOperand) throws StandardException :
{
    ValueNode retval;
    int count[] = new int[]{0};
}
{
    LOOKAHEAD( {leftParenAndSubqueryFollows()} )
    <LEFT_PAREN> retval = tableSubquery(SubqueryNode.SubqueryType.IN, leftOperand) <RIGHT_PAREN>
    {
        return retval;
    }
|
    retval = rowCtor(count)
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.IN_LIST_OPERATOR_NODE,
                                              leftOperand,
                                              retval,
                                              parserContext);
    }
}

ValueNode
inValueList(ValueNode leftOperand) throws StandardException:
{
    ValueNodeList inList = (ValueNodeList)nodeFactory.getNode(NodeTypes.VALUE_NODE_LIST,
                                                              parserContext);
}
{
    inElement(inList) 
    ( <COMMA> inElement(inList) )*
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.IN_LIST_OPERATOR_NODE,
                                              leftOperand,
                                              inList,
                                              parserContext);
    }
}

void
inElement(ValueNodeList inList) throws StandardException :
{
    ValueNode valueNode;
}
{
    valueNode = additiveExpression()
    {
        inList.addValueNode(valueNode);
    }
}


ValueNode
rowCtor(int count[]) throws StandardException:
{
    ValueNodeList list = (ValueNodeList)nodeFactory.getNode(NodeTypes.VALUE_NODE_LIST,
                                                            parserContext);
}
{
    <LEFT_PAREN>
    getRow(list, count)
    <RIGHT_PAREN>
    {
        ++count[0];
        return (ValueNode)nodeFactory.getNode(NodeTypes.ROW_CTOR_NODE,
                                              list,
                                              new int[]{count[0]},
                                              parserContext);
        
    }
}

void
getRow(ValueNodeList rowList, int count[]) throws StandardException:
{
    int max = count[0];
}
{
    max = rowElement(rowList, new int[]{count[0]}, max)
    ( <COMMA> max = rowElement(rowList, new int[]{count[0]}, max) )*
    {
        count[0] = max;
        return;
    }
}

int
rowElement(ValueNodeList list, int count[], int max) throws StandardException:
{   
    ValueNode element = null;
}
{
    (
        (LOOKAHEAD( {rowValueConstructorListFollows()} )
        element = rowCtor(count))
     |   
        element = additiveExpression()
    )
    {
        list.addValueNode(element);
        return max >= count[0] ? max : count[0];
    }

}


SubqueryNode.SubqueryType
quantifier(BinaryOperatorNode.OperatorType opType) throws StandardException :
{
    SubqueryNode.SubqueryType retval = null;
}
{
    <ALL> 
    {
        switch (opType) {
        case EQ:
            retval = SubqueryNode.SubqueryType.EQ_ALL;
            break;

        case NE:
            retval = SubqueryNode.SubqueryType.NE_ALL;
            break;

        case LE:
            retval = SubqueryNode.SubqueryType.LE_ALL;
            break;

        case LT:
            retval = SubqueryNode.SubqueryType.LT_ALL;
            break;

        case GE:
            retval = SubqueryNode.SubqueryType.GE_ALL;
            break;

        case GT:
            retval = SubqueryNode.SubqueryType.GT_ALL;
            break;

        default:
            assert false : "Invalid value for opType (" + opType + ") passed to quantifier()";
        }
        return retval;
    }
|
    some()
    {
        switch (opType) {
        case EQ:
            retval = SubqueryNode.SubqueryType.EQ_ANY;
            break;

        case NE:
            retval = SubqueryNode.SubqueryType.NE_ANY;
            break;

        case LE:
            retval = SubqueryNode.SubqueryType.LE_ANY;
            break;

        case LT:
            retval = SubqueryNode.SubqueryType.LT_ANY;
            break;

        case GE:
            retval = SubqueryNode.SubqueryType.GE_ANY;
            break;

        case GT:
            retval = SubqueryNode.SubqueryType.GT_ANY;
            break;

        default:
            assert false : "Invalid value for opType (" + opType + ") passed to quantifier()";
        }
        return retval;
    }
}

void
some() throws StandardException :
{}
{
    <SOME> | <ANY>
}

SubqueryNode
existsExpression() throws StandardException :
{
    SubqueryNode subqueryNode;
}
{
    <EXISTS> <LEFT_PAREN>
    subqueryNode = tableSubquery(SubqueryNode.SubqueryType.EXISTS, null)
    <RIGHT_PAREN>
    {
        return subqueryNode;
    }
}

SelectNode
tableExpression(ResultColumnList selectList) throws StandardException :
{
    SelectNode selectNode;
    FromList fromList = null;
    ValueNode whereClause = null;
    GroupByList groupByList = null;
    ValueNode havingClause = null;
    Token whereToken;
    WindowList windows = null;
}
{
    [ fromList = fromClause() ]
    [ whereToken = <WHERE> whereClause = whereClause(whereToken) ]
    [ groupByList = groupByClause() ]
    [ havingClause = havingClause() ]
    [ windows = windowClause() ]
    {
        // fix for HAVING without GROUP BY, makes sure we get one
        // aggregate operator by adding a count(*), this fixes beetle 5853, 5890
        if (havingClause != null && groupByList == null) {
            ValueNode vn = (ValueNode)nodeFactory.getNode(NodeTypes.AGGREGATE_NODE,
                                                          null,
                                                          "CountAggregateDefinition",
                                                          Boolean.FALSE, // distinct Boolean.TRUE?
                                                          "COUNT(*)",
                                                          parserContext);
            AggregateNode n = (AggregateNode)vn;
            // TODO: Needed somewhere else.
            // n.replaceAggregatesWithColumnReferences(selectList, 0);          
        }
        
        if (fromList == null)
          fromList = (FromList)nodeFactory.getNode(NodeTypes.FROM_LIST, 
                                                   true, 
                                                   parserContext);

        selectNode = (SelectNode)nodeFactory.getNode(NodeTypes.SELECT_NODE,
                                                     selectList,
                                                     null,       /* AGGREGATE list */
                                                     fromList,
                                                     whereClause,
                                                     groupByList,
                                                     havingClause,
                                                     windows,
                                                     parserContext);

        return selectNode;
    }
}

FromList
fromClause() throws StandardException :
{
    FromList fromList = (FromList)nodeFactory.getNode(NodeTypes.FROM_LIST,
                                                      true, // nodeFactory.doJoinOrderOptimization()
                                                      parserContext);
    int tokKind;
    Token beginToken, endToken;
}
{
    <FROM> { beginToken = getToken(1); }
    [ fromListProperties(fromList) ]
    tableReferences(fromList)
    ( <COMMA> tableReferences(fromList) )* { endToken = getToken(0); }
    {
        fromList.setBeginOffset(beginToken.beginOffset);
        fromList.setEndOffset(endToken.endOffset);
        return fromList;
    }
}

void
fromListProperties(FromList fromList) throws StandardException :
{
    Properties properties;
}
{
    properties = propertyList(true) <CHECK_PROPERTIES>
    {
        fromList.setProperties(properties);
    }
}

void
tableReferences(FromList fromList) throws StandardException :
{
    FromTable tableReference;
}
{
    /* If we have a table constructor and the expression is a SELECT
     * query or a VALUES query then we read the <TABLE> keyword;
     * otherwise we leave the <TABLE> token in the queue and let
     * other types of expressions (namely, vtiTableConstruct())
     * deal with it accordingly.    DERBY-2152.
     */
    LOOKAHEAD( { getToken(1).kind == TABLE && getToken(2).kind == LEFT_PAREN &&
                                 (getToken(3).kind == SELECT || getToken(3).kind == VALUES) } )
    <TABLE>
    tableReference = tableReferenceTypes(false)
    {
        fromList.addFromTable(tableReference);
    }
|
    tableReference = tableReferenceTypes(false)
    {
        fromList.addFromTable(tableReference);
    }
}

FromTable
tableReferenceTypes(boolean nestedInParens) throws StandardException :
{
    FromTable tableReference;
}
{
    tableReference = tableReference(nestedInParens)
    {
        return tableReference ;
    }
|
    <LEFT_BRACE> <OJ> tableReference = tableReference(nestedInParens) <RIGHT_BRACE>
    {
        return tableReference;
    }
}

Object[]
optionalTableClauses() throws StandardException :
{
    Object[] otc = null;
    Properties tableProperties = null;
    ResultColumnList derivedRCL = null;
    String correlationName = null;
    IndexHintList indexHints = null;
}
{
    otc = optionalTableProperties() 
    {
        otc[OPTIONAL_TABLE_DERIVED_RCL] = derivedRCL;
        otc[OPTIONAL_TABLE_CORRELATION_NAME] = correlationName;
        return otc;
    }
|
    LOOKAHEAD( { indexHintFollows(1) } )
    indexHints = indexHints()
    {
        otc = new Object[OPTIONAL_TABLE_NCLAUSES];
        otc[OPTIONAL_TABLE_MYSQL_INDEX_HINTS] = indexHints;
        return otc;
    }
|
    [ 
        [ <AS> ] 
        correlationName = identifier()
        [ <LEFT_PAREN> derivedRCL = derivedColumnList() <RIGHT_PAREN> ] 
        [ indexHints = indexHints() ]
        [ tableProperties = propertyList(true) <CHECK_PROPERTIES> ] 
    ]
    {
        otc = new Object[OPTIONAL_TABLE_NCLAUSES];
        otc[OPTIONAL_TABLE_PROPERTIES] = tableProperties;
        otc[OPTIONAL_TABLE_DERIVED_RCL] = derivedRCL;
        otc[OPTIONAL_TABLE_CORRELATION_NAME] = correlationName;
        otc[OPTIONAL_TABLE_MYSQL_INDEX_HINTS] = indexHints;
        return otc;
    }
}

Object[]
optionalTableProperties() throws StandardException :
{
    Object[] otc = null;
    Properties tableProperties = null;
}
{
    tableProperties = propertyList(true) <CHECK_PROPERTIES> 
    {
        otc = new Object[OPTIONAL_TABLE_NCLAUSES];
        otc[OPTIONAL_TABLE_PROPERTIES] = tableProperties;
        return otc;
    }
}

IndexHintList
indexHints() throws StandardException :
{
    IndexHintList list = (IndexHintList)nodeFactory.getNode(NodeTypes.INDEX_HINT_LIST,
                                                            parserContext);
}
{
    indexHintList(list)
    {
        return list;
    }
}

void
indexHintList(IndexHintList list) throws StandardException :
{
}
{
    indexHint(list) 
    ( LOOKAHEAD( { getToken(1).kind != COMMA && indexHintFollows(2) } )
      <COMMA> indexHint(list) )*
}

void
indexHint(IndexHintList list) throws StandardException :
{
    IndexHintNode.HintType hintType;
    IndexHintNode.HintScope hintScope = null;
    List<String> indexes = new ArrayList<String>();
}
{
    hintType = indexHintType()
    (<INDEX> | <KEY>)
    [ <FOR> hintScope = indexHintScope() ]
    <LEFT_PAREN>
    [ indexHintIndex(indexes)
    ( <COMMA> indexHintIndex(indexes) )* ]
    <RIGHT_PAREN>
    {
        IndexHintNode indexHint = (IndexHintNode)
            nodeFactory.getNode(NodeTypes.INDEX_HINT_NODE,
                                hintType,
                                hintScope,
                                indexes,
                                parserContext);
        list.add(indexHint);
    }
}

IndexHintNode.HintType
indexHintType() throws StandardException :
{}
{
    <USE>
    { return IndexHintNode.HintType.USE; }
|           
    <IGNORE>
    { return IndexHintNode.HintType.IGNORE; }
|           
    <FORCE>
    { return IndexHintNode.HintType.FORCE; }
}

IndexHintNode.HintScope
indexHintScope() throws StandardException :
{}
{
    <JOIN>
    { return IndexHintNode.HintScope.JOIN; }
|           
    <ORDER> <BY>
    { return IndexHintNode.HintScope.ORDER_BY; }
|           
    <GROUP> <BY>
    { return IndexHintNode.HintScope.GROUP_BY; }
}

void
indexHintIndex(List<String> indexes) throws StandardException :
{
    String index;
    Token token;
}
{
    index = identifier()
    {
        indexes.add(index);
    }
|
    token = <PRIMARY>
    {
        indexes.add(token.image);
    }
}

FromTable
tableReference(boolean nestedInParens) throws StandardException :
{
    FromTable fromTable;
    TableOperatorNode joinTable = null;
}
{
    fromTable = tableFactor()
    ( 
        LOOKAHEAD( { joinedTableExpressionFollows() } )
        joinTable = joinedTableExpression((joinTable == null) ? fromTable : joinTable,
                                          nestedInParens)
    )*
    {
        return joinTable == null ? fromTable : joinTable;
    }
}

FromTable
tableFactor() throws StandardException :
{
    JavaToSQLValueNode javaToSQLNode = null;
    TableName tableName;
    String correlationName = null;
    ResultColumnList derivedRCL = null;
    FromTable fromTable;
    FromTable tableReference;
    Object[] optionalTableClauses = new Object[OPTIONAL_TABLE_NCLAUSES];
    Properties tableProperties = null;
    SubqueryNode derivedTable;
}
{
    // NOTE: this rule has to come first in order to avoid making NEW a reserved word.
    (
        LOOKAHEAD( { newInvocationFollows(1) } )
        javaToSQLNode = newInvocation()
    | 
        javaToSQLNode = vtiTableConstruct()
    )
    [ <AS> ] correlationName = identifier()
    [ <LEFT_PAREN> derivedRCL = derivedColumnList() <RIGHT_PAREN> ]
    [ optionalTableClauses = optionalTableProperties() ]
    {
        fromTable = (FromTable)nodeFactory.getNode(NodeTypes.FROM_VTI,
                                                   javaToSQLNode.getJavaValueNode(),
                                                   correlationName,
                                                   derivedRCL,
                                                   ((optionalTableClauses != null) ? 
                                                    (Properties)optionalTableClauses[OPTIONAL_TABLE_PROPERTIES] :
                                                    (Properties)null),
                                                   parserContext); 
        return fromTable;
    }
|
    tableName = qualifiedName() 
    optionalTableClauses = optionalTableClauses()
    {
        fromTable = (FromTable)nodeFactory.getNode(NodeTypes.FROM_BASE_TABLE,
                                                   tableName,
                                                   optionalTableClauses[OPTIONAL_TABLE_CORRELATION_NAME],
                                                   optionalTableClauses[OPTIONAL_TABLE_DERIVED_RCL],
                                                   optionalTableClauses[OPTIONAL_TABLE_PROPERTIES],
                                                   optionalTableClauses[OPTIONAL_TABLE_MYSQL_INDEX_HINTS],
                                                   parserContext);
        return fromTable;
    }
|
    // There is a grammar ambiguity with nested parentheses here.
    // A series of left parentheses could introduce either a table
    // reference or a derived table.    For example:
    //
    //      (((select c from t) a inner join (select d from s) b ))
    //
    // and:
    //
    //      (((select c from t) a)))
    //
    // To distinguish these two cases, we consider anything that starts
    // with a single parenthesis and either SELECT or VALUES to be
    // a derived table, and anything else to be a table reference.
    // Note that we can't use the subqueryFollows() lookahead method,
    // because it skips over all leading left parentheses to decide
    // whether a subquery follows.
    LOOKAHEAD( { getToken(1).kind == LEFT_PAREN &&
                                 (getToken(2).kind == SELECT || getToken(2).kind == VALUES) } )
    derivedTable = derivedTable() 
    [ <AS> ] correlationName = identifier()
    [ <LEFT_PAREN> derivedRCL = derivedColumnList() <RIGHT_PAREN> ]
    [ optionalTableClauses = optionalTableProperties() ]
    {
        fromTable = (FromTable)nodeFactory.getNode(NodeTypes.FROM_SUBQUERY,
                                                   derivedTable.getResultSet(),
                                                   derivedTable.getOrderByList(),
                                                   derivedTable.getOffset(),
                                                   derivedTable.getFetchFirst(),
                                                   correlationName,
                                                   derivedRCL,
                                                   ((optionalTableClauses != null) ?
                                                    (Properties)optionalTableClauses[OPTIONAL_TABLE_PROPERTIES] :
                                                    (Properties)null),
                                                   parserContext); 

        return fromTable;
    }
|
    <LEFT_PAREN> tableReference = tableReferenceTypes(true) <RIGHT_PAREN>
    {
        fromTable = tableReference;
        return fromTable;
    }
}

ResultColumnList
derivedColumnList() throws StandardException :
{
    ResultColumnList resultColumns = (ResultColumnList)
        nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                            parserContext);
}
{
    columnNameList(resultColumns)
    {
        return resultColumns;
    }
}

void
columnNameList(ResultColumnList columnList) throws StandardException :
{}
{
    columnNameItem(columnList) 
    ( <COMMA> columnNameItem(columnList) )*
}

void
columnNameItem(ResultColumnList columnList) throws StandardException :
{
    String columnName;
    ResultColumn resultColumn;
}
{
    columnName = identifier()
    {
        /*
        ** Store the column names for the result columns in the
        ** result column list.  We don't know yet what valueNodes
        ** should be hooked up to each result column, so set that
        ** to null for now.
        */
        resultColumn = (ResultColumn)nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                                         columnName,
                                                         null,
                                                         parserContext);
        columnList.addResultColumn(resultColumn);
    }
}

IndexColumn
getIndexColumn() throws StandardException :
{
    String columnName;
}
{
    columnName = identifier()
    {
        return (IndexColumn) nodeFactory.getNode(NodeTypes.INDEX_COLUMN,
                                                 columnName,
                                                 Boolean.TRUE,
                                                 parserContext);
    }
}


void
indexItemList(IndexColumnList columnList) throws StandardException :
{}
{
    indexItem(columnList) 
    ( <COMMA> indexItem(columnList) )*
}

void indexItem(IndexColumnList columnList) throws StandardException :
{
    String columnName;
    boolean asc = true;
}
{
    (
      <Z_ORDER_LAT_LON>
      <LEFT_PAREN>
      columnName = identifier()
      {
          int latPosition = columnList.size();
          IndexColumn lat = (IndexColumn)
              nodeFactory.getNode(NodeTypes.INDEX_COLUMN,
                                  columnName,
                                  Boolean.FALSE,
                                  parserContext);
          columnList.add(lat);
      }
      <COMMA>
      columnName = identifier()
      {
          IndexColumn lon = (IndexColumn)
              nodeFactory.getNode(NodeTypes.INDEX_COLUMN,
                                  columnName,
                                  Boolean.FALSE,
                                  parserContext);
          columnList.add(lon);
      }
      <RIGHT_PAREN>
      {
          columnList.applyFunction(IndexColumnList.FunctionType.Z_ORDER_LAT_LON,
                                   latPosition,
                                   2);
      }
    )
    |
    (
      columnName = identifier() 
      [ <ASC> | <DESC> { asc = false; } ]
      {
          IndexColumn indexColumn = (IndexColumn)
              nodeFactory.getNode(NodeTypes.INDEX_COLUMN,
                                  columnName,
                                  asc ? Boolean.TRUE : Boolean.FALSE,
                                  parserContext);
          columnList.add(indexColumn);
    }
    )
}

void
indexUnorderedColumnItem(IndexColumnList columnList) throws StandardException :
{
    String columnName;
}
{
    columnName = identifier() 
    {
        IndexColumn indexColumn = (IndexColumn)
            nodeFactory.getNode(NodeTypes.INDEX_COLUMN,
                                columnName,
                                Boolean.TRUE,
                                parserContext);
        columnList.add(indexColumn);
    }
}

SubqueryNode
derivedTable() throws StandardException :
{
    SubqueryNode tableSubquery;
}
{
    <LEFT_PAREN>
    tableSubquery = tableSubquery(SubqueryNode.SubqueryType.FROM, null)
    <RIGHT_PAREN>
    {
        return tableSubquery;
    }
}

TableOperatorNode
joinedTableExpression(ResultSetNode leftRSN, boolean nestedInParens) 
        throws StandardException :
{
    TableOperatorNode joinNode;
}
{
    joinNode = crossJoin(leftRSN, nestedInParens)
    {
        return joinNode;
    }
|
    joinNode = qualifiedJoin(leftRSN, nestedInParens) 
    {
        return joinNode;
    }
|
    joinNode = naturalJoin(leftRSN, nestedInParens)
    {
        return joinNode;
    }
}

TableOperatorNode
crossJoin(ResultSetNode leftRSN, boolean nestedInParens)
        throws StandardException :
{
    ResultSetNode rightRSN;
}
{
    <CROSS> <JOIN> rightRSN = tableFactor()
    {
                TableOperatorNode ton = newJoinNode(leftRSN,
                                                    rightRSN,
                                                    null, // no ON clause in CROSS JOIN
                                                    null, // no USING clause in CROSS JOIN
                                                    JoinNode.JoinType.INNER);
                ton.setNestedInParens(nestedInParens);
                return ton;
    }
}

TableOperatorNode
qualifiedJoin(ResultSetNode leftRSN, boolean nestedInParens) throws StandardException :
{
    JoinNode.JoinType joinType;
    ResultSetNode rightRSN;
    TableOperatorNode ton = null;
    Object[] onOrUsingClause = null;
    ResultColumnList usingClause = null;
    ValueNode onClause;
}
{
    joinType = qualifiedJoinType()
    rightRSN = tableReferenceTypes(nestedInParens) 
    onOrUsingClause = joinSpecification(leftRSN, rightRSN)
    {
        /* If NATURAL or CROSS is specified, then no joinSpecification()
         * is required, otherwise it is required. NATURAL and CROSS should
         * be handled by other rules, so this rule should always see a
         * joinSpecification().
         */

        /* Figure out whether an ON or USING clause was used */
        onClause = (ValueNode)onOrUsingClause[JOIN_ON];
        usingClause = (ResultColumnList)onOrUsingClause[JOIN_USING];

        if (onClause == null && usingClause == null) {
            throw new StandardException("Missing JOIN specification");
        }

        ton = newJoinNode(leftRSN, rightRSN, onClause, usingClause, joinType);

        /* Mark whether or not we are nested within parens */
        ton.setNestedInParens(nestedInParens);
        return ton;
    }
}

TableOperatorNode naturalJoin(ResultSetNode leftRSN, boolean nestedInParens)
        throws StandardException :
{
    JoinNode.JoinType joinType = JoinNode.JoinType.INNER;
    ResultSetNode rightRSN;
}
{
    <NATURAL> [ joinType = joinType() ] <JOIN> rightRSN = tableFactor()
    {
        JoinNode node = newJoinNode(leftRSN, rightRSN, null, null, joinType);
        node.setNestedInParens(nestedInParens);
        node.setNaturalJoin();
        return node;
    }
}

JoinNode.JoinType
joinType() throws StandardException :
{
    JoinNode.JoinType joinType;
}
{
    <INNER> 
    {
        return JoinNode.JoinType.INNER;
    }
|
    joinType = outerJoinType() [ <OUTER> ]
    {
        return joinType;
    }
}

JoinNode.JoinType
outerJoinType() throws StandardException :
{}
{
    <LEFT> 
    {
        return JoinNode.JoinType.LEFT_OUTER;
    }
|
    <RIGHT> 
    {
        return JoinNode.JoinType.RIGHT_OUTER;
    }
|
    <FULL> 
    {
        return JoinNode.JoinType.FULL_OUTER;
    }
}

JoinNode.JoinType
qualifiedJoinType() throws StandardException :
{
    JoinNode.JoinType joinType = JoinNode.JoinType.INNER;
}
{
    LOOKAHEAD( { straightJoinFollows() } ) 
    <STRAIGHT_JOIN> 
    {
        return JoinNode.JoinType.STRAIGHT;
    }
|
    [ joinType = joinType() ] <JOIN>
    {
        return joinType;
    }
}

Object[]
joinSpecification(ResultSetNode leftRSN, ResultSetNode rightRSN) 
        throws StandardException :
{
    Object[] onOrUsingClause = new Object[JOIN_NCLAUSES];
    ResultColumnList usingClause = null;
    ValueNode joinClause = null;
}
{
    joinClause = joinCondition() 
    {
        onOrUsingClause[JOIN_ON] = joinClause;
        onOrUsingClause[JOIN_USING] = usingClause;
        return onOrUsingClause;
    }
|
    usingClause = namedColumnsJoin()
    {
        onOrUsingClause[JOIN_ON] = joinClause;
        onOrUsingClause[JOIN_USING] = usingClause;
        return onOrUsingClause;
    }
}

ValueNode
joinCondition() throws StandardException :
{
    ValueNode joinClause;
}
{
    <ON> joinClause = valueExpression()
    {
        return joinClause;
    }
}

ResultColumnList
namedColumnsJoin() throws StandardException :
{
    ResultColumnList usingClause = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                         parserContext);
}
{
    <USING> <LEFT_PAREN> columnNameList(usingClause) <RIGHT_PAREN>
    {
        return usingClause;
    }
}

ResultSetNode
tableValueConstructor() throws StandardException :
{
    ResultSetNode    resultSetNode;
}
{
    <VALUES> resultSetNode = tableValueConstructorList()
    {
        return resultSetNode;
    }
}

ResultSetNode
tableValueConstructorList() throws StandardException :
{
    ResultSetNode resultSetNode;
}
{
    resultSetNode = rowValueConstructor(null) 
    ( <COMMA> resultSetNode = rowValueConstructor(resultSetNode) )*
    {
        if (resultSetNode instanceof UnionNode) {
            ((UnionNode)resultSetNode).markTopTableConstructor();
        }
        return resultSetNode;
    }
}

void
checkOptionalParens() throws StandardException:
{
}
{
    LOOKAHEAD ( {parensFollow()} )
    <LEFT_PAREN> <RIGHT_PAREN>
    {
        return;
    }
|
    {
        return;
    }
}

ValueNode
datetimeValueFunction() throws StandardException :
{
    int prec = -1; // can't be negative, if used
}
{
    LOOKAHEAD( { (getToken(1).kind == CURRENT && getToken(2).kind == DATE) } ) 
    <CURRENT> <DATE> 
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                              CurrentDatetimeOperatorNode.Field.DATE,
                                              parserContext);
    }
| 
    <CURRENT_DATE>
    {
        checkOptionalParens();
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                              CurrentDatetimeOperatorNode.Field.DATE,
                                              parserContext);
    }
|
    LOOKAHEAD( { (getToken(1).kind == CURRENT && getToken(2).kind == TIME) } )
    <CURRENT> <TIME> 
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                              CurrentDatetimeOperatorNode.Field.TIME,
                                              parserContext);
    }
| 
    <CURRENT_TIME> 
    {
        checkOptionalParens();
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                              CurrentDatetimeOperatorNode.Field.TIME,
                                              parserContext);
    }
|
    LOOKAHEAD( { (getToken(1).kind == CURRENT && getToken(2).kind == TIMESTAMP) } ) 
    <CURRENT> <TIMESTAMP> 
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                              CurrentDatetimeOperatorNode.Field.TIMESTAMP,
                                              parserContext);
    }
    | 
    <CURRENT_TIMESTAMP> 
    {
        checkOptionalParens();
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
                                              CurrentDatetimeOperatorNode.Field.TIMESTAMP,
                                              parserContext);
    }
}

/*
* Note that set function and aggregate are used interchangeably in the
* parser.    The tree has aggregate nodes.
*/
ValueNode
windowOrAggregateFunctionNode() throws StandardException :
{
    ValueNode winOrAgg;
    QueryTreeNode window = null;
}
{
    <COUNT> <LEFT_PAREN>
    ( <ASTERISK>
    {
            winOrAgg = (ValueNode)nodeFactory.getNode(NodeTypes.AGGREGATE_NODE,
                                                      null,
                                                      "CountAggregateDefinition",
                                                      Boolean.FALSE,
                                                      "COUNT(*)",
                                                      parserContext);
    }
    |
        winOrAgg = aggregateExpression("COUNT", "CountAggregateDefinition")
    )
    <RIGHT_PAREN> 
    [ window = overClause() ]
    {
        if (window != null) {
            winOrAgg = (ValueNode)nodeFactory.getNode(NodeTypes.AGGREGATE_WINDOW_FUNCTION_NODE,
                                                      window,
                                                      winOrAgg,
                                                      parserContext);
        }

        return winOrAgg;
    }
|
    <GROUP_CONCAT>
    winOrAgg = groupConcatExpression()
    {
        return winOrAgg;
    }
|
    winOrAgg = generalAggregate() 
    [ window = overClause() ]
    {
        if (window != null) {
            winOrAgg = (ValueNode)nodeFactory.getNode(NodeTypes.AGGREGATE_WINDOW_FUNCTION_NODE,
                                                      window,
                                                      winOrAgg,
                                                      parserContext);
        }

        return winOrAgg;
    }
|
    <ROWNUMBER> <LEFT_PAREN> <RIGHT_PAREN> 
    window = overClause()
    {
        winOrAgg = (ValueNode)nodeFactory.getNode(NodeTypes.ROW_NUMBER_FUNCTION_NODE,
                                                  null,
                                                  window,
                                                  parserContext);
        return winOrAgg;
    }
}

QueryTreeNode
overClause() throws StandardException :
{
    String windowRef;
    PartitionByList partitionCols = null;
    OrderByList orderCols = null;
}
{
    LOOKAHEAD( { getToken(2).kind == LEFT_PAREN || getToken(2).kind == IDENTIFIER } )
    <OVER>
    ( 
        <LEFT_PAREN>
        [ partitionCols = partitionByClause() ] 
        [ orderCols = orderByClause() ] 
        <RIGHT_PAREN>
    {
        return (QueryTreeNode)nodeFactory.getNode(NodeTypes.WINDOW_DEFINITION_NODE,
                                                  null,
                                                  partitionCols,
                                                  orderCols,
                                                  parserContext);
    }
    |
        windowRef = identifier()
    {
         return (QueryTreeNode)nodeFactory.getNode(NodeTypes.WINDOW_REFERENCE_NODE,
                                                   windowRef,
                                                   parserContext);
    }
 )
}

PartitionByList
partitionByClause() throws StandardException :
{
    PartitionByList partitionByList = (PartitionByList)nodeFactory.getNode(NodeTypes.PARTITION_BY_LIST,
                                                                       parserContext);
}
{
    <PARTITION> <BY>
    windowPartitionColumnReference(partitionByList)
    ( <COMMA> windowPartitionColumnReference(partitionByList) )*
    {
        return partitionByList;
    }
}

void
windowPartitionColumnReference(PartitionByList partitionByList) throws StandardException :
{
    ColumnReference column;
    String collation = null; 
}
{
    column = columnReference()
    [ collation = collateClause() ]
    {
        ValueNode partitionColumn = column;
        if (collation != null)
            partitionColumn = (ValueNode)nodeFactory.getNode(NodeTypes.EXPLICIT_COLLATE_NODE,
                                                             partitionColumn,
                                                             collation,
                                                             parserContext);
        PartitionByColumn partitionBy = (PartitionByColumn)nodeFactory.getNode(NodeTypes.PARTITION_BY_COLUMN,
                                                                               partitionColumn,
                                                                               parserContext);
        partitionByList.add(partitionBy);
    }
}

ValueNode
groupConcatExpression() throws StandardException :
{
    boolean distinct = false;
    ValueNode value;
    OrderByList orderCols = null;
    String sep = ",";
}
{

/*
GROUP_CONCAT([DISTINCT] expr [,expr ...]
             [ORDER BY {unsigned_integer | col_name | expr}
                 [ASC | DESC] [,col_name ...]]
             [SEPARATOR str_val])
*/
    <LEFT_PAREN>
    [ distinct = setQuantifier() ] 
    value = concatColumns()
    [ orderCols = orderByClause() ]
    [ <SEPARATOR> sep = getStringLiteral() ]
    <RIGHT_PAREN>
    {


        return (ValueNode)nodeFactory.getNode(NodeTypes.GROUP_CONCAT_NODE,
                                              value,
                                              "GroupConcatDefinitionNode",
                                              distinct ? Boolean.TRUE : Boolean.FALSE,
                                              "GROUP_CONCAT",
                                              orderCols,
                                              sep,
                                              parserContext);

    }
}

ValueNode
concatColumns() throws StandardException :
{
    QueryTreeNode newNode;
    List<ValueNode> paramList= new ArrayList<ValueNode>();
}
{
    colsList(paramList)
    {
        switch(paramList.size())
        {
            case 0:
                throw new StandardException("GROUP_CONCAT must have at least one argument");
            case 1:
                return paramList.get(0);
            default:
                newNode = nodeFactory.getNode(NodeTypes.NEW_INVOCATION_NODE,
                                              "concat",
                                              paramList,
                                              lastTokenDelimitedIdentifier,
                                              null,
                                              null,
                                              parserContext);

                return (ValueNode)nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                               newNode,
                                                               parserContext);
        }
    }
}

void
colsList(List<ValueNode> parameterList) throws StandardException :
{}
{
    
    methodParameter(parameterList)
    ( <COMMA> methodParameter(parameterList) )*
    
}

ValueNode
aggregateExpression(String aggName, String aggClass) throws StandardException :
{
    boolean distinct = false;
    ValueNode value;
}
{
    [ distinct = setQuantifier() ] 
    value = additiveExpression()
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.AGGREGATE_NODE,
                                              value,
                                              aggClass,
                                              distinct ? Boolean.TRUE : Boolean.FALSE,
                                              aggName,
                                              parserContext);
    }
}

ValueNode
generalAggregate() throws StandardException :
{
    Token aggToken;
    String methodAliasString;
    ValueNode aggExpr;
    ValueNode value;
}
{
    aggToken = builtInAggregateType()
    <LEFT_PAREN>
    aggExpr = aggregateExpression(aggName(aggToken), aggClass(aggToken))
    <RIGHT_PAREN>
    {
        return aggExpr;
    }
}

/*
** All built in aggregates are pretty similar to user
** defined aggregates, except we know what to map to
** without looking up the class name.
**
** NOTE: COUNT is omitted here because the COUNT aggregate is
** factored into a different rule, to distinguish between
** COUNT(*) and COUNT(<expression>).
*/
Token
builtInAggregateType() throws StandardException :
{
    Token retval;
}
{
    (
        retval = <MAX> |
        retval = <AVG> |
        retval = <MIN> |
        retval = <SUM>
    )
    {
        return retval;
    }
}

ValueNode
castSpecification() throws StandardException :
{
    DataTypeDescriptor dts;
    ValueNode treeTop;
    ValueNode value;
    int charType;
    int length = -1;
}
{
    <CAST> <LEFT_PAREN> value = castOperand() 
    <AS> dts = dataTypeCast() <RIGHT_PAREN>
    {
        treeTop = (ValueNode)nodeFactory.getNode(NodeTypes.CAST_NODE,
                                                 value,
                                                 dts,
                                                 parserContext);
        ((CastNode)treeTop).setForExternallyGeneratedCASTnode();

        /* We need to generate a SQL->Java conversion tree above us if
         * the dataTypeCast is a user type.
         */
        if (dts.getTypeId().userType()) {
            treeTop = (ValueNode)nodeFactory.getNode(NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                     nodeFactory.getNode(NodeTypes.SQL_TO_JAVA_VALUE_NODE,
                                                                         treeTop,
                                                                         parserContext),
                                                     parserContext);
        }

        return treeTop;
    }
}

/**
 * Next value from a sequence object
 */
ValueNode
nextValueExpression() throws StandardException :
{
    ValueNode nextValue;
    TableName sequenceName;
}
{
    <NEXT> <VALUE> <FOR> sequenceName = qualifiedName()
    {
        nextValue = (ValueNode)nodeFactory.getNode(NodeTypes.NEXT_SEQUENCE_NODE,
                                                   sequenceName,
                                                   parserContext);

        return nextValue;
    } 
}

/**
 * Current value from a sequence object
 */
ValueNode
currentValueExpression() throws StandardException :
{
    ValueNode sequenceValue;
    TableName sequenceName;
}
{
    LOOKAHEAD( { getToken(1).kind == CURRENT && getToken(2).kind == VALUE && getToken(3).kind == FOR } )
    <CURRENT> <VALUE> <FOR> sequenceName = qualifiedName()
    {
        sequenceValue = (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_SEQUENCE_NODE,
                                                       sequenceName,
                                                       parserContext);

        return sequenceValue;
    } 
}

int
charOrVarchar() :
{}
{
    <CHAR>
    {
        return Types.CHAR;
    }
|
    <VARCHAR>
    {
        return Types.VARCHAR;
    }
}

ValueNode
castOperand() throws StandardException :
{
    ValueNode value;
}
{
    value = additiveExpression()
    {
        return value;
    }
}

ParameterNode
dynamicParameterSpecification() throws StandardException :
{
    Token tok;
}
{
    <QUESTION_MARK>
    {
        return makeParameterNode(parameterNumber++);
    }
|
    tok = <DOLLAR_N>
    {
        int n = Integer.parseInt(tok.image.substring(1));
        return makeParameterNode(n-1);
    }
}

ValueNode
whereClause(Token beginToken) throws StandardException :
{
    ValueNode value;
    Token endToken;
}
{
    value = valueExpression()
    {
        endToken = getToken(0);

        value.setBeginOffset(beginToken.endOffset + 1);
        value.setEndOffset(endToken.endOffset);

        return value;
    }
}

GroupByList
groupByClause() throws StandardException :
{
    GroupByList groupingCols;
}
{
    <GROUP> <BY> 
    (
        LOOKAHEAD ( { getToken(1).kind == ROLLUP && getToken(2).kind == LEFT_PAREN } )
        <ROLLUP> <LEFT_PAREN> groupingCols = groupingColumnReferenceList() <RIGHT_PAREN>
    {
        groupingCols.setRollup();
        return groupingCols;
    }
    |
        groupingCols = groupingColumnReferenceList()
    {
        return groupingCols;
    }
    )
}

GroupByList
groupingColumnReferenceList() throws StandardException :
{
    GroupByList groupingCols = (GroupByList)nodeFactory.getNode(NodeTypes.GROUP_BY_LIST,
                                                                parserContext);
}
{
    groupingColumnReference(groupingCols) 
    ( <COMMA> groupingColumnReference(groupingCols) )*
    {
        return groupingCols;
    }
}

void
groupingColumnReference(GroupByList groupingCols) throws StandardException :
{
    ValueNode columnExpression;
}
{
    columnExpression = additiveExpression()
    {
        /* Aggregates not allowed in group by */
        HasNodeVisitor visitor = new HasNodeVisitor(AggregateNode.class);
        columnExpression.accept(visitor);
        if (visitor.hasNode()) {
            throw new StandardException("Aggregate values not allowed in GROUP BY");
        }

        if (columnExpression.isParameterNode()) {
            throw new StandardException("Parameters not allowed in GROUP BY");
        }
        groupingCols.addGroupByColumn(
            (GroupByColumn)nodeFactory.getNode(NodeTypes.GROUP_BY_COLUMN,
                                               columnExpression,
                                               parserContext));
    }
}

ValueNode
havingClause() throws StandardException :
{
    ValueNode value;
}
{
    <HAVING> value = valueExpression()
    {
        return value;
    }
}

WindowList
windowClause() throws StandardException :
{
    WindowList windows = new WindowList();
    windows.setParserContext(parserContext);
}
{
    <WINDOW> windows = windowDefinition(windows)
    ( <COMMA> windows = windowDefinition(windows) )*
    {
        return windows;
    }
}

WindowList
windowDefinition(WindowList wl) throws StandardException :
{
    String windowName;
    PartitionByList partitionCols = null;
    OrderByList orderCols = null;
}
{
    windowName = identifier()
    <AS> <LEFT_PAREN>
    [ partitionCols = partitionByClause() ] 
    [ orderCols = orderByClause() ] 
    <RIGHT_PAREN>
    {
        wl.addWindow(
            (WindowDefinitionNode)nodeFactory.getNode(NodeTypes.WINDOW_DEFINITION_NODE,
                                                      windowName,
                                                      partitionCols,
                                                      orderCols,
                                                      parserContext));

        return wl;
    }
}

StatementNode
schemaDefinition() throws StandardException :
{
    String schemaName = null;
    String authName = null;
    TableName characterSet = null;
    TableName collation = null;
    CharacterTypeAttributes defaultCharacterAttributes = null;
    ExistenceCheck cond = ExistenceCheck.NO_CONDITION;
}
{
    /*
    ** CREATE SCHEMA:
    ** We are not currently handling schema bodies.
    */
    <SCHEMA> cond = createCondition()
    (
        schemaName = identifier() [ <AUTHORIZATION> authName = identifier() ]
    |
        <AUTHORIZATION> authName = identifier() 
        {
            schemaName = authName;
        }
    )
    [ LOOKAHEAD( { getToken(2).kind == CHARACTER } )
      <_DEFAULT> <CHARACTER> <SET> characterSet = qualifiedName() 
      { defaultCharacterAttributes = CharacterTypeAttributes.forCharacterSet(characterSet.toString()); } ]
    [ LOOKAHEAD( { getToken(2).kind == COLLATION } )
      <_DEFAULT> <COLLATION> collation = qualifiedName() 
      { defaultCharacterAttributes = CharacterTypeAttributes.forCollation(defaultCharacterAttributes, collation.toString()); } ]
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.CREATE_SCHEMA_NODE,
                                                  schemaName,
                                                  authName,
                                                  defaultCharacterAttributes,
                                                  cond,
                                                  parserContext);
    }
}

StatementNode
roleDefinition() throws StandardException :
{
    String roleName = null;
}
{
    /*
     * CREATE ROLE
     *
     * Not currently supported: [ WITH ADMIN <grantor>]
     */
    <ROLE> roleName = identifier()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.CREATE_ROLE_NODE,
                                                  roleName,
                                                  parserContext);
    }
}

StatementNode
sequenceDefinition() throws StandardException :
{
    TableName qualifiedSequenceName = null;
    DataTypeDescriptor dtd = null;
    Long initialValue = null;
    Long stepValue = null;
    Long maxValue = null;
    Long minValue = null;
    Boolean cycle = Boolean.FALSE;
    Object[] optionalClauses = new Object[SEQUENCE_NCLAUSES];
}
{
    <SEQUENCE> qualifiedSequenceName = qualifiedName()
    ( sequenceGeneratorOption( optionalClauses ) )*
    {
        if (optionalClauses[SEQUENCE_DATA_TYPE] != null) { 
            dtd = (DataTypeDescriptor)optionalClauses[SEQUENCE_DATA_TYPE]; 
        }

        if (optionalClauses[SEQUENCE_START_WITH] != null) { 
            initialValue = (Long)optionalClauses[SEQUENCE_START_WITH]; 
        }
        if (optionalClauses[SEQUENCE_INCREMENT_BY] != null) { 
            stepValue = (Long)optionalClauses[SEQUENCE_INCREMENT_BY]; 
        }
        if ((optionalClauses[SEQUENCE_MAX_VALUE] != null) &&
                (!(optionalClauses[SEQUENCE_MAX_VALUE] instanceof Boolean))) {
            maxValue = (Long)optionalClauses[SEQUENCE_MAX_VALUE]; 
        }
        if ((optionalClauses[SEQUENCE_MIN_VALUE] != null) &&
                (!(optionalClauses[SEQUENCE_MIN_VALUE] instanceof Boolean))) { 
            minValue = (Long)optionalClauses[SEQUENCE_MIN_VALUE]; 
        }

        if (optionalClauses[SEQUENCE_CYCLE] != null) { 
            cycle = (Boolean)optionalClauses[SEQUENCE_CYCLE]; 
        }

        return (StatementNode)nodeFactory.getNode(NodeTypes.CREATE_SEQUENCE_NODE,
                                                  qualifiedSequenceName,
                                                  dtd,
                                                  initialValue,
                                                  stepValue,
                                                  maxValue,
                                                  minValue,
                                                  cycle,
                                                  parserContext);
    }
}

void
sequenceGeneratorOption(Object[] optionalClauses) throws StandardException :
{
    Object option = null;
    int optionIndex = -1;
    Boolean[] cycleOption = new Boolean[1];
    String optionName = null;
    Token optionToken = null;
}
{
(
    optionToken = <AS> option = exactIntegerType()
    { 
        optionIndex = SEQUENCE_DATA_TYPE; 
    }
|
    optionToken = <START> <WITH> option = exactIntegerObject()
    {
        optionIndex = SEQUENCE_START_WITH; 
    }
|
    optionToken = <INCREMENT> <BY> option = exactIntegerObject()
    { 
        optionIndex = SEQUENCE_INCREMENT_BY; 
    }
|
    (
        ( optionToken = <MAXVALUE> option = exactIntegerObject() )
    |
        LOOKAHEAD( { getToken(2).kind == MAXVALUE } )
        ( <NO> optionToken = <MAXVALUE> ) { option = Boolean.FALSE; }
    )
    { 
        optionIndex = SEQUENCE_MAX_VALUE; 
    }
|
    (
        ( optionToken = <MINVALUE> option = exactIntegerObject() )
    |
        LOOKAHEAD( { getToken(2).kind == MINVALUE } )
        ( <NO> optionToken = <MINVALUE> ) { option = Boolean.FALSE; }
    )
    { 
        optionIndex = SEQUENCE_MIN_VALUE; 
    }
|
    optionToken = cycleClause(cycleOption)
    {
        option = cycleOption[0];
        optionIndex = SEQUENCE_CYCLE;
    }
)
    {
        if (optionIndex != -1) {
            if (optionalClauses[optionIndex] != null) {
                throw new StandardException("Repeated SEQUENCE clause");
            }
            optionalClauses[ optionIndex ] = option;
        }
    }
}

Token
cycleClause(Boolean[] cycleOption) throws StandardException :
{
    Token token = null;
}
{
    token = <CYCLE>
    {
        cycleOption[0] = Boolean.TRUE;
        return token;
    }
|
    <NO> token = <CYCLE>
    {
        cycleOption[0] = Boolean.FALSE;
        return token;
    }
}

Long
exactIntegerObject() throws StandardException :
{
    long exactNumeric;
}
{
    exactNumeric = exactNumber()
    {
        return new Long(exactNumeric);
    }
}

Long
stepValue() throws StandardException :
{
    long stepValue;
}
{
    <INCREMENT> <BY> stepValue = exactNumber()
    {
        return new Long(stepValue);
    }
}

StatementNode
dropSequenceStatement() throws StandardException :
{
    TableName sequenceName;
    ExistenceCheck cond;
}
{
    /*
     * DROP SEQUENCE <sequencename> RESTRICT
     */
    <SEQUENCE> cond = dropCondition() sequenceName = qualifiedName() <RESTRICT>
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.DROP_SEQUENCE_NODE,
                                                  sequenceName,
                                                  new Integer(StatementType.DROP_RESTRICT),
                                                  cond,
                                                  parserContext);
    }
}

StatementNode
tableDefinition() throws StandardException :
{
    TableName tableName;
    TableElementList tableElementList;
    Properties properties = null;
    char lockGranularity = CreateTableNode.DEFAULT_LOCK_GRANULARITY;
    ResultColumnList resultColumns = null;
    ResultSetNode queryExpression;
    boolean withData = true;
    ExistenceCheck cond;
}
{
    <TABLE> cond = createCondition() tableName = qualifiedName()
    // Lookahead needed to choose between tableElementList and
    // tableColumnList.
    (        
        LOOKAHEAD( { getToken(1).kind == LEFT_PAREN && 
                     getToken(3).kind != COMMA && getToken(3).kind != RIGHT_PAREN } )
        tableElementList = tableElementList()
        [ properties = propertyList(false)<CHECK_PROPERTIES>]
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.CREATE_TABLE_NODE,
                                                  tableName,
                                                  tableElementList,
                                                  properties,
                                                  new Character(lockGranularity),
                                                  cond,
                                                  parserContext);
    }
    |
        [ <LEFT_PAREN> resultColumns = tableColumnList() <RIGHT_PAREN> ]
        <AS> queryExpression = queryExpression(null, NO_SET_OP)
        <WITH> [ <NO> { withData = false; } ] <DATA>
    {
        /* Parameters not allowed in create table */
        HasNodeVisitor visitor =
            new HasNodeVisitor(ParameterNode.class);
        queryExpression.accept(visitor);
        if (visitor.hasNode()) {
            throw new StandardException("Parameters not allowed in CREATE TABLE");
        }

        StatementNode result = (StatementNode)nodeFactory.getNode(NodeTypes.CREATE_TABLE_NODE,
                                                                  tableName,
                                                                  resultColumns,
                                                                  queryExpression,
                                                                  cond,
                                                                  parserContext);
        if (withData) {
            ((CreateTableNode)result).markWithData();
        }
        return result;
    }
    )
}

ResultColumnList
tableColumnList() throws StandardException :
{
    ResultColumnList resultColumns = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                           parserContext);
}
{
    columnNameList(resultColumns)
    {
        return resultColumns;
    }
}

/*
 * This method is called when a comment starting with --derby-properties is found.
 * Such a comment is a special directive to Derby and allows a sql to pass optimizer
 * overrides. Derby looks for propertyName=value [,propertyName=value]* after
 * --derby-properties and returns these properties in a Properties object as a return 
 * value of this method.
 * The param propertiesUseAllowed true indicates that users are allowed to 
 * specify optimizer overrides in the given context. 
 * False means optimizer overrides in the given context are allowed internally 
 * only eg impl/load/import.java specifies property insertMode=replace/bulkInsert
 * in the insert statement. This same property will not be acceptable from an 
 * insert statement from a user sql.
 */
Properties
propertyList(boolean propertiesUseAllowed) throws StandardException :
{
    Properties properties = new Properties();
    StringTokenizer commaSeparatedProperties;
    StringTokenizer equalOperatorSeparatedProperty;
}
{
    <DERBYDASHPROPERTIES> 
    {
        //first use StringTokenizer to get tokens which are delimited by ,s
        commaSeparatedProperties = new StringTokenizer(getToken(1).image, ",");
        while (commaSeparatedProperties.hasMoreTokens()) {
            //Now verify that tokens delimited by ,s follow propertyName=value pattern
            String currentProperty = commaSeparatedProperties.nextToken();
            equalOperatorSeparatedProperty = new StringTokenizer(currentProperty,"=", true);
            if (equalOperatorSeparatedProperty.countTokens() != 3)
                throw new StandardException("Invalid properties syntax");
            else {
                String key = equalOperatorSeparatedProperty.nextToken().trim();
                if (!equalOperatorSeparatedProperty.nextToken().equals("="))
                    throw new StandardException("Invalid properties syntax");
                String value = equalOperatorSeparatedProperty.nextToken().trim();
                parserContext.checkStringLiteralLengthLimit(value);
                /* Trim off the leading and trailing ', and compress all '' to ' */
                if (value.startsWith("'") && value.endsWith("'"))
                    value = trimAndCompressQuotes(value, SINGLEQUOTES, false);
                /* Trim off the leading and trailing ", and compress all "" to " */
                else if (value.startsWith("\"") && value.endsWith("\""))
                    value = trimAndCompressQuotes(value, DOUBLEQUOTES, false);
                else 
                    value = value.toUpperCase();
                // Do not allow user to specify multiple values for the same key
                if (properties.put(key, value) != null) {
                    throw new StandardException("Duplicate property: " + key);
                }
            }
        }
        //if this property override is supported in internal mode only, then do that verification here.
        if (!propertiesUseAllowed) {
            // TODO: What to do?
        }
        return properties;
    }
}

char
DB2lockGranularityClause() throws StandardException :
{
    char lockGranularity;
}
{
    <LOCKSIZE> lockGranularity = lockGranularity()
    {
        return lockGranularity;
    }
}

char
lockGranularity() throws StandardException :
{
}
{
    <TABLE>
    {
        return CreateTableNode.TABLE_LOCK_GRANULARITY;
    }
|
    <ROW>
    {
        return CreateTableNode.ROW_LOCK_GRANULARITY;
    }
}

StatementNode
indexDefinition() throws StandardException :
{
    Boolean unique = Boolean.FALSE;
    Properties properties = null;
    TableName indexName;
    TableName tableName;
    IndexColumnList indexColumnList = null;
    boolean groupFormat = hasFeature(SQLParserFeature.GROUPING);
    JoinNode.JoinType joinType = null;
    ExistenceCheck cond;
    StorageLocation location = null;
}
{
    [ unique = unique() ] 
    <INDEX>
    cond = createCondition()
    indexName = qualifiedName() 
    <ON> tableName = qualifiedName()
    <LEFT_PAREN>
    (
      LOOKAHEAD ( { groupFormat } )
      groupIndexItemList(indexColumnList = (IndexColumnList)nodeFactory.getNode(NodeTypes.INDEX_COLUMN_LIST, parserContext))
    |
      LOOKAHEAD ( { !groupFormat } )
      indexItemList(indexColumnList = (IndexColumnList)nodeFactory.getNode(NodeTypes.INDEX_COLUMN_LIST, parserContext))
    )
    <RIGHT_PAREN>
    [ LOOKAHEAD ( { groupFormat && getToken(1).kind == USING } )
      <USING> joinType = joinType() <JOIN> ]
    [ properties = propertyList(false) <CHECK_PROPERTIES>]
    [ <AS> location = getLocation() ]
    {
        /* User allowed to specify schema name on table and index.
         * If no schema name specified for index, then it "inherits" 
         * its schema name from the table.
         * If index has a schema name and table does not, then
         * table "inherits" its schema name from the index.
         * If schema names are specified for both objects, then the
         * schema names must be the same.
         */
        if (indexName.getSchemaName() == null) {
            indexName.setSchemaName(tableName.getSchemaName());
        }
        else if (tableName.getSchemaName() == null) {
            tableName.setSchemaName(indexName.getSchemaName());
        }
        else {
            /* schema name specified for both */
            if (! (indexName.getSchemaName().equals(
                        tableName.getSchemaName()))) {
                throw new StandardException("Specified schemas do not match: " + 
                                            indexName + ", " + tableName);
            }
        }
        return (StatementNode)nodeFactory.getNode(NodeTypes.CREATE_INDEX_NODE,
                                                  unique,
                                                  null,
                                                  indexName,
                                                  tableName,
                                                  indexColumnList,
                                                  joinType,
                                                  properties,
                                                  cond,
                                                  location,
                                                  parserContext);
    }
}

Boolean
unique() throws StandardException :
{}
{
    <UNIQUE>
    {
        return Boolean.TRUE;
    }
}

/**
    CREATE PROCEDURE

    procedureElements contains the description of the procedure.
    (CREATE FUNCTIONS shares this lyout), see functionDefinition

    0 - Object[] 3 element array for parameters
    1 - TableName - specific name
    2 - Integer - dynamic result set count
    3 - String language
    4 - String external name
    5 - Short parameter style
    6 - Short - SQL allowed.
    7 - Boolean - CALLED ON NULL INPUT (always TRUE for procedures)
    8 - DataTypeDescriptor - return type (always NULL for procedures)
    9 - Boolean - definers rights
   10 - String - inline definition
*/

StatementNode
procedureDefinition(Boolean createOrReplace) throws StandardException :
{
    TableName procedureName;
    Object[] procedureElements = new Object[CreateAliasNode.ROUTINE_ELEMENT_COUNT];
}
{
    <PROCEDURE> procedureName = qualifiedName()
    procedureElements[0] = procedureParameterList()
    ( routineElement(true, false, procedureElements) ) +
    {
        checkRequiredRoutineClause(procedureElements);

        return getCreateAliasNode(procedureName,
                                  (String)procedureElements[CreateAliasNode.EXTERNAL_NAME],
                                  procedureElements,
                                  AliasInfo.Type.PROCEDURE,
                                  createOrReplace);
    }
}

void
routineElement(boolean isProcedure, boolean isTableFunction, Object[] routineElements) 
        throws StandardException :
{
    int drs;
    int clausePosition = -1;
    Object clauseValue = null;
}
{
(
    <SPECIFIC> clauseValue = qualifiedName()
    {
        clausePosition = CreateAliasNode.TABLE_NAME; 
        throw new StandardException("Not implemented SPECIFIC identifier");
    }
|
    [ <DYNAMIC> ] <RESULT> <SETS> drs = uint_value()
    {
        if (!isProcedure)
            throw new StandardException("Only allowed on procedure: RESULT SETS");
        clauseValue = drs; 
        clausePosition = CreateAliasNode.DYNAMIC_RESULT_SET_COUNT;
    }
|
    <LANGUAGE> clauseValue = routineLanguage() { clausePosition = CreateAliasNode.LANGUAGE; }
|
    <DETERMINISTIC>
    {
        clauseValue = Boolean.TRUE;
        clausePosition = CreateAliasNode.DETERMINISTIC;
    }
|
    <NOT> <DETERMINISTIC>
    {
        clauseValue = Boolean.FALSE;
        clausePosition = CreateAliasNode.DETERMINISTIC; 
    }
|
    <EXTERNAL>
    ( 
        <NAME> clauseValue = string()
    { clausePosition = CreateAliasNode.EXTERNAL_NAME; }
    |
        <SECURITY>
    { 
        clauseValue = new Boolean(routineSecurityClause());
        clausePosition = CreateAliasNode.ROUTINE_SECURITY_DEFINER;
    }
    )
|
    <PARAMETER> <STYLE> clauseValue = parameterStyle()
    {
        clausePosition = CreateAliasNode.PARAMETER_STYLE; 
    }
|
    <AS> clauseValue = string()
    {
        clausePosition = CreateAliasNode.INLINE_DEFINITION; 
    }
|
    <NO> <SQL>
    {
        clauseValue = RoutineAliasInfo.SQLAllowed.NO_SQL;
        clausePosition = CreateAliasNode.SQL_CONTROL; 
    }
|    
    <CONTAINS> <SQL>
    { 
        clauseValue = RoutineAliasInfo.SQLAllowed.CONTAINS_SQL;
        clausePosition = CreateAliasNode.SQL_CONTROL; 
    }
|    
    <READS> <SQL> <DATA>
    {
        clauseValue = RoutineAliasInfo.SQLAllowed.READS_SQL_DATA;
        clausePosition = CreateAliasNode.SQL_CONTROL; 
    }
|    
    <MODIFIES> <SQL> <DATA>
    {
        if (!isProcedure)
            throw new StandardException("Only allowed on procedure: MODIFIES SQL DATA");
        clauseValue = RoutineAliasInfo.SQLAllowed.MODIFIES_SQL_DATA;
        clausePosition = CreateAliasNode.SQL_CONTROL;
    }
|       
    clauseValue = calledOnNullInput(isProcedure) { clausePosition = CreateAliasNode.NULL_ON_NULL_INPUT; }
)
    {
        if (clausePosition != -1) {
            // check for repeated clause
            if (routineElements[clausePosition] != null) {

                String which = ROUTINE_CLAUSE_NAMES[clausePosition];
                throw new StandardException("Repeated " + which + " clause");
            }
                
            routineElements[clausePosition] = clauseValue;
        }
    }
}

Boolean
calledOnNullInput(boolean isProcedure) throws StandardException :
{
    Boolean calledOnNull;
}
{
(
    <CALLED> 
    {
        calledOnNull = Boolean.TRUE; 
    }
| 
    <RETURNS> <NULL> 
    {
        if (isProcedure)
            throw new StandardException("Not allowed for procedure RETURNS NULL ON NULL INPUT");
        calledOnNull = Boolean.FALSE;
    }
)
    <ON> <NULL> <INPUT>
    {
        return calledOnNull;
    }
}

boolean
routineSecurityClause() throws StandardException :
{
    boolean result = false;
}
{
(
    <INVOKER>
    {
        result = false;
    }
|       
    <DEFINER> 
    { 
        result = true; 
    }
)
    {
        return result;
    }
}

String
routineLanguage() throws StandardException :
{
    String ident;
    Token token;
}
{
(
    ident = identifier()
|       
    token = <SQL>
    { 
        ident = token.image;
    }
)
    {
        return ident;
    }
}

String
parameterStyle() throws StandardException :
{
    String ident;
    Token token;
}
{
(
    ident = identifier()
)
    {
        return ident;
    }
}

List[]
procedureParameterList() throws StandardException :
{
    // TODO: Need some struct or something
    List[] list = new List[3];
    list[0] = new ArrayList<String>(); // name
    list[1] = new ArrayList<DataTypeDescriptor>(); // type
    list[2] = new ArrayList<Integer>(); // in/out
}
{
    <LEFT_PAREN>
    [ procedureParameterDefinition(list)
        ( <COMMA> procedureParameterDefinition(list) )* ]
    <RIGHT_PAREN>
    {
        return list;
    }
}

void
procedureParameterDefinition(List[] list) throws StandardException :
{
    DataTypeDescriptor typeDescriptor;
    String parameterName = null;
    Integer inout;
}
{
    inout = inoutParameter()
    
    // Lookahead needed because token could satisfy identifier and dataTypeDDL
    [ LOOKAHEAD( { dataTypeCheck(2) })
        parameterName = identifier() ]
    typeDescriptor = dataTypeDDL()
    {
        list[0].add(parameterName);
        list[1].add(typeDescriptor);
        list[2].add(inout);
    }
}

Integer
inoutParameter() :
{
    int mode = ParameterMetaData.parameterModeIn;
}
{
    [
        <IN> { }
    | 
        <OUT> { mode = ParameterMetaData.parameterModeOut; }
    | 
        <INOUT> { mode = ParameterMetaData.parameterModeInOut; }
    ]
    { 
        return mode;
    }
}

/**
    CREATE FUNCTION

    functionElements contains the description of the function.

    0 - Object[] 3 element array for parameters
    1 - TableName - specific name
    2 - Integer - dynamic result set count - always 0
    3 - String language
    4 - String external name
    5 - Short parameter style
    6 - Short - SQL allowed.
    7 - Boolean - CALLED ON NULL INPUT
    8 - DataTypeDescriptor - return type
    9 - Boolean - definers rights
   10 - String - inline definition
*/

StatementNode
functionDefinition(Boolean createOrReplace) throws StandardException :
{
    TableName functionName;
    DataTypeDescriptor returnType;
    Object[] functionElements = new Object[CreateAliasNode.ROUTINE_ELEMENT_COUNT];
}
{
    <FUNCTION> functionName = qualifiedName()
    functionElements[0] = functionParameterList()
    <RETURNS> returnType = functionReturnDataType() 
    ( routineElement(false, returnType.isRowMultiSet(), functionElements) )+
    {
        functionElements[CreateAliasNode.RETURN_TYPE] = returnType;
        checkRequiredRoutineClause(functionElements);
                
        return getCreateAliasNode(functionName,
                                  (String)functionElements[CreateAliasNode.EXTERNAL_NAME],
                                  functionElements,
                                  AliasInfo.Type.FUNCTION,
                                  createOrReplace);
    }
}

Object[]
functionParameterList() throws StandardException :
{
    List[] list = new List[3];
    list[0] = new ArrayList<String>(); // name
    list[1] = new ArrayList<DataTypeDescriptor>(); // type
    list[2] = new ArrayList<Integer>(); // in/out - ALWAYS IN
}
{
    <LEFT_PAREN>
    [ functionParameterDefinition(list)
        ( <COMMA> functionParameterDefinition(list) )* ]
    <RIGHT_PAREN>
    {
        return list;
    }
}

void
functionParameterDefinition(List[] list) throws StandardException :
{
    DataTypeDescriptor typeDescriptor;
    String parameterName = "";
}
{
    // Lookahead needed because token could satisfy identifier and dataTypeDDL
    [ LOOKAHEAD( { dataTypeCheck(2) })
        parameterName = identifier() ]
    typeDescriptor = dataTypeDDL() 
    {
        list[0].add(parameterName);
        list[1].add(typeDescriptor);
        list[2].add(ParameterMetaData.parameterModeIn);
    }
}

DataTypeDescriptor
functionReturnDataType() throws StandardException :
{
    DataTypeDescriptor typeDescriptor;
}
{
(
    typeDescriptor = catalogType()
|
    typeDescriptor = functionTableType()
)
    {
        return typeDescriptor;
    }
}

DataTypeDescriptor
functionTableType() throws StandardException :
{
    List<String> names = new ArrayList<String>();
    List<DataTypeDescriptor> types = new ArrayList<DataTypeDescriptor>();
    String[] nameArray;
    DataTypeDescriptor[] typeArray;
    int columnCount;
}
{
    <TABLE>
    <LEFT_PAREN>
    functionTableReturnColumn( names, types )
    ( <COMMA> functionTableReturnColumn( names, types ) )*
    <RIGHT_PAREN>
    {
        columnCount = names.size();
        nameArray = new String[ columnCount ];
        names.toArray(nameArray);
        typeArray = new DataTypeDescriptor[columnCount];
        types.toArray(typeArray);
        return DataTypeDescriptor.getRowMultiSet(nameArray, typeArray);
    }
}

void
functionTableReturnColumn(List<String> names, List<DataTypeDescriptor> types) 
        throws StandardException :
{
    String name;
    DataTypeDescriptor typeDescriptor;
}
{
    name = identifier()
    typeDescriptor = dataTypeDDL()
    {
        names.add(name);
        types.add(typeDescriptor);
    }
}

/**
    CREATE TYPE
*/

StatementNode
udtDefinition(Boolean createOrReplace) throws StandardException :
{
    TableName udtName;
    String externalName;
}
{
    <TYPE> udtName = qualifiedName()
    <EXTERNAL> <NAME> externalName = string()
    <LANGUAGE> <JAVA>
    {
        return getCreateAliasNode(udtName,
                                  externalName,
                                  null,
                                  AliasInfo.Type.UDT,
                                  createOrReplace);
    }
}

StatementNode
viewDefinition(Token beginToken) throws StandardException :
{
    int checkOptionType;
    ResultColumnList resultColumns = null;
    ResultSetNode queryExpression;
    TableName tableName;
    Token checkTok = null;
    Token endToken;
    OrderByList orderCols = null;
    ValueNode[] offsetAndFetchFirst = new ValueNode[2];
    ExistenceCheck cond;
}
{
    <VIEW> cond = createCondition() tableName = qualifiedName() 
    [ <LEFT_PAREN> resultColumns = viewColumnList() <RIGHT_PAREN> ]
    <AS> queryExpression = queryExpression(null, NO_SET_OP)
    [ orderCols = orderByClause() ]
    ( offsetOrFetchFirstClause(offsetAndFetchFirst) )*
    {
        checkOptionType = CreateViewNode.NO_CHECK_OPTION;
        endToken = getToken(0);

        /* Parameters not allowed in create view */
        HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);
        queryExpression.accept(visitor);
        if (visitor.hasNode()) {
            throw new StandardException("Parameters not allowed in CREATE VIEW");
        }

        return (StatementNode)nodeFactory.getNode(NodeTypes.CREATE_VIEW_NODE,
                                                  tableName,
                                                  resultColumns,
                                                  queryExpression,
                                                  checkOptionType,
                                                  sliceSQLText(beginToken.beginOffset, endToken.endOffset, false),
                                                  orderCols,
                                                  offsetAndFetchFirst[0],
                                                  offsetAndFetchFirst[1],
                                                  cond,
                                                  parserContext);
    }
}

ResultColumnList
viewColumnList() throws StandardException :
{
    ResultColumnList resultColumns = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                           parserContext);
}
{
    // TODO: What is this comment about?
    /* RESOLVE: Passing null parameter for now just to keep Java happy */
    columnNameList(resultColumns)
    {
        return resultColumns;
    }
}

StatementNode
triggerDefinition() throws StandardException :
{
    Boolean isBefore;
    Boolean isRow = Boolean.FALSE;  // STATEMENT implicit by default
    TableName tableName;
    TableName triggerName;
    Token[] tokenHolder = new Token[1];
    Token beginToken;
    Token checkTok = null;
    Token endToken;
    int actionBegin;
    int actionEnd;
    int triggerEvent;
    QueryTreeNode actionNode;
    ResultColumnList triggerColumns = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                            parserContext);
    List<TriggerReferencingStruct> refClause = null;
}
{
    <TRIGGER> triggerName = qualifiedName()
    isBefore = beforeOrAfter()
    triggerEvent = triggerEvent(triggerColumns)
    <ON> tableName = qualifiedName()
    [ refClause = triggerReferencingClause() ]
    [ <FOR> <EACH> isRow = rowOrStatement() ]
    [ <MODE> <DB2SQL> ]
    actionNode = proceduralStatement(tokenHolder)
    {
        actionEnd = getToken(0).endOffset;
        actionBegin = tokenHolder[0].beginOffset;

        // No DML in action node for BEFORE triggers.
        if (isBefore.booleanValue() && (actionNode instanceof DMLModStatementNode)) {
            throw new StandardException("DML not allowed in BEFORE trigger");
        }

        // No params in trigger action.
        HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);
        actionNode.accept(visitor);
        if (visitor.hasNode()) {
            throw new StandardException("Parameters not allowed in trigger action");
        }

        return (StatementNode)nodeFactory.getNode(NodeTypes.CREATE_TRIGGER_NODE,
                                                  triggerName,
                                                  tableName,
                                                  triggerEvent,
                                                  triggerColumns,
                                                  isBefore,    
                                                  isRow,
                                                  Boolean.TRUE,                   // enabled
                                                  refClause,          // referencing clause
                                                  null,// when clause node
                                                  null,           // when clause text
                                                  0,
                                                  // when clause begin offset
                                                  actionNode,
                                                  sliceSQLText(actionBegin, actionEnd, false),
                                                  actionBegin,
                                                  parserContext);
    }
}

StatementNode
synonymDefinition(Boolean createOrReplace) throws StandardException :
{
    TableName synonymName;
    TableName targetName;
}
{
    <SYNONYM> synonymName = qualifiedName() 
    <FOR> targetName = qualifiedName()
    {
        return (StatementNode)nodeFactory.getCreateAliasNode(synonymName,
                                                             targetName,
                                                             null,
                                                             AliasInfo.Type.SYNONYM,
                                                             createOrReplace,
                                                             parserContext);
    }
}

Boolean
beforeOrAfter() :
{}
{
    <NO> <CASCADE> <BEFORE> 
    {
        return Boolean.TRUE;
    }
|       
    <AFTER>
    {
        return Boolean.FALSE;
    }
}

int
triggerEvent(ResultColumnList rcl) throws StandardException :
{}
{
    <INSERT> 
    {
        return CreateTriggerNode.TRIGGER_EVENT_INSERT;
    }
|       
    <DELETE>
    {
        return CreateTriggerNode.TRIGGER_EVENT_DELETE;
    }
|    
    <UPDATE> [ <OF> columnNameList(rcl) ]
    {
        return CreateTriggerNode.TRIGGER_EVENT_UPDATE;
    }
}

Boolean
rowOrStatement() :
{}
{
    <ROW> 
    {
        return Boolean.TRUE;
    }
|       
    <STATEMENT>
    {
        return Boolean.FALSE;
    }
}

List<TriggerReferencingStruct>
triggerReferencingClause() throws StandardException :
{
    List<TriggerReferencingStruct> list = new ArrayList<TriggerReferencingStruct>();
}
{
    <REFERENCING> triggerReferencingExpression(list)
    ( triggerReferencingExpression(list) )*
    {
        return list;
    }
}

void
triggerReferencingExpression(List<TriggerReferencingStruct> list) 
        throws StandardException :
{
    String identifier;
    boolean isNew = true;
    boolean isRow = true;
}
{
(
    <NEW> [ <ROW> | <TABLE> { isRow = false; } ]
|
    <OLD> {isNew = false;} [ <ROW> | <TABLE> { isRow = false;} ]
|
    <NEW_TABLE> { isRow = false;}
|
    <OLD_TABLE> { isNew = false; isRow = false;}
)
    <AS> identifier = identifier()
    {
        list.add(new TriggerReferencingStruct(isRow, isNew, identifier));
    }
}
 
ValueNode
defaultClause(long[] autoIncrementInfo, String columnName) throws StandardException :
{
    ValueNode value;
    Token beginToken;
}
{
    [ <WITH> ] 
    beginToken = <_DEFAULT> 
    value = defaultOption(beginToken, autoIncrementInfo, columnName)
    {
        return value;
    }
|
    value = generatedColumnOption(autoIncrementInfo)
    {
        return value;
    }
}

ValueNode
defaultNullOnlyClause() throws StandardException :
{}
{
    <_DEFAULT> <NULL>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                              parserContext);
    }
}

// TODO: Like it says:
// A specific class not such long[] should exists for autoIncrementInfo ...

ValueNode
generatedColumnOption(long[] autoIncrementInfo) throws StandardException :
{
    ValueNode value = null;
}
{
    {
    autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = 1;
    autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = 1;
    autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] = 1;
    autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.CREATE_AUTOINCREMENT;
    }
    <GENERATED>
    (
        value = generatedAlways( autoIncrementInfo )
        {
            return value;
        }
    |
        value = generatedByDefault( autoIncrementInfo )
        {
            return value;
        }
    )
}

ValueNode
generatedAlways(long[] autoIncrementInfo) throws StandardException :
{
    ValueNode value = null;
}
{
    <ALWAYS>
    (
        LOOKAHEAD( { getToken(1).kind == AS && getToken(2).kind == IDENTITY } )
        asIdentity( autoIncrementInfo )
        {
            return value;
        }
    |
        LOOKAHEAD( { getToken(1).kind == AS && getToken(2).kind == LEFT_PAREN } )
        value = generationClause()
        {
            return value;
        }
    )
}

ValueNode
generatedByDefault(long[] autoIncrementInfo) throws StandardException :
{
    ValueNode value = null;
}
{
    <BY> <_DEFAULT> asIdentity(autoIncrementInfo)
    { 
        value = (ValueNode)nodeFactory.getNode(NodeTypes.DEFAULT_NODE,
                                               parserContext) ;

        return value;
    }
}

void
asIdentity(long[] autoIncrementInfo) throws StandardException :
{}
{
    <AS> <IDENTITY> [<LEFT_PAREN> autoIncrementBeginEnd(autoIncrementInfo) <RIGHT_PAREN>]
}

ValueNode
generationClause() throws StandardException :
{
    ValueNode value = null;
    Token beginToken = null;
    Token endToken = null;
}
{
    <AS> beginToken = <LEFT_PAREN> 
    value = valueExpression() 
    endToken = <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.GENERATION_CLAUSE_NODE,
                                              value,
                                              sliceSQLText(beginToken.endOffset + 1, endToken.beginOffset - 1, true),
                                              parserContext);
    }
}

void 
autoIncrementBeginEnd(long[] autoIncrementInfo) throws StandardException :
{
    long autoIncrementInitial = 1;
    long autoIncrementIncrement = 1;
}
{
    <INCREMENT> <BY> autoIncrementIncrement = exactNumber()
    {
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.CREATE_AUTOINCREMENT;
        return;
    }
|
    <START> <WITH> autoIncrementInitial = exactNumber() 
    [ <COMMA> <INCREMENT> <BY> autoIncrementIncrement = exactNumber() ]
    {
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = autoIncrementInitial;
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.CREATE_AUTOINCREMENT;
        return;
    }
}

ValueNode
defaultOption(Token beginToken, long[] autoIncrementInfo, String columnName) 
        throws StandardException :
{
    Token endToken;
    Token errorTok = null;
    Token initialTok = null;
    ValueNode value;
}
{
    //Look ahead required to tell NULL from a class name which starts with
    // NULL (e.g., NULL::)
    LOOKAHEAD( { getToken(1).kind == NULL && 
                                 !(getToken(2).kind == PERIOD || getToken(2).kind == DOUBLE_COLON) } )
    <NULL>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                              parserContext);
    }
|
    value = DB2DefaultOption(columnName)
    {
        endToken = getToken(0);
        value.setBeginOffset(beginToken.beginOffset);
        value.setEndOffset(endToken.endOffset);
        value = (ValueNode)nodeFactory.getNode(NodeTypes.DEFAULT_NODE,
                                               value,
                                               sliceSQLText(beginToken.beginOffset + 7, endToken.endOffset, true),
                                               parserContext);
        return value;
    }
}

ValueNode
DB2DefaultOption(String columnName) throws StandardException :
{
    ValueNode value;
}
{
    // DB2 spec says default can only be one of the
    // following: <constant>, <datetime-special-register> (ex.
    // "current time"), CURRENT SCHEMA, USER, NULL, or
    // <cast-function>.  We currently support all of these
    // except the 'blob' function that is part of the DB2 valid
    // <cast-function> grammar.  See beetle 5281 for plans
    // support 'blob' function in future.

    LOOKAHEAD( { getToken(2).kind == SCHEMA || getToken(2).kind == SQLID } )
    <CURRENT> (<SCHEMA> | <SQLID>)
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CURRENT_SCHEMA_NODE,
                                              parserContext);
    }
|
    /* Revert DB2 restriction: DERBY-3013. Accept standard SQL CURRENT_USER,
     * SESSION_USER in addition to USER.
     */
    value = userNode()
    {
        return value;
    }
|
    value = currentRoleNode()
    {
        return value;
    }
|
    LOOKAHEAD( { getToken(1).kind == DATE || 
                             getToken(1).kind == TIME || 
                             getToken(1).kind == TIMESTAMP } )
    value = miscBuiltins()
    { // these functions are allowed as valid <cast-function> defaults.
        // Once "BLOB" is allowed as a cast-function (5281), a case should be
        // added for that, as well.
        return value;
    }
|
    LOOKAHEAD( { getToken(2).kind == LEFT_PAREN ||
                                 (getToken(4).kind == LEFT_PAREN && getToken(2).kind != COMMA) } )
        // Check against comma: see Derby-331 
        // Before adding this, the following was erroneously
        // flagged as invalid: 
        //       create table foo(.., b int default 0, unique (a))
    value = miscBuiltins()
    {
        // If we have a function (as indicated by an open paren,
        // which can be either the 2nd token (w/ normal function name)
        // or the 4th token (w/ qualified function name)), then
        // it's not valid.  Catch it here and throw an "invalid
        // default" error (42894) instead of letting it go as
        // a syntax error (this matches DB2 UDB behavior).
        throw new StandardException("Invalid default for " + columnName);
    }
|
    value = datetimeValueFunction()
    {
        return value;
    }
|
    // Only (valid) thing left is literals (i.e. actual constants).
    value = literal()
    {
        return value;
    }
}

ValueNode
literal() throws StandardException :
{
    String sign = "";
    Token tok;
    String datetimeString;
    String bitString;
    ValueNode constantNode;
}
{
    [ sign = sign() ] constantNode = numericLiteral(sign)
    {
        return constantNode;
    }
|
    constantNode = stringLiteral()
    {
        return  constantNode;
    }
|
    constantNode = hexLiteral()
    {
        return  constantNode;
    }
|
    constantNode = dateTimeLiteral()
    {
        return constantNode;
    }
|
    tok = booleanLiteral()
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.BOOLEAN_CONSTANT_NODE,
                                              "true".equalsIgnoreCase(tok.image) ? Boolean.TRUE : Boolean.FALSE,
                                              parserContext);
    }
|
    constantNode = intervalLiteral()
    {
        return constantNode;
    }
|
    constantNode = nullSpecification()
    {
        return constantNode;
    }
}

NumericConstantNode
intLiteral() throws StandardException :
{
    Token tok;
    String sign = null;
}
{
    [ sign = sign() ] tok = <EXACT_NUMERIC>
    {
        try {
            return getNumericNode(getNumericString(tok, sign), true);
        } 
        catch (NumberFormatException e) {
            throw new StandardException("Integer literal expected", e);
        }
    }
}

ValueNode
numericLiteral(String sign) throws StandardException :
{
    Token tok;
}
{
    tok = <EXACT_NUMERIC>
    {
        return getNumericNode(getNumericString(tok, sign), false);
    }
|
    tok = <APPROXIMATE_NUMERIC>
    {
        StringBuffer doubleImage;
        String doubleString;
        int ePosn, dotPosn; // Position of letter e and '.' in value
        Double      doubleValue;
        
        doubleImage = new StringBuffer(sign);
        doubleImage.append(tok.image);
        doubleString = doubleImage.toString();

        ePosn = doubleString.indexOf('E');
        if (ePosn == -1)
            ePosn = doubleString.indexOf('e');
        assert (ePosn != -1) : "no E or e in approximate numeric";

        // there is a limit on the length of a floatingpoint literal in DB2
        if (doubleString.length() > MAX_FLOATINGPOINT_LITERAL_LENGTH)
            throw new StandardException("Floating point literal too long");
        // if there is no '.' before the e, put one in
        dotPosn = doubleString.substring(0,ePosn).indexOf('.');
        if (dotPosn == -1) {
            doubleImage.insert(ePosn,'.');
            doubleString = doubleImage.toString();
            ePosn++;
        }

        try
        {
            doubleValue = Double.valueOf(doubleString);

        }
        catch (NumberFormatException nfe)
        {
            throw new StandardException("Invalid double", nfe);
        }

        double dv = doubleValue.doubleValue();

        // When the value is 0 it's possible rounded, try to detect it by checking if the mantissa is 0.0
        //   "proof of correctness": any nonzero value (mantissa) with less than 30 characters will not be
        //                                                   rounded to 0.0 by a float/real. This correctly detects the case when
        //                                                   the radix/exponent being "too small" (1e-900) giving a value rounded to zero.
        if ( (dv == 0.0d) && (Double.parseDouble(doubleString.substring(0, ePosn-1)) != 0.0d) )
        {
            throw new StandardException("Floating point exponent underflow");
        }

        if (Double.isNaN(dv) || Double.isInfinite(dv))
            throw new StandardException("Floating point exponent overflow");

        return (ValueNode)nodeFactory.getNode(NodeTypes.DOUBLE_CONSTANT_NODE,
                                              doubleValue,
                                              parserContext);
    }
}

ValueNode
dateTimeLiteral() throws StandardException :
{
    ValueNode constantNode;
    DataTypeDescriptor typeDescriptor;
}
{
// RESOLVE: There is an incompatibility between Derby and DB2 here. The DB2 SQL parser does not recognize
// JDBC date/time escapes. They are handled in a JDBC pre-processor. However embedded Derby does not have
// a separate pre-processor. JDBC date/time escapes are handled by the Derby SQL parser. This will only
// be visible if Derby is accessed through a non-JDBC pathway. (ODBC?) In that case Derby will allow
// the JDBC date/time escape while DB2 will not.
    ( <LEFT_BRACE> constantNode = escapedDateTimeLiteral() <RIGHT_BRACE> )
    {
        return constantNode;
    }
|
    // This LOOKAHEAD is needed because DATE, etc. are also function names that do
    // the same thing, but with an arbitrary expression.
    LOOKAHEAD( { isDATETIME(getToken(1).kind) && getToken(2).kind == SINGLEQUOTED_STRING } )
    typeDescriptor = datetimeType()
    constantNode = stringLiteral()
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.CAST_NODE,
                                              constantNode, typeDescriptor,
                                              parserContext);
    }
}

ValueNode
escapedDateTimeLiteral() throws StandardException :
{
    ValueNode constantNode;
}
{
    <D> constantNode = bareDateLiteral()
    {
        return constantNode;
    }
|
    <T> constantNode = bareTimeLiteral()
    {
        return constantNode;
    }
|
    <TS> constantNode = bareTimestampLiteral()
    {
        return constantNode;
    }
}

ValueNode
bareDateLiteral() throws StandardException :
{
    String dateString;
}
{
    dateString = string()
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.USERTYPE_CONSTANT_NODE,
                                              Date.valueOf(dateString),
                                              parserContext);
    }
}

ValueNode
bareTimeLiteral() throws StandardException :
{
    String timeString;
}
{
    timeString = string()
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.USERTYPE_CONSTANT_NODE,
                                              Time.valueOf(timeString),
                                              parserContext);
    }
}

ValueNode
bareTimestampLiteral() throws StandardException :
{
    String timestampString;
}
{
    timestampString = string()
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.USERTYPE_CONSTANT_NODE,
                                              Timestamp.valueOf(timestampString),
                                              parserContext);
    }
}

ValueNode
intervalLiteral() throws StandardException :
{
    ValueNode value;
    DataTypeDescriptor intervalType;
    int[] factors = new int[] { 1, 1 };
}
{
    <INTERVAL> value = valueExpression() 
    (
        intervalType = intervalQualifier()
    |
        LOOKAHEAD( { mysqlIntervalFollows() } )
        intervalType = mysqlIntervalQualifier(factors)
    )
    {
        value = (ValueNode)nodeFactory.getNode(NodeTypes.CAST_NODE,
                                               value, intervalType,    
                                               parserContext);
        if (factors[0] != 1)
            value = (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_TIMES_OPERATOR_NODE,
                                                   value,
                                                   nodeFactory.getNode(NodeTypes.INT_CONSTANT_NODE,
                                                                       Integer.valueOf(factors[0]),
                                                                       parserContext),
                                                   parserContext);
        if (factors[1] != 1)
            value = (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_DIVIDE_OPERATOR_NODE,
                                                   value,
                                                   nodeFactory.getNode(NodeTypes.INT_CONSTANT_NODE,
                                                                       Integer.valueOf(factors[1]),
                                                                       parserContext),
                                                   parserContext);
        return value;
    }
}

DataTypeDescriptor
mysqlIntervalQualifier(int[] factors) throws StandardException :
{
    TypeId typeId;
    int prec = 0, scale = 0;
}
{
(
    <MICROSECOND>
    {
        typeId = TypeId.INTERVAL_SECOND_ID;
        scale = 6;
        factors[1] = 1000000;
    }
|
    <WEEK>
    {
        typeId = TypeId.INTERVAL_DAY_ID;
        factors[0] = 7;
    }
|
    <QUARTER>
    {
        typeId = TypeId.INTERVAL_MONTH_ID;
        factors[0] = 3;
    }
|
    <SECOND_MICROSECOND>
    {
        typeId = TypeId.INTERVAL_SECOND_ID;
        scale = 6;
    }
|
    <MINUTE_MICROSECOND>
    {
        typeId = TypeId.INTERVAL_MINUTE_SECOND_ID;
        scale = 6;
    }
|
    <MINUTE_SECOND>
    {
        typeId = TypeId.INTERVAL_MINUTE_SECOND_ID;
    }
|
    <HOUR_MICROSECOND>
    {
        typeId = TypeId.INTERVAL_HOUR_SECOND_ID;
        scale = 6;
    }
|
    <HOUR_SECOND>
    {
        typeId = TypeId.INTERVAL_HOUR_SECOND_ID;
    }
|
    <HOUR_MINUTE>
    {
        typeId = TypeId.INTERVAL_HOUR_MINUTE_ID;
    }
|
    <DAY_MICROSECOND>
    {
        typeId = TypeId.INTERVAL_DAY_SECOND_ID;
        scale = 6;
    }
|
    <DAY_SECOND>
    {
        typeId = TypeId.INTERVAL_DAY_SECOND_ID;
    }
|
    <DAY_MINUTE>
    {
        typeId = TypeId.INTERVAL_DAY_MINUTE_ID;
    }
|
    <DAY_HOUR>
    {
        typeId = TypeId.INTERVAL_DAY_HOUR_ID;
    }
|
    <YEAR_MONTH>
    {
        typeId = TypeId.INTERVAL_YEAR_MONTH_ID;
    }
)
    {
        return new DataTypeDescriptor(typeId, prec, scale,
                                      true, DataTypeDescriptor.intervalMaxWidth(typeId, prec, scale));
    }
}

String
string() throws StandardException :
{
    Token tok;
}
{
    tok = <SINGLEQUOTED_STRING>
    {
        parserContext.checkStringLiteralLengthLimit(tok.image);
        /* Trim off the leading and trailing ', and compress all '' to ' */
        return trimAndCompressQuotes(tok.image, SINGLEQUOTES, false);
    }
|
    tok = <DOUBLEQUOTED_STRING>
    {
        parserContext.checkStringLiteralLengthLimit(tok.image);
        /* Trim off the leading and trailing ', and compress all '' to ' */
        return trimAndCompressQuotes(tok.image, DOUBLEQUOTES, true);
    }
|
    tok = <DOUBLEDOLLAR_STRING>
    {
        parserContext.checkStringLiteralLengthLimit(tok.image);
        /* Trim off the leading and trailing $$ */
        return tok.image.substring(2, tok.image.length()-2);
    }
}

CharConstantNode
stringLiteral() throws StandardException :
{
    String st;
}
{
    st = getStringLiteral()
    {
        return (CharConstantNode)nodeFactory.getNode(NodeTypes.CHAR_CONSTANT_NODE,
                                                    st,
                                                    parserContext);
    }                                            
                                                
}

String
getStringLiteral() throws StandardException :
{
    Token tok;
    String string;
}
{
(
    tok = <SINGLEQUOTED_STRING>
    {
        parserContext.checkStringLiteralLengthLimit(tok.image);
        string = trimAndCompressQuotes(tok.image, SINGLEQUOTES, false);
    }
|
    tok = <DOUBLEQUOTED_STRING>
    {
        parserContext.checkStringLiteralLengthLimit(tok.image);
        string = trimAndCompressQuotes(tok.image, DOUBLEQUOTES, true);
    }
)
    {
        return string;
    }
}

String
collateClause() throws StandardException :
{
    TableName collation;
}
{
    <COLLATE> collation = qualifiedName()
    {
        return collation.toString();
    }
}

ValueNode
hexLiteral() throws StandardException :
{
    Token tok;
}
{
    tok = <HEX_STRING>
    {
        String hexLiteral = tok.image;

        //there is a maximum limit on the length of the hex constant
        if (hexLiteral.length()-3 > 65535*2)
            throw new StandardException("Hex literal too long");
        if ((hexLiteral.length()-3)%2 == 1)
            throw new StandardException("Hex literal invalid");

        int bitLength = ((hexLiteral.length() - 3) / 2);
        return (ValueNode)
                nodeFactory.getNode(NodeTypes.VARBIT_CONSTANT_NODE,
                                    hexLiteral.substring(2, hexLiteral.length() - 1), bitLength,
                                    parserContext);
    }
}

TableName
constraintNameDefinition() throws StandardException :
{
    TableName constraintName;
}
{
    /* changed constraintName() to qualifiedName() for compaction */
    <CONSTRAINT> constraintName = qualifiedName()
    {
        return constraintName;
    }
}

/*
 * DB2 requires column check constraints to refer to only that column. Derby
 * doesn't care if check constraints are column level or table level. For DB2 compatibility
 * check that column check constraints only refer to that column.
 */
ConstraintDefinitionNode
checkConstraintDefinition(TableName constraintName, String columnName)
        throws StandardException :
{    
    Token beginToken, endToken;
    ValueNode value;
    ResultColumnList rclList = null;
}
{
    <CHECK> beginToken = <LEFT_PAREN> 
    value = valueExpression() 
    endToken = <RIGHT_PAREN>
    {
        if (columnName != null) {
            /* Column check constraint */
            rclList = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                            parserContext);
            rclList.addResultColumn((ResultColumn)nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                                                      columnName,
                                                                      null,
                                                                      parserContext));
        }

        value.setBeginOffset(beginToken.beginOffset);
        value.setEndOffset(endToken.endOffset);
        return (ConstraintDefinitionNode)nodeFactory.getNode(NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                             constraintName,
                                                             ConstraintDefinitionNode.ConstraintType.CHECK,
                                                             rclList,
                                                             null,
                                                             value,
                                                             sliceSQLText(beginToken.beginOffset, endToken.endOffset, true),
                                                             parserContext);
    }
}

// Index names are like column names: unqualified searches tables for
// match with possible ambiguous exception.
String
indexName(TableName[] retTableName) throws StandardException :
{
    String firstName;
    String secondName = null;
    String thirdName = null;
}
{
    firstName = identifierDeferCheckLength()
    [
        <PERIOD> secondName = identifierDeferCheckLength()
        [
            <PERIOD> thirdName = identifierDeferCheckLength()
        ]
    ]
    {
        String schemaName = null;
        String tableName = null;
        String indexName = null;

        if (thirdName != null) {
            // Three names: schema.table.index
            schemaName = firstName;
            tableName = secondName;
            indexName = thirdName;
        }
        else if (secondName != null) {
            // Two names: table.index
            tableName = firstName;
            indexName = secondName;
        }
        else {
            // Only one name, index.
            indexName = firstName;
        }

        if (tableName != null) {
            if (schemaName != null)
                parserContext.checkIdentifierLengthLimit(schemaName);
            parserContext.checkIdentifierLengthLimit(tableName);
            retTableName[0] = (TableName)nodeFactory.getNode(NodeTypes.TABLE_NAME,
                                                             schemaName,
                                                             tableName,
                                                             new Integer(nextToLastIdentifierToken.beginOffset),
                                                             new Integer(nextToLastIdentifierToken.endOffset),
                                                             parserContext);
        }

        parserContext.checkIdentifierLengthLimit(indexName);
        return indexName;
    }
}

StatementNode
spsRenameStatement() throws StandardException :
{
    StatementNode qtn;
}
{
    <RENAME> 
    (
        qtn = renameTableStatement() 
    |
        qtn = renameIndexStatement() 
    |
        qtn = renameColumnStatement()
    )
    {
        return qtn;
    }
}

StatementNode
renameTableStatement() throws StandardException :
{
    TableName tableName, newTableName;
}
{
    <TABLE> tableName = qualifiedName() 
    <TO> newTableName = qualifiedName()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.RENAME_NODE,
                                                  tableName,
                                                  null,
                                                  newTableName,
                                                  Boolean.FALSE,
                                                  RenameNode.RenameType.TABLE,
                                                  parserContext);
    }
}

StatementNode
renameIndexStatement() throws StandardException :
{ 
    String indexName, newIndexName;
    TableName tableName[] = new TableName[1];
}
{
    <INDEX> indexName = indexName(tableName) 
    <TO> newIndexName = identifier()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.RENAME_NODE,
                                                  tableName[0],
                                                  indexName,
                                                  newIndexName,
                                                  Boolean.FALSE,
                                                  RenameNode.RenameType.INDEX,
                                                  parserContext);
    }
}

StatementNode
renameColumnStatement() throws StandardException :
{
    String newColumnName;
    ColumnReference oldColumnReference;
    TableElementList tableElementList;
    TableName tableName;
}
{
    <COLUMN> oldColumnReference = columnReference()
    <TO> newColumnName = identifier()
    {
        if ((tableName = oldColumnReference.getTableNameNode()) == null)
            throw new StandardException("Table name missing in RENAME COLUMN");

        tableElementList = (TableElementList)nodeFactory
                    .getNode(NodeTypes.TABLE_ELEMENT_LIST, parserContext);

        tableElementList.addTableElement((TableElementNode)nodeFactory
                    .getNode(NodeTypes.AT_RENAME_COLUMN_NODE,
                             oldColumnReference.getColumnName(),
                             newColumnName,
                             parserContext));

        return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_TABLE_NODE,
                                                  tableName,
                                                  tableElementList,
                                                  new Character('\0'),
                                                  new int[] {DDLStatementNode.MODIFY_TYPE},
                                                  new int[] {0},
                                                  parserContext);  
    }
}

StatementNode
lockStatement() throws StandardException :
{
    Boolean exclusiveMode;
    TableName tableName;
}
{
    <LOCK> <TABLE> tableName = qualifiedName() 
        <IN> exclusiveMode = lockMode() <MODE>
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.LOCK_TABLE_NODE,
                                                  tableName,
                                                  exclusiveMode,
                                                  parserContext);
    }
}

Boolean
lockMode() :
{}
{
    <EXCLUSIVE>
    {
        return Boolean.TRUE;
    }
|
    <SHARE>
    {
        return Boolean.FALSE;
    }
}

TransactionStatementNode
setIsolationStatement() throws StandardException :
{
    TransactionStatementNode tranNode;
}
{
    setIsolationHeader()
    [ ( <EQUALS_OPERATOR> | <TO> ) ] tranNode = transactionMode()
    {
        return tranNode;
    }
}

void
setIsolationHeader() throws StandardException :
{}
{
    <ISOLATION>
|
    LOOKAHEAD( { getToken(1).kind == CURRENT && getToken(2).kind == ISOLATION } )
    <CURRENT> <ISOLATION>
}

TransactionStatementNode
transactionMode() throws StandardException :
{
    IsolationLevel isolationLevel;
}
{
    isolationLevel = isolationLevelDB2OrReset() 
    {
        return (TransactionStatementNode)nodeFactory.getNode(NodeTypes.SET_TRANSACTION_ISOLATION_NODE,
                                                             Boolean.FALSE,
                                                             isolationLevel,
                                                             parserContext);
    }
}

IsolationLevel
isolationLevelDB2OrReset() :
{
    IsolationLevel isolationLevel;
}
{
(
    <RESET> 
    {
        return IsolationLevel.UNSPECIFIED_ISOLATION_LEVEL; 
    }
| 
    isolationLevel = isolationLevelDB2() 
    {
        return isolationLevel; 
    }
)
}

IsolationLevel
isolationLevelDB2() :
{
    IsolationLevel isolationLevel;
}
{
(
    isolationLevel = isolationLevelDB2Abbrev()
    { 
        return isolationLevel; 
    }
|
    ( ( <REPEATABLE> <READ> ) | <SERIALIZABLE> )
    {
        return IsolationLevel.SERIALIZABLE_ISOLATION_LEVEL; 
    }
| 
    <CURSOR> <STABILITY>
    { 
        return IsolationLevel.READ_COMMITTED_ISOLATION_LEVEL; 
    }
| 
    <DIRTY> <READ>
    {
        return IsolationLevel.READ_UNCOMMITTED_ISOLATION_LEVEL; 
    }
|
    LOOKAHEAD( { getToken(1).kind == READ && getToken(2).kind == COMMITTED } )
    <READ> <COMMITTED>
    {
        return IsolationLevel.READ_COMMITTED_ISOLATION_LEVEL; 
    }
|
    LOOKAHEAD( { getToken(1).kind == READ && getToken(2).kind == UNCOMMITTED } )
    <READ> <UNCOMMITTED>
    { 
        return IsolationLevel.READ_UNCOMMITTED_ISOLATION_LEVEL; 
    }
)
}

IsolationLevel
isolationLevelDB2Abbrev() :
{}
{
(
    <RR>
    { 
        return IsolationLevel.SERIALIZABLE_ISOLATION_LEVEL; 
    }
|
    <RS> 
    { 
        return IsolationLevel.REPEATABLE_READ_ISOLATION_LEVEL; 
    }
|
    <CS>
    { 
        return IsolationLevel.READ_COMMITTED_ISOLATION_LEVEL; 
    }
|
    <UR>
    { 
        return IsolationLevel.READ_UNCOMMITTED_ISOLATION_LEVEL; 
    }
)
}

IsolationLevel
isolationLevel() :
{
    IsolationLevel isolationLevel;
}
{
    <ISOLATION> <LEVEL> isolationLevel = levelOfIsolation()
    {
        return isolationLevel;
    }
}

IsolationLevel
levelOfIsolation() :
{}
{
    <READ>
    {
        return levelOfIsolationRead();
    }
| 
    <REPEATABLE> <READ>
    {
        return IsolationLevel.REPEATABLE_READ_ISOLATION_LEVEL;
    }
|
    <SERIALIZABLE>
    {
        return IsolationLevel.SERIALIZABLE_ISOLATION_LEVEL;
    }
}

IsolationLevel
levelOfIsolationRead() :
{}
{
    <UNCOMMITTED> 
    {
        return IsolationLevel.READ_UNCOMMITTED_ISOLATION_LEVEL;
    }
|
    <COMMITTED> 
    {
        return IsolationLevel.READ_COMMITTED_ISOLATION_LEVEL;
    }
}

ValueNode
simpleValueSpecification() throws StandardException :
{
    ValueNode value;
}
{
    value = literal()
    {
        return value;
    }
}

StatementNode
setRoleStatement() throws StandardException :
{
    StatementNode role;
}
{
    <ROLE> role = setRoleSpecification()
    {
        if (parameterList != null && parameterList.size() > 0) {
            // Can also be prepared with ? argument, cf. SET SCHEMA.
            // set the type of parameter node, it should be a varchar
            // max Limits.MAX_IDENTIFIER_LENGTH - non nullable
            ParameterNode p = parameterList.get(0);
            p.setType(new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), false,
                                             128));
        }
        return role;
    }
}

StatementNode
setRoleSpecification() throws StandardException :
{
    String roleName = null;
}
{
    <NONE>
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.SET_ROLE_NODE,
                                                  roleName,
                                                  null,
                                                  parserContext);
    }
|
    roleName = identifier()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.SET_ROLE_NODE,
                                                  roleName,
                                                  null,
                                                  parserContext);
    }
|
    dynamicParameterSpecification()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.SET_ROLE_NODE,
                                                  null,
                                                  StatementType.SET_ROLE_DYNAMIC,
                                                  parserContext);
    }
|
    roleName = string()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.SET_ROLE_NODE,
                                                  roleName,
                                                  null,
                                                  parserContext);
    }
}

StatementNode
setSchemaStatement() throws StandardException :
{
    StatementNode setSchema;
}
{
    setSchemaHeader() [ <EQUALS_OPERATOR> ] setSchema = setSchemaValues()
    {
        if (parameterList != null && parameterList.size() > 0) {
            // Set the type of parameter node, it should be a VARCHAR.
            ParameterNode p = parameterList.get(0);
            p.setType(new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), false,
                                             128));
        }
        return setSchema;
    }
}

void 
setSchemaHeader() throws StandardException :
{}
{
    <SCHEMA>
|
    LOOKAHEAD( { getToken(1).kind == CURRENT && 
                                 (getToken(2).kind == SCHEMA || getToken(2).kind == SQLID ) } )
    <CURRENT> ( <SCHEMA>    | <SQLID> )
}

StatementNode
setSchemaValues() throws StandardException :
{
    String schemaName;
}
{
    schemaName = identifier()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.SET_SCHEMA_NODE,
                                                  schemaName,
                                                  null,
                                                  parserContext);
    }
|
    <USER>
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.SET_SCHEMA_NODE,
                                                  null,
                                                  StatementType.SET_SCHEMA_USER,
                                                  parserContext);
    }
|
    dynamicParameterSpecification()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.SET_SCHEMA_NODE,
                                                  null,
                                                  StatementType.SET_SCHEMA_DYNAMIC,
                                                  parserContext);
    }
|    
    schemaName = string()
    {
        parserContext.checkIdentifierLengthLimit(schemaName);
        return (StatementNode)nodeFactory.getNode(NodeTypes.SET_SCHEMA_NODE,
                                                  schemaName,
                                                  null,
                                                  parserContext);
    }
}

// Set the locale for messages coming from the database system. This
// is for support only, so we can get messages in our preferred language
// (usually English). I didn't want to create all the execution wiring
// to do this, so this command executes in the parser
StatementNode
setMessageLocaleStatement() throws StandardException :
{
    String messageLocale;
}
{
    <MESSAGE_LOCALE> messageLocale = string()
    {
        parserContext.setMessageLocale(messageLocale);

        return (StatementNode)nodeFactory.getNode(NodeTypes.NOP_STATEMENT_NODE,
                                                  parserContext);
    }
}

StatementNode
setTransactionStatement() throws StandardException :
{
    Boolean current;
    StatementNode transactionStatement;
}
{
(
    <TRANSACTION> { current = Boolean.TRUE; }
|
    <SESSION> <CHARACTERISTICS> <AS> <TRANSACTION> { current = Boolean.FALSE; }
)
    transactionStatement = transactionStatement(current)
    {
        return transactionStatement;
    }
}

StatementNode
transactionStatement(Boolean current) throws StandardException :
{
    IsolationLevel isolationLevel;
    AccessMode accessMode;
}
{
    isolationLevel = isolationLevel()
    {
        return (TransactionStatementNode)nodeFactory.getNode(NodeTypes.SET_TRANSACTION_ISOLATION_NODE,
                                                             current,
                                                             isolationLevel,
                                                             parserContext);
    }
|
    accessMode = transactionAccessMode()
    {
        return (TransactionStatementNode)nodeFactory.getNode(NodeTypes.SET_TRANSACTION_ACCESS_NODE,
                                                             current,
                                                             accessMode,
                                                             parserContext);
    }
}

AccessMode
transactionAccessMode() throws StandardException :
{}
{
    <READ>
(
    <ONLY>
    {
        return AccessMode.READ_ONLY_ACCESS_MODE;
    }
|
    <WRITE>
    {
        return AccessMode.READ_WRITE_ACCESS_MODE;
    }
)
}

StatementNode
setConfigurationStatement() throws StandardException :
{
    Token variable;
    CharConstantNode value = null;
}
{
    variable = <IDENTIFIER>
    ( <EQUALS_OPERATOR> | <TO> )
    ( value = stringLiteral() | <_DEFAULT> )
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.SET_CONFIGURATION_NODE,
                                                  variable.image, 
                                                  (value == null) ? null : value.getValue(),
                                                  parserContext);
    }
}

ValueNode
valueSpecification() throws StandardException :
{
    ValueNode value;
    ValueNode leftExpression;
    ValueNode rightExpression;
}
{
    value = literal()
    {
        return value;
    }
|
    value = generalValueSpecification()
    {
        return value;
    }
|
    <NULLIF> <LEFT_PAREN> leftExpression = additiveExpression() 
    <COMMA> rightExpression = additiveExpression() <RIGHT_PAREN>
    {
        // "NULLIF(L, R)" is the same as "L=R ? untyped NULL : L"
        // An impl assumption here is that Derby can promote CHAR to any comparable datatypes such as numeric
        ValueNodeList thenElseList = (ValueNodeList)nodeFactory.getNode(NodeTypes.VALUE_NODE_LIST, parserContext);

        //Use untyped null for then clause at this point. At the bind time, we will cast it to the datatype of L 
        thenElseList.addValueNode((ValueNode)nodeFactory.getNode(NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                                                 parserContext));
        thenElseList.addValueNode(leftExpression);

        return (ValueNode)nodeFactory.getNode(NodeTypes.CONDITIONAL_NODE,
                                              (ValueNode)nodeFactory.getNode(NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
                                                                             leftExpression,
                                                                             rightExpression,
                                                                             parserContext),
                                              thenElseList,
                                              Boolean.TRUE,//this node is for nullif 
                                              parserContext);
    }
|
    <CASE> value = caseExpression()
    {
        return value;
    }
}

ValueNode
caseExpression() throws StandardException :
{
    ValueNode expr;
}
{
    LOOKAHEAD ( { getToken(1).kind == WHEN } )
    expr = whenThenExpression()
    {
        return expr;
    }
|
    expr = simpleCaseExpression()
    {
        return expr;
    }
}

ValueNode
whenThenExpression() throws StandardException :
{
    ValueNode expr;
    ValueNode thenExpr;
    ValueNode elseExpr;
}
{
    <WHEN> expr = orExpression(null) 
        ( <OR> expr = orExpression(expr) )*
        <THEN> thenExpr = thenElseExpression()
    elseExpr = caseElseExpression()
    {
        ValueNodeList thenElseList = (ValueNodeList)nodeFactory.getNode(NodeTypes.VALUE_NODE_LIST, parserContext);
        thenElseList.addValueNode(thenExpr); // then
        thenElseList.addValueNode(elseExpr); // else

        return((ValueNode)nodeFactory.getNode(NodeTypes.CONDITIONAL_NODE,
                                              expr,
                                              thenElseList,
                                              Boolean.FALSE,
                                              parserContext));
    }
}

ValueNode
thenElseExpression() throws StandardException :
{
    ValueNode expr;
}
{    
    LOOKAHEAD ( { getToken(1).kind == NULL } )
    <NULL>
    {
        ValueNode value = (ValueNode)nodeFactory.getNode(NodeTypes.CAST_NODE,
                                                         (ValueNode)nodeFactory.getNode(NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                                                                        parserContext),
                                                         DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 1),    
                                                         parserContext);
        ((CastNode)value).setForExternallyGeneratedCASTnode();
        return value;
    }
|
    expr = additiveExpression()
    {
        return expr;
    }
}

ValueNode
caseElseExpression() throws StandardException :
{
    ValueNode expr;
}
{
    <END>
    {
        ValueNode value = (ValueNode)nodeFactory.getNode(NodeTypes.CAST_NODE,
                                                         (ValueNode)nodeFactory.getNode(NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
                                                                                        parserContext),
                                                         DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 1),    
                                                         parserContext);
        ((CastNode)value).setForExternallyGeneratedCASTnode();
        return value;
    }
|
    <ELSE> expr = thenElseExpression() <END>
    {
        return expr;
    }
|
    expr = whenThenExpression()
    {
        return expr;
    }
}

ValueNode
simpleCaseExpression() throws StandardException :
{
    ValueNode operand;
    SimpleCaseNode caseExpr;
}
{
    operand = additiveExpression()
    {
        caseExpr = (SimpleCaseNode)nodeFactory.getNode(NodeTypes.SIMPLE_CASE_NODE,
                                                       operand, 
                                                       parserContext);
    }
    simpleCaseWhenThenExpression(caseExpr)
    {
        return caseExpr;
    }
}

void
simpleCaseWhenThenExpression(SimpleCaseNode caseExpr) throws StandardException :
{
    ValueNode expr;
    ValueNode thenExpr;
    ValueNode elseExpr;
}
{
    <WHEN> expr = additiveExpression()
    <THEN> thenExpr = thenElseExpression()
    {
        caseExpr.addCase(expr, thenExpr);
    }
    simpleCaseElseExpression(caseExpr)
}

void
simpleCaseElseExpression(SimpleCaseNode caseExpr) throws StandardException :
{
    ValueNode expr;
}
{
    <END>
|
    <ELSE> expr = thenElseExpression() <END>
    {
        caseExpr.setElseValue(expr);
    }
|
    simpleCaseWhenThenExpression(caseExpr)
}

void
tableConstraintDefinition(TableElementList tableElementList) throws StandardException :
{
    Properties properties = null;
    ConstraintDefinitionNode tcdn;
    TableName constraintName = null;
}
{
    [ constraintName = constraintNameDefinition() ] 
    tcdn = tableConstraint(constraintName) 
    [ properties = propertyList(false) <CHECK_PROPERTIES>]
    {
        if (properties != null) {
            tcdn.setProperties(properties);
        }

        tableElementList.addTableElement((TableElementNode)tcdn);
    }
}

ConstraintDefinitionNode
tableConstraint(TableName constraintName) throws StandardException :
{
    ConstraintDefinitionNode tcdn;
}
{
    tcdn = indexConstraintDefinition(constraintName)
    {
        return tcdn;
    }
|
    tcdn = uniqueConstraintDefinition(constraintName) 
    {
        return tcdn;
    }
|
    tcdn = referentialConstraintDefinition(constraintName) 
    {
        return tcdn;
    }
|
    tcdn = checkConstraintDefinition(constraintName, null)
    {
        return tcdn;
    }
}

ConstraintDefinitionNode
indexConstraintDefinition(TableName constraintName) throws StandardException : 
{
    boolean groupFormat = hasFeature(SQLParserFeature.GROUPING);

    String indexName = null;
    IndexColumnList indexColumnList = null;
    JoinNode.JoinType joinType = null;
    StorageLocation location = null;
}
{
    <INDEX> [indexName = identifier()]
    <LEFT_PAREN>
    ( 
      LOOKAHEAD ( { groupFormat } )
      groupIndexItemList(indexColumnList = (IndexColumnList)nodeFactory.getNode(NodeTypes.INDEX_COLUMN_LIST, parserContext))
    |
      LOOKAHEAD ( { !groupFormat } )
      indexItemList(indexColumnList = (IndexColumnList)nodeFactory.getNode(NodeTypes.INDEX_COLUMN_LIST, parserContext))
    )
    <RIGHT_PAREN>
    [ LOOKAHEAD ( { groupFormat && getToken(1).kind == USING } )
      <USING> joinType = joinType() <JOIN> ]
    [ <AS> location = getLocation() ]
    {
        return (ConstraintDefinitionNode)nodeFactory.getNode(NodeTypes.INDEX_CONSTRAINT_NODE,
                                                             constraintName,
                                                             indexColumnList,
                                                             indexName,
                                                             joinType,
                                                             location,
                                                             parserContext);
    }
    
}


ConstraintDefinitionNode
uniqueConstraintDefinition(TableName constraintName) throws StandardException :
{
    ConstraintDefinitionNode.ConstraintType constraintType;
    ResultColumnList uniqueColumnList;
}
{
    //for table level constraint, parameter will be null
    constraintType = uniqueSpecification(null) 
    <LEFT_PAREN> uniqueColumnList = uniqueColumnList() <RIGHT_PAREN>
    {
        return (ConstraintDefinitionNode)nodeFactory.getNode(NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                             constraintName,
                                                             constraintType,
                                                             uniqueColumnList,
                                                             null,
                                                             null,
                                                             null,
                                                             parserContext);
    }
}

//the second parameter to the following method will always be null for a table level
//constraint but not for a column level constraint
ConstraintDefinitionNode.ConstraintType
uniqueSpecification(String columnName) throws StandardException :
{}
{
    <UNIQUE> 
    {
        return ConstraintDefinitionNode.ConstraintType.UNIQUE;
    }
|
    <PRIMARY> <KEY>
    {
        return ConstraintDefinitionNode.ConstraintType.PRIMARY_KEY;
    }
}

ResultColumnList
uniqueColumnList() throws StandardException :
{
    ResultColumnList resultColumns = (ResultColumnList)
        nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                            parserContext);
}
{
    columnNameList(resultColumns)
    {
        return resultColumns;
    }
}

ConstraintDefinitionNode
referentialConstraintDefinition(TableName constraintName) throws StandardException :
{
    ResultColumnList fkRcl = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                   parserContext);
    ResultColumnList refRcl = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                    parserContext);
    TableName referencedTable;
    int[] refActions = { StatementType.RA_NOACTION,
                         StatementType.RA_NOACTION }; //default values
    Token grouping = null;
}
{
    // NB: GROUPING case must be kept in sync with alterGroup()
    [ LOOKAHEAD ( { groupConstructFollows(GROUPING) } )
      grouping = <GROUPING> ]
    <FOREIGN> <KEY> <LEFT_PAREN> columnNameList(fkRcl) <RIGHT_PAREN>
    referencedTable = referencesSpecification(refRcl, refActions)
    {
        return (ConstraintDefinitionNode)nodeFactory.getNode(NodeTypes.FK_CONSTRAINT_DEFINITION_NODE,
                                                             constraintName,
                                                             referencedTable,
                                                             fkRcl,
                                                             refRcl,
                                                             refActions,
                                                             (grouping == null) ? Boolean.FALSE : Boolean.TRUE,
                                                             parserContext);
    }
}

TableName
referencesSpecification(ResultColumnList rcl, int[] refActions) 
        throws StandardException :
{
    TableName tableName = null;
}
{
    <REFERENCES> tableName = referencedTableAndColumns(rcl)
        // not supporting MATCH or referential actions beyond syntax for default
        [ <ON> referentialTriggeredAction(refActions) ]
    {
        return tableName;
    }
}

TableName
referencedTableAndColumns(ResultColumnList rcl) throws StandardException :
{
    TableName    tableName = null;
}
{
    tableName = qualifiedName() [ <LEFT_PAREN> columnNameList(rcl) <RIGHT_PAREN> ]
    {
        return tableName;
    }
}

void
referentialTriggeredAction(int [] refActions) throws StandardException :
{}
{
( 
    refActions[1] = updateActions() [ <ON> refActions[0] = deleteActions() ] 
|
    refActions[0] = deleteActions() [ <ON> refActions[1] = updateActions() ] 
)
}

int
updateActions() :
{
    int action;
}
{
    <UPDATE> action = updateReferentialAction()
    {
        return action;
    }
}

int
deleteActions()  :
{
    int action;
}
{
    <DELETE> action = deleteReferentialAction()
    {
        return action;
    }
}

int
updateReferentialAction() :
{}
{
    <RESTRICT> 
    {
        return StatementType.RA_RESTRICT;
    }
| 
    <NO> <ACTION> 
    {
        return StatementType.RA_NOACTION;
    }
}

int
deleteReferentialAction() :
{}
{
    <CASCADE> 
    {
        return StatementType.RA_CASCADE;
    }
| 
    <RESTRICT> 
     {
         return StatementType.RA_RESTRICT;
     } 
| 
    <NO> <ACTION>
    {
        return StatementType.RA_NOACTION;
    }
| 
    <SET> 
    (
        <NULL> 
    {
        return StatementType.RA_SETNULL;
    }
    |
        <_DEFAULT>
    {
        return StatementType.RA_SETDEFAULT;
    }
    )
}

void
columnConstraintDefinition(DataTypeDescriptor[] dataTypeDescriptor,
                           TableElementList tableElementList,
                           String columnName) throws StandardException :
{
    int constraintType;
    TableElementNode tcdn;
    TableName constraintName = null;
}
{
    [ constraintName = constraintNameDefinition() ]
        tcdn = columnConstraint(constraintName, dataTypeDescriptor, columnName)
    {
        /* NOT NULL constraints are handled by marking the dataTypeDescriptor
         * as being non-nullable.
         */
        if (tcdn == null) {
            return;
        }

        /* All other constraints, whether column or table will be added as
         * table constraints.    We do this to facilitate the handling of
         * multiple column constraints on the same column.
         */
        tableElementList.addTableElement(tcdn);
    }
}

ConstraintDefinitionNode
columnConstraint(TableName constraintName,
                 DataTypeDescriptor[] dataTypeDescriptor,
                 String columnName) throws StandardException :
{
    Token notNull = null;
    ConstraintDefinitionNode.ConstraintType constraintType;
    Properties properties = null;
    ConstraintDefinitionNode tcdn;
    ResultColumnList refRcl = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                    parserContext);
    TableName referencedTable;
    int[] refActions = {StatementType.RA_NOACTION,
                        StatementType.RA_NOACTION} ; //default: NO ACTION
    Token grouping = null;
}
{
    [ notNull = <NOT> ] <NULL>
    {
        if ( dataTypeDescriptor[0] == null ) { 
            throw new StandardException("[NOT] NULL requires a data type");
        }
        dataTypeDescriptor[0] = dataTypeDescriptor[0].getNullabilityType(notNull == null);
        return null;
    }
|
    //pass the columnname as the second parameter. It will be used to throw an
    //exception if null constraint is defined for this column-level primary 
    //key constraint
    constraintType = uniqueSpecification(columnName)
    [ properties = propertyList(false) <CHECK_PROPERTIES>]
    {
        ResultColumnList uniqueColumnList = (ResultColumnList)
            nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                parserContext);
        uniqueColumnList.addResultColumn((ResultColumn)
                                         nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                                             columnName,
                                                             null,
                                                             parserContext));

        return (ConstraintDefinitionNode)nodeFactory.getNode(NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                             constraintName,
                                                             constraintType,
                                                             uniqueColumnList,
                                                             properties,
                                                             null,
                                                             null,
                                                             parserContext);
    }
|    
    [ LOOKAHEAD ( { groupConstructFollows(GROUPING) } )
      grouping = <GROUPING> ]
    referencedTable = referencesSpecification(refRcl, refActions)
    [ properties = propertyList(false)<CHECK_PROPERTIES>] 
    {
        ResultColumnList fkRcl = (ResultColumnList)
            nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                parserContext);
        fkRcl.addResultColumn((ResultColumn)nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                                                columnName,
                                                                null,
                                                                parserContext));
        tcdn = (ConstraintDefinitionNode)nodeFactory.getNode(NodeTypes.FK_CONSTRAINT_DEFINITION_NODE,
                                                             constraintName,
                                                             referencedTable,
                                                             fkRcl,
                                                             refRcl,
                                                             refActions,
                                                             (grouping == null) ? Boolean.FALSE : Boolean.TRUE,
                                                             parserContext);
        if (properties != null) {
            tcdn.setProperties(properties);
        }
        return tcdn;
    }
|
    tcdn = checkConstraintDefinition(constraintName, columnName)
    {
        return tcdn;
    }
}

StatementNode
dropRoleStatement() throws StandardException :
{
    String roleName;
}
{
    <ROLE> roleName = identifier()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.DROP_ROLE_NODE,
                                                  roleName,
                                                  parserContext);
    }
}

StatementNode
dropSchemaStatement() throws StandardException :
{
    String schemaName;
    int[] behavior = new int[1];
    ExistenceCheck cond;
}
{
    <SCHEMA> cond = dropCondition() schemaName = identifier() dropBehavior(behavior)
    {
        StatementNode stmt = (StatementNode)nodeFactory.getNode(NodeTypes.DROP_SCHEMA_NODE,
                                                                schemaName,
                                                                new Integer(behavior[0]),
                                                                cond,
                                                                parserContext);

        return stmt;
    }
}

StatementNode
alterGroup() throws StandardException :
{
    TableName childTable;
    TableName parentTable;
    ResultColumnList childColumns;
    ResultColumnList parentColumns = null;
    TableElementList tableElementList = (TableElementList)
        nodeFactory.getNode(NodeTypes.TABLE_ELEMENT_LIST, parserContext);

}
{
    <ADD> <TABLE> childTable = qualifiedName()
    <LEFT_PAREN> childColumns = tableColumnList() <RIGHT_PAREN>
    <TO> parentTable = qualifiedName()
    [<LEFT_PAREN> parentColumns = tableColumnList() <RIGHT_PAREN>]
    {
        // NB: Must be kept in sync with referentialConstraintDefinition()
        // Equivalent to this statement:
        // ALTER TABLE <child schema table name>
        //      ADD GROUPING FOREIGN KEY ( <column name> [ , ... n ] )
        //          REFERENCES <parent schema table name> [ ( <column name> [ , ... n ] ) ]

        tableElementList.addTableElement((TableElementNode)
            nodeFactory.getNode(NodeTypes.FK_CONSTRAINT_DEFINITION_NODE,
                                 null,
                                 parentTable,
                                 childColumns,
                                 parentColumns,
                                 new int[] {StatementType.RA_NOACTION,StatementType.RA_NOACTION},
                                 Boolean.TRUE,
                                 parserContext));

        return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_TABLE_NODE,
                                                  childTable,
                                                  tableElementList,
                                                  new Character('\0'),
                                                  new int[] {DDLStatementNode.ADD_TYPE},
                                                  new int[]{0}, // not used
                                                  parserContext);
    }
|
    <DROP> <TABLE> childTable = qualifiedName()
    {
        // NB: Must be kept in sync with dropTableConstraintDefinition()
        // Equivalent to this statement:
        // ALTER TABLE <leaf schema table name> DROP GROUPING FOREIGN KEY

        tableElementList.addTableElement((TableElementNode)
            nodeFactory.getNode(NodeTypes.FK_CONSTRAINT_DEFINITION_NODE,
                                null,
                                ConstraintDefinitionNode.ConstraintType.DROP,
                                StatementType.DROP_DEFAULT,
                                Boolean.TRUE,
                                parserContext));

         return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_TABLE_NODE,
                                                   childTable,
                                                   tableElementList,
                                                   new Character('\0'),
                                                   new int[]{DDLStatementNode.DROP_TYPE},
                                                   new int[]{StatementType.DROP_DEFAULT},
                                                   parserContext);
        
    }
}

StatementNode
alterStatement() throws StandardException :
{
    StatementNode node;
    TableName tableName;
}
{
    <TABLE> tableName = qualifiedName() node = alterTableBody(tableName)
    {
        return node;
    }
|   
    <SERVER> node = alterServerBody()
    {
        return node;
    } 
|
    <GROUP> node = alterGroup()
    {
        return node;
    }
}

StatementNode
alterServerBody () throws StandardException:
{
    StatementNode sn;
    ValueNode sessionID;
    Token immediate = null;
    Token interrupt = null;
    Token disconnect = null;
    Token kill = null;
}
{
    <SET> sn = setConfigurationStatement() 
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_SERVER_NODE,
        					sn,
        					parserContext);
    }
|
    <SHUTDOWN>
    (
        [ immediate = <IMMEDIATE> ]
    )
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_SERVER_NODE,
                                                 new Boolean(immediate != null),
                                                 parserContext);
    }
|
    ( interrupt = <INTERRUPT> | disconnect = <DISCONNECT> | kill = <KILL>)
    <SESSION>
    sessionID = alterSessionID()
    {
    	return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_SERVER_NODE,
    						interrupt,
    						disconnect, 
    						kill,
    						sessionID,
    						parserContext);
    }
}

ValueNode
alterSessionID() throws StandardException:
{
    ValueNode valueNode;
}
{
    valueNode = intLiteral()
    {
        return valueNode;
    }
|
    <ALL>
    {
        return (ValueNode)nodeFactory.getNode(NodeTypes.DEFAULT_NODE,
                                              null,
                                              parserContext); 
    }
}

StatementNode
alterTableBody(TableName tableName) throws StandardException :
{
    StatementNode sn;
    char lockGranularity = '\0';
    String newTableName;
    TableElementList tableElementList = (TableElementList)
        nodeFactory.getNode(NodeTypes.TABLE_ELEMENT_LIST, parserContext);
    int[] changeType = new int[1];
    int[] behavior = new int[1];
    String indexName = null;
}
{
//insert special key before compress so that only internal SP can know
    <COMPRESS>
    (
        sn = inplaceCompress(tableName)
    |
        sn = sequentialCompress(tableName)
    )
    {
        return sn;
    }
|
//This means update the statistics of all the indexes on the table
    <ALL> <UPDATE> <STATISTICS>
    {
        //This will make sure that this ALTER TABLE...syntax can't be called directly.
        //This sql can only be generated internally (right now it is done for
        //syscs_util.SYSCS_UPDATE_STATISTICS procedure
        return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_TABLE_NODE,
                                                  tableName,
                                                  Boolean.TRUE,
                                                  null,
                                                  parserContext);
    }
|
//This means update the statistics of the index name supplied for the table
    <UPDATE> <STATISTICS>
    (
        indexName = identifier()
    )
    {
        //This will make sure that this ALTER TABLE...syntax can't be called directly.
        //This sql can only be generated internally (right now it is done for
        //syscs_util.SYSCS_UPDATE_STATISTICS procedure
        return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_TABLE_NODE,
                                                  tableName,
                                                  Boolean.FALSE,
                                                  indexName,
                                                  parserContext);
    }
|
    alterTableAction(tableElementList, changeType, behavior)
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_TABLE_NODE,
                                                  tableName,
                                                  tableElementList,
                                                  new Character(lockGranularity), // Not used, but we kind of nned it
                                                  changeType,                     // to make the method take 5 args
                                                  behavior,                       // The one that takes 4 args does
                                                  parserContext);                 // something else!
    }
}

StatementNode
inplaceCompress(TableName tableName) throws StandardException :
{
    Token purge = null;
    Token defragment = null;
    Token truncate = null;
}
{
    <INPLACE>
    (
        [ purge = <PURGE> ]
        [ defragment = <DEFRAGMENT> ]
        [ truncate = <TRUNCATE_END> ]
    )
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_TABLE_NODE,
                                                  tableName,
                                                  new Boolean(purge != null),
                                                  new Boolean(defragment != null),
                                                  new Boolean(truncate != null),
                                                  parserContext);
    }
}

StatementNode
sequentialCompress(TableName tableName) throws StandardException :
{
    Token tok = null;
}
{
    [ tok = <SEQUENTIAL> ]
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_TABLE_NODE,
                                                  tableName,
                                                  new Boolean(tok != null),
                                                  parserContext);
    }
}


void
alterTableAction(TableElementList tableElementList, int[] changeType, int[] behavior) 
        throws StandardException :
{
    TableElementNode tableElement;
    boolean hasAutoIncrement = false;
    DataTypeDescriptor  typeDescriptor;
    Token tok = null;
    String name;
    String newCName;
    TableName newName;
    long[] autoIncrementInfo = new long[4];
}
{
    <ADD>
    (
        LOOKAHEAD ( {getToken(1).kind == UNIQUE && getToken(2).kind == INDEX || getToken(1).kind == INDEX} )
        addIndex(tableElementList)
    |
        hasAutoIncrement = addColumnDefinition(tableElementList)
    |
        tableConstraintDefinition(tableElementList)
    )
    {
        if (hasAutoIncrement)
            //bug 5724 - auto increment columns not allowed in ALTER TABLE statement
            throw new StandardException("Auto increment column not allowed in ALTER TABLE");

        changeType[0] = DDLStatementNode.ADD_TYPE;
    }
|
    <ALTER> [ <COLUMN> ] name = identifier() 
    tableElement = columnAlterClause(name)
    {
        changeType[0] = DDLStatementNode.MODIFY_TYPE;
        tableElementList.addTableElement(tableElement);
    }
|
    <DROP>
    (
        LOOKAHEAD ( {getToken(1).kind == INDEX || getToken(1).kind == KEY } )
        tableElement = dropIndex()
    |
        tableElement = dropColumnDefinition(behavior)
    |
        tableElement = dropTableConstraintDefinition()
    )
    {
        changeType[0] = DDLStatementNode.DROP_TYPE;
        tableElementList.addTableElement(tableElement);
    }
|
    <RENAME>
    (
        LOOKAHEAD ( {getToken(1).kind == COLUMN} )
        <COLUMN> name = identifier() [<TO> | <AS>] newCName = identifier()
        {
            tableElement = (TableElementNode)nodeFactory.getNode(NodeTypes.AT_RENAME_COLUMN_NODE,
                                                                 name,
                                                                 newCName,
                                                                 parserContext);
        }
    |
        [<TABLE>] [<TO> | <AS>] newName = qualifiedName()
        {
            tableElement = (TableElementNode)nodeFactory.getNode(NodeTypes.AT_RENAME_NODE,
                                                                 newName,
                                                                 parserContext);
        }
    )
    {

        changeType[0] = DDLStatementNode.MODIFY_TYPE;
        tableElementList.addTableElement(tableElement);
    }
}

/*
 * Handle
 *
 *      ALTER TABLE tablename DROP [ COLUMN ] columnname [ CASCADE | RESTRICT ]
 */
TableElementNode
dropColumnDefinition(int []behavior) throws StandardException :
{
    String columnName;
    TableElementNode tableElement;
}
{
    [ <COLUMN> ] columnName = identifier()
    dropBehavior(behavior)
    {
        return (TableElementNode)nodeFactory.getNode(NodeTypes.DROP_COLUMN_NODE,
                                                     columnName, null,
                                                     null, null,
                                                     parserContext);
    }
}

TableElementNode
dropIndex() throws StandardException :
{
    String indexName;
    ExistenceCheck cond;
}
{
    (<INDEX> | <KEY>) cond = dropCondition() indexName = identifier()
    {
        return (TableElementNode)nodeFactory.getNode(NodeTypes.AT_DROP_INDEX_NODE,
                                                     indexName, // name
                                                     cond,      // existence 
                                                     parserContext);
    }
}

StorageLocation
getLocation() throws StandardException :
{
}
{
    <IN_MEMORY>
    {
        return StorageLocation.IN_MEMORY;
    }
|
    <BTREE>
    {
        return StorageLocation.BTREE;
    }
}

void
addIndex(TableElementList tableElementList) throws StandardException :
{
    boolean groupFormat = hasFeature(SQLParserFeature.GROUPING);

    ExistenceCheck cond;
    Boolean unique = Boolean.FALSE;
    String indexName;
    IndexColumnList indexColumnList = null;
    JoinNode.JoinType joinType = null;
    Properties properties = null;
    StorageLocation location = null;
}
{
    
    [unique = unique()]
    <INDEX>
    cond = createCondition()
    indexName = identifier()
     <LEFT_PAREN>
    ( LOOKAHEAD ( { groupFormat } )
      groupIndexItemList(indexColumnList = (IndexColumnList)nodeFactory.getNode(NodeTypes.INDEX_COLUMN_LIST, parserContext))
    |
      LOOKAHEAD ( { !groupFormat } )
      indexItemList(indexColumnList = (IndexColumnList)nodeFactory.getNode(NodeTypes.INDEX_COLUMN_LIST, parserContext))
    )
    <RIGHT_PAREN>
    [ LOOKAHEAD ( { groupFormat && getToken(1).kind == USING } )
      <USING> joinType = joinType() <JOIN> ]
    [ properties = propertyList(false) <CHECK_PROPERTIES>]
    [ <AS> location = getLocation() ]
    {
        
        tableElementList.addTableElement((TableElementNode)nodeFactory.getNode
                                                                (NodeTypes.AT_ADD_INDEX_NODE,
                                                                 cond,
                                                                 unique,
                                                                 indexName,
                                                                 indexColumnList,
                                                                 joinType,
                                                                 properties,
                                                                 location,
                                                                 parserContext));
    }
}

void
dropBehavior(int[] behavior) :
{
    int refBehavior = StatementType.DROP_DEFAULT;
}
{
    [ 
        <CASCADE> 
        {
            refBehavior = StatementType.DROP_CASCADE;
        }       
    | 
        <RESTRICT>
        {
            refBehavior = StatementType.DROP_RESTRICT;
        } 
    ]
    {
        behavior[0] = refBehavior;
    }
}


boolean
addColumnDefinition(TableElementList tableElementList) throws StandardException :
{
    boolean autoIncre;
    boolean hasAutoIncre;
}
{
    [ <COLUMN> ]
    hasAutoIncre = columnDefinition(tableElementList)
    ( <COMMA>
      LOOKAHEAD ( { notAlterActionFollows() } )
      (autoIncre = columnDefinition(tableElementList) { hasAutoIncre |= autoIncre;})
    )*
    {
        return hasAutoIncre;
    }
}

/*
 * Various variants of the ALTER TABLE ALTER COLUMN statement.
 *
 * By the type we get here, we've parsed
 *      ALTER TABLE tablename ALTER [COLUMN] columnname
 * and here we parse the remainder of the ALTER COLUMN clause, one of:
 *      SET DATA TYPE data_type
 *      SET INCREMENT BY increment_value
 *      RESTART WITH increment_restart_value
 *      [SET | WITH] DEFAULT default_value
 *          DROP DEFAULT
 *          [NOT] NULL
 */
TableElementNode
columnAlterClause(String columnName) throws StandardException :
{
    ValueNode    defaultNode;
    long[] autoIncrementInfo = new long[4];
    long autoIncrementIncrement = 1;
    long autoIncrementRestartWith = 1;
    DataTypeDescriptor typeDescriptor = null;
}
{
    LOOKAHEAD( { getToken(2).kind == DATA } )
    <SET> <DATA> <TYPE> typeDescriptor = dataTypeDDL()
    {
        return (TableElementNode)nodeFactory.getNode(NodeTypes.MODIFY_COLUMN_TYPE_NODE,
                                                     columnName, null,
                                                     typeDescriptor, null,
                                                     parserContext);
    }
|
    LOOKAHEAD( { getToken(2).kind == INCREMENT } )
    <SET> <INCREMENT> <BY> autoIncrementIncrement = exactNumber()
    {
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE;
        return (TableElementNode)nodeFactory.getNode(NodeTypes.MODIFY_COLUMN_DEFAULT_NODE,
                                                     columnName,
                                                     null, null, autoIncrementInfo,
                                                     parserContext);
    }
|
    <RESTART> <WITH> autoIncrementRestartWith = exactNumber()
    {
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = autoIncrementRestartWith;
        autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE;
        return (TableElementNode)nodeFactory.getNode(NodeTypes.MODIFY_COLUMN_DEFAULT_NODE,
                                                     columnName,
                                                     null, null, autoIncrementInfo,
                                                     parserContext);
    }
|
    LOOKAHEAD( { getToken(1).kind == WITH || getToken(1).kind == _DEFAULT ||
                 getToken(1).kind == GENERATED ||
                (getToken(1).kind == SET && (getToken(2).kind == _DEFAULT ||
                                             getToken(2).kind == GENERATED)) } )
    [<SET>] defaultNode = defaultClause(autoIncrementInfo, columnName)
    {
        return wrapAlterColumnDefaultValue(defaultNode,
                                           columnName,
                                           autoIncrementInfo);
    }
|
    <DROP> <_DEFAULT>
    {
        defaultNode = (ValueNode)nodeFactory.getNode(NodeTypes.UNTYPED_NULL_CONSTANT_NODE, parserContext);

        return wrapAlterColumnDefaultValue(defaultNode,
                                           columnName,
                                           autoIncrementInfo);
    }
|
    LOOKAHEAD( { getToken(1).kind == NULL } )
    <NULL>
    {
        // for a MODIFY column NULL clause form a modify_column node
        // with all null values. In a column definition a [NOT] NULL
        // column constraint is specified by setting the right value
        // in the nullability field of the data type but we don't have
        // a datatype here.
        return (TableElementNode)nodeFactory.getNode(NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE,
                                                     columnName, null, null, null,
                                                     parserContext);
    }
|
    LOOKAHEAD( { getToken(1).kind == NOT } )
    <NOT> <NULL>
    {
        // for a MODIFY column NOT NULL clause form a modify_column node
        // with all null values. In a column definition a [NOT] NULL
        // column constraint is specified by setting the right value
        // in the nullability field of the data type but we don't have
        // a datatype here.
        return (TableElementNode)nodeFactory.getNode(NodeTypes.MODIFY_COLUMN_CONSTRAINT_NOT_NULL_NODE,
                                                     columnName, null, null, null,
                                                     parserContext);
    }
}

TableElementNode
dropTableConstraintDefinition() throws StandardException :
{
    TableName constraintName = null;
    Token grouping = null;
}
{
    LOOKAHEAD( { getToken(1).kind == CONSTRAINT } )
    <CONSTRAINT> constraintName = qualifiedName()
    {
        return (TableElementNode)nodeFactory.getNode(NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                     constraintName,
                                                     ConstraintDefinitionNode.ConstraintType.DROP,
                                                     null,
                                                     null,
                                                     null,
                                                     null,
                                                     StatementType.DROP_DEFAULT,
                                                     parserContext);
    }
|
    LOOKAHEAD( { getToken(1).kind == PRIMARY } )
    <PRIMARY> <KEY>
    {
        return (TableElementNode)nodeFactory.getNode(NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                     null,
                                                     ConstraintDefinitionNode.ConstraintType.DROP,
                                                     null,
                                                     null,
                                                     null,
                                                     null,
                                                     StatementType.DROP_DEFAULT,
                                                     ConstraintDefinitionNode.ConstraintType.PRIMARY_KEY,
                                                     parserContext);
    }
|
    // NB: GROUPING case needs to be kept in sync with alterGroup()!
    LOOKAHEAD( { (getToken(1).kind == FOREIGN) || 
                 (groupConstructFollows(GROUPING) && (getToken(2).kind == FOREIGN)) } )
    [ grouping = <GROUPING> ] <FOREIGN> <KEY> [ constraintName = qualifiedName() ]
    {
        return (TableElementNode)nodeFactory.getNode(NodeTypes.FK_CONSTRAINT_DEFINITION_NODE,
                                                     constraintName,
                                                     ConstraintDefinitionNode.ConstraintType.DROP,
                                                     StatementType.DROP_DEFAULT,
                                                     (grouping == null) ? Boolean.FALSE : Boolean.TRUE,
                                                     parserContext);
    }
|
    LOOKAHEAD( { getToken(1).kind == UNIQUE } )
    <UNIQUE> constraintName = qualifiedName()
    {
        return (TableElementNode)nodeFactory.getNode(NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                     constraintName,
                                                     ConstraintDefinitionNode.ConstraintType.DROP,
                                                     null,
                                                     null,
                                                     null,
                                                     null,
                                                     StatementType.DROP_DEFAULT,
                                                     ConstraintDefinitionNode.ConstraintType.UNIQUE,
                                                     parserContext);
    }
|
    <CHECK> constraintName = qualifiedName()
    {
        return (TableElementNode)nodeFactory.getNode(NodeTypes.CONSTRAINT_DEFINITION_NODE,
                                                     constraintName,
                                                     ConstraintDefinitionNode.ConstraintType.DROP,
                                                     null,
                                                     null,
                                                     null,
                                                     null,
                                                     StatementType.DROP_DEFAULT,
                                                     ConstraintDefinitionNode.ConstraintType.CHECK,
                                                     parserContext);
    }
}

StatementNode
dropTableStatement() throws StandardException :
{
    TableName tableName;
    int[] behavior = new int[1];
    ExistenceCheck cond;
}
{
    <TABLE> cond = dropCondition() tableName = qualifiedName() dropBehavior(behavior)
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.DROP_TABLE_NODE,
                                                  tableName,
                                                  new Integer(behavior[0]),
                                                  cond,
                                                  parserContext);
    }
}

StatementNode
dropIndexStatement() throws StandardException :
{
    String indexName;
    TableName tableName[] = new TableName[1];
    ExistenceCheck cond;
}
{
    <INDEX> cond = dropCondition() indexName = indexName(tableName)
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.DROP_INDEX_NODE,
                                                  tableName[0],
                                                  indexName,
                                                  cond,
                                                  parserContext);
    }
}

StatementNode
dropAliasStatement() throws StandardException :
{
    TableName aliasName;
    ExistenceCheck cond;
}
{
    <PROCEDURE> cond = dropCondition() aliasName = qualifiedName() 
    {
        return dropAliasNode(aliasName, AliasInfo.Type.PROCEDURE, cond);
    }    
|        
    <FUNCTION> cond = dropCondition() aliasName = qualifiedName() 
    {
        return dropAliasNode(aliasName, AliasInfo.Type.FUNCTION, cond);
    }    
|    
    <SYNONYM> cond = dropCondition() aliasName = qualifiedName()
    {
        return dropAliasNode(aliasName, AliasInfo.Type.SYNONYM, cond);
    }
|    
    <TYPE> cond = dropCondition() aliasName = qualifiedName() <RESTRICT>
    {
        return dropAliasNode(aliasName, AliasInfo.Type.UDT, cond);
    }
}

StatementNode
dropViewStatement() throws StandardException :
{
    TableName viewName;
    ExistenceCheck cond;
}
{
    <VIEW> cond = dropCondition() viewName = qualifiedName() 
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.DROP_VIEW_NODE,
                                                  viewName,
                                                  cond,
                                                  parserContext);
    }
}

StatementNode
dropGroupStatement() throws StandardException :
{
    TableName groupName;
    ExistenceCheck cond;
}
{
    <GROUP> cond = dropCondition() groupName = qualifiedName()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.DROP_GROUP_NODE,
                                                   groupName,
                                                   cond,
                                                   parserContext);
    }
}

StatementNode
dropTriggerStatement() throws StandardException :
{
    TableName triggerName;
}
{
    <TRIGGER> triggerName = qualifiedName() 
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.DROP_TRIGGER_NODE,
                                                  triggerName,
                                                  parserContext);
    }
}

StatementNode
truncateStatement() throws StandardException :
{
    StatementNode statementNode;
}
{
    <TRUNCATE>
(
    statementNode = truncateTableStatement()
)
    {
        return statementNode;
    }
}

StatementNode
truncateTableStatement() throws StandardException :
{
    TableName tableName;
}
{
    <TABLE> tableName = qualifiedName() 
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.ALTER_TABLE_NODE,
                                                  tableName,
                                                  parserContext);
    }
}

StatementNode
grantStatement() throws StandardException :
{
    StatementNode node;
}
{
    /* TRIGGER is a non-reserved word, so it is allowed as role
     * identifier.  This gives a parser problem in determining if
     * a grant statement is a grant role or grant privilege
     * statement. In a grant privilege statement, all the other
     * grantable privileges are reserved keywords, except
     * TRIGGER. So, if we encounter GRANT TRIGGER, we need to look
     * one or two more tokens ahead to determine what kind of
     * grant statement we are seeing:
     *
     * privilege grant:
     *      grant trigger , <any of rest of privilege keywords>
     *      grant trigger on ..
     *      grant <any of rest of privilege keywords>
     * role grant:
     *      grant trigger to ..
     *      grant trigger, <NOT any of  rest of privilege keywords>
     *      grant <NOT any of rest of privilege keywords>
     */
    LOOKAHEAD( { getToken(1).kind == GRANT &&
                                 ((getToken(2).kind == TRIGGER &&
                                     ((getToken(3).kind == COMMA &&
                                         isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||
                                        getToken(3).kind == ON)) ||
                                    isPrivilegeKeywordExceptTrigger(getToken(2).kind)) } )
    <GRANT>
    (
        node = tableGrantStatement()
    |
        node = routineGrantStatement() 
    |
        node = usageGrantStatement()
    )
    {
        return node;
    }
|
    LOOKAHEAD( { getToken(1).kind == GRANT &&
                                 ((getToken(2).kind == TRIGGER &&
                                     ((getToken(3).kind == COMMA &&
                                         !isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||
                                        getToken(3).kind == TO)) ||
                                    !isPrivilegeKeywordExceptTrigger(getToken(2).kind)) } )
    <GRANT>
    ( node = roleGrantStatement() )
    {
        return node;
    }
}

StatementNode
tableGrantStatement() throws StandardException :
{
 PrivilegeNode privileges;
 List grantees;
}
{
    privileges = tablePrivileges()
    <TO> grantees = granteeList()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.GRANT_NODE,
                                                  privileges, grantees,
                                                  parserContext);
    }
}

PrivilegeNode tablePrivileges() throws StandardException :
{
    TablePrivilegesNode tablePrivilegesNode = null;
    TableName objectName = null;
}
{
    tablePrivilegesNode = tableActions()
    <ON> [ <TABLE> ] objectName = qualifiedName()
    {
        return (PrivilegeNode)nodeFactory.getNode(NodeTypes.PRIVILEGE_NODE,
                                                  PrivilegeNode.ObjectType.TABLE_PRIVILEGES,
                                                  objectName, tablePrivilegesNode,
                                                  parserContext);
    }
}

TablePrivilegesNode tableActions() throws StandardException :
{
    TablePrivilegesNode tableActionsNode = (TablePrivilegesNode)
        nodeFactory.getNode(NodeTypes.TABLE_PRIVILEGES_NODE, parserContext);
}
{
    <ALL> <PRIVILEGES>
    {
        tableActionsNode.addAll();
        return tableActionsNode;
    }
|
    tableAction(tableActionsNode) 
    ( <COMMA> tableAction( tableActionsNode) )*
    {
        return tableActionsNode;
    }
}

StatementNode
routineGrantStatement() throws StandardException :
{
    List grantees;
    RoutineDesignator routine;
}
{
    <EXECUTE> <ON> routine = routineDesignator()
    <TO> grantees = granteeList()
    {
        PrivilegeNode routinePrivilege = (PrivilegeNode)
                    nodeFactory.getNode(NodeTypes.PRIVILEGE_NODE,
                                        PrivilegeNode.ObjectType.ROUTINE_PRIVILEGES,
                                        routine, null,
                                        parserContext);
        return (StatementNode)nodeFactory.getNode(NodeTypes.GRANT_NODE,
                                                  routinePrivilege, grantees,
                                                  parserContext);
    }
}

StatementNode
usageGrantStatement() throws StandardException :
{
    List grantees;
    TableName name;
    PrivilegeNode.ObjectType objectType;
}
{
    <USAGE> <ON>
    objectType = usableObjects()
    name = qualifiedName()
    <TO> grantees = granteeList()
    {
                PrivilegeNode privilegeNode = (PrivilegeNode)nodeFactory.getNode(NodeTypes.PRIVILEGE_NODE,
                                                                                 objectType,
                                                                                 name,
                                                                                 PrivilegeNode.USAGE_PRIV,
                                                                                 Boolean.FALSE,
                                                                                 parserContext);
        return (StatementNode)nodeFactory.getNode(NodeTypes.GRANT_NODE,
                                                  privilegeNode,
                                                  grantees,
                                                  parserContext);
    }
}

PrivilegeNode.ObjectType
usableObjects() throws StandardException :
{}
{
    <SEQUENCE>
    {
        return PrivilegeNode.ObjectType.SEQUENCE_PRIVILEGES;
    }
|
    <TYPE>
    {
        return PrivilegeNode.ObjectType.UDT_PRIVILEGES;
    }
}

RoutineDesignator 
routineDesignator() throws StandardException :
{
 Token procOrFunction;
 TableName name;
 List paramTypeList = null;
}
{
    ( procOrFunction = <FUNCTION> | procOrFunction = <PROCEDURE> )
    name = qualifiedName()
    [ <LEFT_PAREN> paramTypeList = parameterTypeList() <RIGHT_PAREN> ]
    {
        return new RoutineDesignator(false,
                                     name,
                                     (procOrFunction.kind == FUNCTION),
                                     paramTypeList);
    }
}

List<DataTypeDescriptor>
parameterTypeList() throws StandardException :
{
    List<DataTypeDescriptor> list = new ArrayList<DataTypeDescriptor>();
    DataTypeDescriptor type;
}
{
    [ 
        type = catalogType()
        {
            list.add(type);
        }
     ( <COMMA> type = catalogType()
     {
         list.add(type);
     }
     )* 
     ]
     {
         return list;
     }
}

void 
tableAction(TablePrivilegesNode tablePrivilegesNode)    throws StandardException :
{
    ResultColumnList columnList = null;
}
{
    <SELECT> [ columnList = privilegeColumnList() ]
    {
        tablePrivilegesNode.addAction(TablePrivilegesNode.SELECT_ACTION, columnList);
    }
|
    <DELETE>
    {
        tablePrivilegesNode.addAction(TablePrivilegesNode.DELETE_ACTION, (ResultColumnList)null);
    }
|
    <INSERT>
    {
        tablePrivilegesNode.addAction(TablePrivilegesNode.INSERT_ACTION, (ResultColumnList)null);
    }
|
    <UPDATE> [ columnList = privilegeColumnList() ]
    {
        tablePrivilegesNode.addAction(TablePrivilegesNode.UPDATE_ACTION, columnList);
    }
|
    <REFERENCES> [ columnList = privilegeColumnList() ]
    {
        tablePrivilegesNode.addAction(TablePrivilegesNode.REFERENCES_ACTION, columnList);
    }
|
    <TRIGGER>
    {
        tablePrivilegesNode.addAction(TablePrivilegesNode.TRIGGER_ACTION, (ResultColumnList)null);
    }
}

ResultColumnList
privilegeColumnList() throws StandardException :
{
    ResultColumnList cl = (ResultColumnList)nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                                                parserContext);
}
{
    <LEFT_PAREN> columnNameList(cl) <RIGHT_PAREN>
    {
        return cl;
    }
}

List<String>
granteeList() throws StandardException :
{
List<String> list = new ArrayList<String>();
}
{
    grantee(list) 
    ( <COMMA> grantee(list) )*
    {
        return list;
    }
}

void
grantee(List<String> list)  throws StandardException :
{
    String str;
}
{
    str = identifier()
    {
        list.add(str);
    }
|
    <PUBLIC>
    {
        list.add(PUBLIC_AUTHORIZATION_ID);
    }
}

StatementNode
roleGrantStatement() throws StandardException :
{
    List rolesGranted;
    List grantees;
}
{
    /*
     * GRANT <rolename> {, <rolename>}* TO <authentication identifier>
     *                                  {, <authentication identifier>}*
     *
     * not implemented: WITH ADMIN OPTION, GRANTED BY clauses
     */
    rolesGranted = roleList()
    <TO> grantees = granteeList()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.GRANT_ROLE_NODE,
                                                  rolesGranted,
                                                  grantees,
                                                  parserContext);
    }
}

List<String> roleList() throws StandardException :
{
    List<String> list = new ArrayList<String>();
}
{
    roleElement(list) 
    ( <COMMA> roleElement(list) )*
    {
        return list;
    }
}

void
roleElement(List<String> list)  throws StandardException :
{
    String str;
}
{
    str = identifier()
    {
        list.add(str);
    }
}

StatementNode
revokeStatement() throws StandardException :
{
    StatementNode node;
}
{
    /* See look-ahead explanation in grantStatement.
     *
     * privilege revoke:
     *      revoke trigger , <any of rest of privilege keywords>
     *      revoke trigger on ..
     *      revoke <any of rest of privilege keywords>
     * role revoke:
     *      revoke trigger from ..
     *      revoke trigger, <NOT any of  rest of privilege keywords>
     *      revoke <NOT any of rest of privilege keywords>
     */
    LOOKAHEAD( { getToken(1).kind == REVOKE &&
                                 ((getToken(2).kind == TRIGGER &&
                                     ((getToken(3).kind == COMMA &&
                                         isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||
                                        getToken(3).kind == ON)) ||
                                    isPrivilegeKeywordExceptTrigger(getToken(2).kind)) } )
    <REVOKE>
    (
        node = tableRevokeStatement() 
    |
        node = routineRevokeStatement() 
    |
        node = usageRevokeStatement()
    )
    {
        return node;
    }
|
    LOOKAHEAD( { getToken(1).kind == REVOKE &&
                                 ((getToken(2).kind == TRIGGER &&
                                     ((getToken(3).kind == COMMA &&
                                         !isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||
                                        getToken(3).kind == FROM)) ||
                                    !isPrivilegeKeywordExceptTrigger(getToken(2).kind)) } )
    <REVOKE>
    ( node = roleRevokeStatement() )
    {
        return node;
    }
}

StatementNode
tableRevokeStatement() throws StandardException :
{
    PrivilegeNode privileges = null;
    List grantees;
}
{
    privileges = tablePrivileges()
    <FROM> grantees = granteeList()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.REVOKE_NODE,
                                                  privileges, grantees,
                                                  parserContext);
    }
}

StatementNode
routineRevokeStatement() throws StandardException :
{
    List grantees;
    RoutineDesignator routine = null;
}
{
    <EXECUTE> <ON> routine = routineDesignator()
    <FROM> grantees = granteeList() <RESTRICT>
        {
                PrivilegeNode routinePrivilege = (PrivilegeNode)
                    nodeFactory.getNode(NodeTypes.PRIVILEGE_NODE,
                                        PrivilegeNode.ObjectType.ROUTINE_PRIVILEGES,
                                        routine, null,
                                        parserContext);
                return (StatementNode)nodeFactory.getNode(NodeTypes.REVOKE_NODE,
                                                          routinePrivilege, grantees,
                                                          parserContext);
        }
}

StatementNode
usageRevokeStatement() throws StandardException :
{
    List grantees;
    TableName name;
    PrivilegeNode.ObjectType objectType;
}
{
    <USAGE> <ON>
    objectType = usableObjects()
    name = qualifiedName()
    <FROM> grantees = granteeList() <RESTRICT>
    {
        PrivilegeNode privilegeNode = (PrivilegeNode)nodeFactory.getNode(NodeTypes.PRIVILEGE_NODE,
                                                                         objectType,
                                                                         name,
                                                                         PrivilegeNode.USAGE_PRIV,
                                                                         Boolean.TRUE,
                                                                         parserContext);
        return (StatementNode)nodeFactory.getNode(NodeTypes.REVOKE_NODE,
                                                  privilegeNode,
                                                  grantees,
                                                  parserContext);
    }
}

StatementNode
roleRevokeStatement() throws StandardException :
{
    List rolesRevokeed;
    List grantees;
}
{
    rolesRevokeed = roleList()
    <FROM> grantees = granteeList()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.REVOKE_ROLE_NODE,
                                                  rolesRevokeed,
                                                  grantees,
                                                  parserContext);
    }
}

StatementNode
cursorStatement() throws StandardException :
{
    String name;
    StatementNode stmt;
    int count = 1;
    Token[] tokenHolder = new Token[1];
}
{
    <DECLARE> name = identifier() [<NO> <SCROLL>] <CURSOR>
    <FOR> stmt = declarableStatement(tokenHolder)
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.DECLARE_STATEMENT_NODE,
                                                  name, stmt,
                                                  parserContext);
    }
|
    <FETCH>
    [ 
      <NEXT>
    |
      count = uint_value()
    |
      <ALL> { count = -1; }
    ]
    [ <FROM> ]
    name = identifier()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.FETCH_STATEMENT_NODE,
                                                  name, count,
                                                  parserContext);
    }
|
    <CLOSE>
    name = identifier()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.CLOSE_STATEMENT_NODE,
                                                  name,
                                                  parserContext);
    }
|
    <PREPARE> name = identifier()
    <AS> stmt = proceduralStatement(tokenHolder)
    {
        stmt.setBeginOffset(tokenHolder[0].beginOffset);
        stmt.setEndOffset(getToken(0).endOffset);
        return (StatementNode)nodeFactory.getNode(NodeTypes.PREPARE_STATEMENT_NODE,
                                                  name, stmt,
                                                  parserContext);
    }
|
    <DEALLOCATE>
    name = identifier()
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.DEALLOCATE_STATEMENT_NODE,
                                                  name,
                                                  parserContext);
    }
}

StatementNode
declarableStatement(Token[] tokenHolder) throws StandardException :
{
    StatementNode stmt;
    tokenHolder[0] = getToken(1);
}
{
(
    stmt = proceduralStatement(tokenHolder)
|
    stmt = executeStatement()
)
    {
        stmt.setBeginOffset(tokenHolder[0].beginOffset);
        stmt.setEndOffset(getToken(0).endOffset);
        return stmt;
    }
}

StatementNode
executeStatement() throws StandardException :
{
    String name;
    List<ValueNode> params = new ArrayList<ValueNode>();
}
{
    <EXECUTE> name = identifier() [ methodCallParameterList(params) ]
    {
        ValueNodeList parameterList = (ValueNodeList)
            nodeFactory.getNode(NodeTypes.VALUE_NODE_LIST, 
                                parserContext);
        for (ValueNode param : params)
            parameterList.add(param);
        return (StatementNode)nodeFactory.getNode(NodeTypes.EXECUTE_STATEMENT_NODE,
                                                  name, parameterList,
                                                  parserContext);
    }
}

StatementNode
explainStatement() throws StandardException :
{
    StatementNode stmt;
    Token[] tokenHolder = new Token[1];
    ExplainStatementNode.Detail detail = ExplainStatementNode.Detail.NORMAL;
}
{
    <EXPLAIN> 
    [ detail = explainDetail() ]
    stmt = declarableStatement(tokenHolder)
    {
        return (StatementNode)nodeFactory.getNode(NodeTypes.EXPLAIN_STATEMENT_NODE,
                                                  stmt, detail,
                                                  parserContext);
    }
}

ExplainStatementNode.Detail
explainDetail() throws StandardException :
{
}
{
    <BRIEF>
    { return ExplainStatementNode.Detail.BRIEF; }
|        
    <VERBOSE>
    { return ExplainStatementNode.Detail.VERBOSE; }
}

StatementNode
copyStatement() throws StandardException :
{
    CopyStatementNode stmt;
}
{
    <COPY> stmt = copyStatementBase()
    [ [<WITH>] <LEFT_PAREN> copyOption(stmt)
      ( <COMMA> copyOption(stmt) )* 
      <RIGHT_PAREN> ]
    {
        return stmt;
    }
}

CopyStatementNode
copyStatementBase() throws StandardException :
{
    CopyStatementNode.Mode mode;
    TableName tableName = null;
    ResultColumnList columnList = null;
    SubqueryNode subquery = null;
    String filename = null;
}
{
(
    LOOKAHEAD( { getToken(1).kind == LEFT_PAREN && getToken(2).kind == SELECT } )
    subquery = derivedTable()
    <TO> ( filename = string() | <STDOUT> )
    { mode = CopyStatementNode.Mode.FROM_SUBQUERY; }
|
    tableName = qualifiedName()
    [ <LEFT_PAREN> columnList = insertColumnList() <RIGHT_PAREN> ]
    ( <TO> ( filename = string() | <STDOUT> )
       { mode = CopyStatementNode.Mode.FROM_TABLE; }
    | <FROM> ( filename = string() | <STDIN> )
       { mode = CopyStatementNode.Mode.TO_TABLE; }
    )
)
    {
        if (subquery != null)
            return (CopyStatementNode)nodeFactory.getNode(NodeTypes.COPY_STATEMENT_NODE,
                                                          mode, 
                                                          subquery, 
                                                          filename,
                                                          parserContext);
        else
            return (CopyStatementNode)nodeFactory.getNode(NodeTypes.COPY_STATEMENT_NODE,
                                                          mode, 
                                                          tableName, columnList, 
                                                          filename,
                                                          parserContext);
    }
}

void
copyOption(CopyStatementNode stmt) throws StandardException :
{
    String value;
    long lvalue;
    CopyStatementNode.Format format;
}
{
    <FORMAT> format = copyFormat()
    {
        stmt.setFormat(format);
    }
|
    <DELIMITER> value = string()
    {
        stmt.setDelimiter(value);
    }
|
    <NULL> value = string()
    {
        stmt.setNullString(value);
    }
|
    <HEADER> token = booleanLiteral()
    {
        stmt.setHeader(token.kind == TRUE);
    }
|
    <_QUOTE> value = string()
    {
        stmt.setQuote(value);
    }
|
    <ESCAPE> value = string()
    {
        stmt.setEscape(value);
    }
|
    <ENCODING> value = string()
    {
        stmt.setEncoding(value);
    }
|
    <COMMIT> lvalue = exactNumber() [<ROWS>]
    {
        stmt.setCommitFrequency(lvalue);
    }
}

CopyStatementNode.Format
copyFormat() throws StandardException :
{
}
{
    <CSV> { return CopyStatementNode.Format.CSV; }
|
    <MYSQL_DUMP> { return CopyStatementNode.Format.MYSQL_DUMP; }
}

String
internalIdentifier() throws StandardException :
{
    String str;
    Token tok;
}
{
    tok = <IDENTIFIER>
    {
        str = SQLToIdentifierCase(tok.image);
 
        // Remember last identifier token and whether it was delimited.
        nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
        lastTokenDelimitedIdentifier = Boolean.FALSE;
        nextToLastIdentifierToken = lastIdentifierToken;
        lastIdentifierToken = tok;
        return str;
    }
|
    str = delimitedIdentifier()
    {
        return str;
    }
|
    str = nonReservedKeyword()
    {
        return SQLToIdentifierCase(str);
    }
}

String
identifier() throws StandardException :
{
    String id;
}
{
    id = internalIdentifier()
    {
        parserContext.checkIdentifierLengthLimit(id);
        return id;
    }
}

// Same as above, but without length check, which caller will perform.
// This avoids errors too soon from Java name components that are too
// long to be SQL identifier components.
String
identifierDeferCheckLength() throws StandardException :
{
    String id;
}
{
    id = internalIdentifier()
    {
        return id;
    }
}

String
delimitedIdentifier() :
{
    String str;
    Token tok;
}
{
(
    tok = <DOUBLEQUOTED_IDENTIFIER>
    {
        // Strip quotes and correct interior ones.
        str = trimAndCompressQuotes(tok.image, DOUBLEQUOTES, false);
    }
|
    tok = <BACKQUOTED_IDENTIFIER>
    {
        str = trimAndCompressQuotes(tok.image, BACKQUOTES, false);
    }
)
    {
        // Remember last identifier token and whether it was delimited.
        nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
        lastTokenDelimitedIdentifier = Boolean.TRUE;
        nextToLastIdentifierToken = lastIdentifierToken;
        lastIdentifierToken = tok;
        return str;
    }
}

String
reservedKeyword() :
{
    Token tok;
}
{
    // NOTE: All reserved keywords have to be repeated here so that they
    // can still be part of a Java name.
(
    /* SQL92 reserved keywords */
  tok = <ADD>
| tok = <ALL>
| tok = <ALLOCATE>
| tok = <ALTER>
| tok = <AND>
| tok = <ANY>
| tok = <ARE>
| tok = <AS>
| tok = <AT>
| tok = <AUTHORIZATION>
| tok = <AVG>
| tok = <BEGIN>
| tok = <BETWEEN>
| tok = <BIT>
| tok = <BOTH>
| tok = <BY>
| tok = <CASCADED>
| tok = <CASE>
| tok = <CAST>
| tok = <CHAR>
| tok = <CHARACTER_LENGTH>
| tok = <CHAR_LENGTH>
| tok = <CHECK>
| tok = <CLOSE>
| tok = <COLLATE>
| tok = <COLUMN>
| tok = <COMMIT>
| tok = <CONNECT>
| tok = <CONNECTION>
| tok = <CONSTRAINT>
| tok = <CONTINUE>
| tok = <CONVERT>
| tok = <CORRESPONDING>
| tok = <CREATE>
| tok = <CROSS>
| tok = <CURRENT>
| tok = <CURRENT_DATE>
| tok = <CURRENT_TIME>
| tok = <CURRENT_TIMESTAMP>
| tok = <CURRENT_USER>
| tok = <CURSOR>
| tok = <DEALLOCATE>
| tok = <DEC>
| tok = <DECIMAL>
| tok = <DECLARE>
| tok = <_DEFAULT>
| tok = <DELETE>
| tok = <DESCRIBE>
| tok = <DISCONNECT>
| tok = <DISTINCT>
| tok = <DOUBLE>
| tok = <DROP>
| tok = <ELSE>
| tok = <END>
| tok = <ENDEXEC>
| tok = <ESCAPE>
| tok = <EXCEPT>
| tok = <EXEC>
| tok = <EXECUTE>
| tok = <EXISTS>
| tok = <EXTERNAL>
| tok = <FALSE>
| tok = <FETCH>
| tok = <FLOAT>
| tok = <FOR>
| tok = <FOREIGN>
| tok = <FROM>
| tok = <FULL>
| tok = <FUNCTION>
| tok = <GET>
| tok = <GET_CURRENT_CONNECTION>
| tok = <GLOBAL>
| tok = <GRANT>
| tok = <GROUP>
| tok = <GROUP_CONCAT>
| tok = <HAVING>
| tok = <HOUR>
| tok = <IDENTITY>
| tok = <IMMEDIATE>
| tok = <IN>
| tok = <INDEX>
| tok = <INDICATOR>
| tok = <INNER>
| tok = <INOUT>
| tok = <INPUT>
| tok = <INSENSITIVE>
| tok = <INSERT>
| tok = <INT>
| tok = <INTEGER>
| tok = <INTERSECT>
| tok = <INTERVAL>
| tok = <INTO>
| tok = <IS>
| tok = <JOIN>
| tok = <LEADING>
| tok = <LEFT>
| tok = <LIKE>
| tok = <LIMIT>
| tok = <LOWER>
| tok = <MATCH>
| tok = <MAX>
| tok = <MIN>
| tok = <MINUTE>
| tok = <NATIONAL>
| tok = <NATURAL>
| tok = <NCHAR>
| tok = <NVARCHAR> 
| tok = <NEXT>
| tok = <NO>
| tok = <NONE>
| tok = <NOT>
| tok = <NULL>
| tok = <NULLIF>
| tok = <NUMERIC>
| tok = <OCTET_LENGTH>
| tok = <OF>
| tok = <ON>
| tok = <ONLY>
| tok = <OPEN>
| tok = <OR>
| tok = <ORDER>
| tok = <OUT>
| tok = <OUTER>
| tok = <OUTPUT>
| tok = <OVERLAPS>
| tok = <PARTITION>
| tok = <PREPARE>
| tok = <PRIMARY>
| tok = <PROCEDURE>
| tok = <PUBLIC>
| tok = <REAL>
| tok = <REFERENCES>
| tok = <RESTRICT>
| tok = <RETURNING>
| tok = <REVOKE>
| tok = <RIGHT>
| tok = <ROLLBACK>
| tok = <ROWS>
| tok = <SCHEMA>
| tok = <SCROLL>
| tok = <SECOND>
| tok = <SELECT>
| tok = <SESSION_USER>
| tok = <SET>
| tok = <SMALLINT>
| tok = <SOME>
| tok = <SQL>
| tok = <SQLCODE>
| tok = <SQLERROR>
| tok = <SQLSTATE>
| tok = <STRAIGHT_JOIN>
| tok = <SUBSTRING>
| tok = <SUM>
| tok = <SYSTEM_USER>
| tok = <TABLE>
| tok = <TIMEZONE_HOUR>
| tok = <TIMEZONE_MINUTE>
| tok = <TO>
| tok = <TRAILING>
| tok = <TRANSLATE>
| tok = <TRANSLATION>
| tok = <TRUE>
| tok = <UNION>
| tok = <UNIQUE>
| tok = <UNKNOWN>
| tok = <UPDATE>
| tok = <UPPER>
| tok = <USER>
| tok = <USING>
| tok = <VALUES>
| tok = <VARCHAR>
| tok = <VARYING>
| tok = <WHENEVER>
| tok = <WHERE>
| tok = <WITH>
| tok = <YEAR>
    /* non-SQL92 reserved keywords */
| tok = <BOOLEAN>
| tok = <CALL>
| tok = <CURRENT_ROLE>
| tok = <CURRENT_SCHEMA>
| tok = <EXPLAIN>
| tok = <GROUPING>
| tok = <LTRIM>
| tok = <RTRIM>
| tok = <TRIM>
| tok = <SUBSTR>
| tok = <XML>
| tok = <XMLPARSE>
| tok = <XMLSERIALIZE>
| tok = <XMLEXISTS>
| tok = <XMLQUERY>
| tok = <Z_ORDER_LAT_LON>
)
    {
        // Remember whether last token was a delimited identifier
        nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
        lastTokenDelimitedIdentifier = Boolean.FALSE;
        return tok.image;
    }
}

String
nonReservedKeyword() :
{
    Token tok;
}
{
    // NOTE: All non-reserved keywords have to be repeated here so that
    // they may be used as normal identifiers.
(
  tok = <ABS>  
| tok = <ABSVAL>    
| tok = <ACTION>
| tok = <AFTER>
| tok = <ALWAYS>
| tok = <ASC> // SQL92 reserved, SQL2003 non-reserved
| tok = <ASSERTION> // SQL92 reserved, SQL2003 non-reserved
| tok = <BEFORE>
| tok = <BINARY>
| tok = <BLOB>
| tok = <BRIEF>
| tok = <BTREE>
| tok = <C>
| tok = <CALLED>
| tok = <CASCADE> // SQL92 reserved, SQL2003 non-reserved
| tok = <CHARACTER> // SQL92 reserved, SQL2003 non-reserved
| tok = <CHARACTERISTICS>
| tok = <CLASS>
| tok = <CLOB>
| tok = <COALESCE>
| tok = <COBOL>
| tok = <COLLATION> // SQL92 reserved, SQL2003 non-reserved
| tok = <COMMITTED>
| tok = <COMPRESS>
| tok = <CONCAT>
| tok = <CONSTRAINTS> // SQL92 reserved, SQL2003 non-reserved
| tok = <CONTAINS>
| tok = <CONTENT>
| tok = <COPY>
| tok = <COUNT>
| tok = <CS>
| tok = <CSV>
| tok = <CURDATE>
| tok = <CURTIME>
| tok = <D>
| tok = <DATA>
| tok = <DATABASE>
| tok = <DATE>
| tok = <DATETIME>
| tok = <DAY>
| tok = <DAY_HOUR>
| tok = <DAY_MICROSECOND>
| tok = <DAY_MINUTE>
| tok = <DAY_SECOND>
| tok = <DB2SQL>
| tok = <DEFERRABLE> // SQL92 reserved, SQL2003 non-reserved
| tok = <DEFERRED> // SQL92 reserved, SQL2003 non-reserved
| tok = <DEFRAGMENT>
| tok = <DELIMITER>
| tok = <DESC> // SQL92 reserved, SQL2003 non-reserved
| tok = <DIAGNOSTICS> // SQL92 reserved, SQL2003 non-reserved
| tok = <DIRTY>
| tok = <DIV>
| tok = <DOCUMENT>
| tok = <DUMMY>
| tok = <DYNAMIC>
| tok = <EACH>
| tok = <EMPTY>
| tok = <ENCODING>
| tok = <EXCEPTION> // SQL92 reserved, SQL2003 non-reserved
| tok = <EXCLUSIVE>
| tok = <EXTRACT>
| tok = <FIRST> // SQL92 reserved, SQL2003 non-reserved
| tok = <FN>
| tok = <FORCE>
| tok = <FORMAT>
| tok = <FORTRAN>
| tok = <FOUND> // SQL92 reserved, SQL2003 non-reserved
| tok = <FULL_TEXT>
| tok = <GENERATED>
| tok = <GO> // SQL92 reserved, SQL2003 non-reserved
| tok = <GOTO> // SQL92 reserved, SQL2003 non-reserved
| tok = <HEADER>
| tok = <HOUR_MICROSECOND>
| tok = <HOUR_MINUTE>
| tok = <HOUR_SECOND>
| tok = <IDENTITY_VAL_LOCAL>
| tok = <IF>
| tok = <IGNORE>
| tok = <INCREMENT>
| tok = <INITIAL>
| tok = <INITIALLY> // SQL92 reserved, SQL2003 non-reserved
| tok = <INPLACE>
| tok = <INTERRUPT>
| tok = <IN_MEMORY>
| tok = <ISOLATION> // SQL92 reserved, SQL2003 non-reserved
| tok = <JAVA>
| tok = <KEY> // SQL92 reserved, SQL2003 non-reserved
| tok = <KILL>
| tok = <LANGUAGE>
| tok = <LARGE>
| tok = <LAST> // SQL92 reserved, SQL2003 non-reserved
| tok = <LCASE>
| tok = <LENGTH>
| tok = <LEVEL>
| tok = <LOCATE>
| tok = <LOCK>
| tok = <LOCKS>
| tok = <LOCKSIZE>
| tok = <LOGGED>
| tok = <LONG>
| tok = <LONGBLOB>
| tok = <LONGINT>
| tok = <LONGTEXT>
| tok = <MEDIUMBLOB>
| tok = <MEDIUMINT>
| tok = <MEDIUMTEXT>
| tok = <MESSAGE_LOCALE>
| tok = <METHOD>
| tok = <MICROSECOND>
| tok = <MINUTE_MICROSECOND>
| tok = <MINUTE_SECOND>
| tok = <MOD>
| tok = <MODE>
| tok = <MODIFIES>
| tok = <MODIFY>
// SQL92 says MODULE is reserved, but we want it to be non-reserved.
| tok = <MODULE>
| tok = <_MORE>
| tok = <MONTH>
| tok = <MUMPS>
| tok = <MYSQL_DUMP>
| tok = <NAME>
| tok = <NCLOB>
| tok = <NEW>
| tok = <NEW_TABLE>
| tok = <NULLABLE>
| tok = <NULLS>
| tok = <NUMBER>
| tok = <OBJECT>
| tok = <OFF>
| LOOKAHEAD( { getToken(1).kind == OFFSET && !seeingOffsetClause() } )
  tok = <OFFSET>
| tok = <OJ>
| tok = <OLD>
| tok = <OLD_TABLE>
| tok = <OPTION> // SQL92 reserved, SQL2003 non-reserved
| tok = <OVER>
| tok = <PAD> // SQL92 reserved, SQL2003 non-reserved
| tok = <PARTIAL> // SQL92 reserved, SQL2003 non-reserved
| tok = <PASCAL>
| tok = <PASSING>
| tok = <PLI>
| tok = <POSITION>
| tok = <PRECISION>
| tok = <PRESERVE> // SQL92 reserved, SQL2003 non-reserved
| tok = <PRIOR> // SQL92 reserved, SQL2003 non-reserved
| tok = <PRIVILEGES> // SQL92 reserved, SQL2003 non-reserved
| tok = <PROPERTIES>
| tok = <PURGE>
| tok = <QUARTER>
| tok = <_QUOTE>
| tok = <READ> // SQL92 reserved, SQL2003 non-reserved
| tok = <READS>
| tok = <RELATIVE> // SQL92 reserved, SQL2003 non-reserved
| tok = <REF>
// SQL92 says RELEASE is reserved, but we want it to be non-reserved.
| tok = <RELEASE>
| tok = <RENAME>
| tok = <REPEATABLE>
| tok = <REPLACE>
| tok = <REFERENCING>
| tok = <RESET>
| tok = <RESTART>
| tok = <RESULT>
| tok = <RETAIN>
| tok = <RETURNS>
| tok = <ROLE>
| tok = <ROLLUP>
| tok = <ROW>
//| tok = <ROW_COUNT>
| tok = <ROWNUMBER>
| tok = <RR>
| tok = <RS>
| tok = <SCALE>
| tok = <SAVEPOINT>
| tok = <SECOND_MICROSECOND>
| tok = <SECURITY>
| tok = <SEPARATOR>
| tok = <SERVER>
| tok = <SEQUENCE>
| tok = <SEQUENTIAL>
| tok = <SERIALIZABLE>
| tok = <SESSION> // SQL92 reserved, SQL2003 non-reserved
| tok = <SETS>
| tok = <SHARE>
| tok = <SHUTDOWN>
| tok = <SPACE> // SQL92 reserved, SQL2003 non-reserved
| tok = <SPECIFIC>
| tok = <SQLID>
| tok = <SQL_TSI_DAY>
| tok = <SQL_TSI_FRAC_SECOND>
| tok = <SQL_TSI_HOUR>
| tok = <SQL_TSI_MINUTE>
| tok = <SQL_TSI_MONTH>
| tok = <SQL_TSI_QUARTER>
| tok = <SQL_TSI_SECOND>
| tok = <SQL_TSI_WEEK>
| tok = <SQL_TSI_YEAR>
| tok = <SQRT>
| tok = <STABILITY>
| tok = <START>
| tok = <STATEMENT>
| tok = <STATISTICS>
| tok = <STDIN>
| tok = <STDOUT>
| tok = <STRIP>
| tok = <STYLE>
| tok = <SYNONYM>
| tok = <T>
| tok = <TEMPORARY> // SQL92 reserved, SQL2003 non-reserved
| tok = <TEXT>
| tok = <THEN>
| tok = <TIME>
| tok = <TIMESTAMP>
| tok = <TIMESTAMPADD>
| tok = <TIMESTAMPDIFF>
| tok = <TINYBLOB>
| tok = <TINYINT>
| tok = <TINYTEXT>
| tok = <TRANSACTION> // SQL92 reserved, SQL2003 non-reserved
| tok = <TRIGGER>
| tok = <TRUNCATE>
| tok = <TRUNCATE_END>
| tok = <TS>
| tok = <TYPE>
| tok = <UCASE>
| tok = <UNCOMMITTED>
| tok = <UNSIGNED>
| tok = <UR>
| tok = <USAGE>
| tok = <USE>
| tok = <VIEW> // SQL92 reserved, SQL2003 non-reserved
| tok = <WORK> // SQL92 reserved, SQL2003 non-reserved
| tok = <WRITE> // SQL92 reserved, SQL2003 non-reserved
// SQL92 says VALUE is reserved, but we want it to be nonreserved.
| tok = <VALUE>
| tok = <VARBINARY>
| tok = <PARAMETER>
| tok = <VERBOSE>
| tok = <WEEK>
| tok = <WHEN>
| tok = <WHITESPACE>
| tok = <YEAR_MONTH>
)
    {
        // Remember last identifier token and whether it was delimited.
        nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
        lastTokenDelimitedIdentifier = Boolean.FALSE;
        nextToLastIdentifierToken = lastIdentifierToken;
        lastIdentifierToken = tok;
        return tok.image;
    }
}

String
caseSensitiveIdentifierPlusReservedWords() :
{
    String str;
}
{
    str = caseSensitiveIdentifier()
    {
        return str;
    }
|
    str = reservedKeyword()
    {
        return str;
    }
}

String
caseInsensitiveIdentifierPlusReservedWords() throws StandardException :
{
    String str;
}
{
    str = identifier()
    {
        return str;
    }
|
    str = reservedKeyword()
    {
        return SQLToIdentifierCase(str);
    }
}

String
caseSensitiveIdentifier() :
{
    String  str;
    Token       tok;
}
{
    tok = <IDENTIFIER>
    {
        // Remember whether last token was a delimited identifier.
        nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
        lastTokenDelimitedIdentifier = Boolean.FALSE;
        return tok.image;
    }
|
    str = delimitedIdentifier()
    {
        return str;
    }
|
    str = nonReservedKeyword()
    {
        return str;
    }
}

void
groupIndexItemList(IndexColumnList columnList) throws StandardException :
{}
{
    LOOKAHEAD( { getToken(1).kind == FULL_TEXT && getToken(2).kind == LEFT_PAREN } )
    fullTextColumnItemList(columnList)
|
    groupIndexItem(columnList) 
    ( <COMMA> groupIndexItem(columnList) )*
}

void groupIndexItem(IndexColumnList columnList) throws StandardException :
{
    int latPosition;
}
{
    (
      <Z_ORDER_LAT_LON>
      <LEFT_PAREN>
      { latPosition = columnList.size(); }
      unorderedGroupIndexColumnItem(columnList)
      <COMMA>
      unorderedGroupIndexColumnItem(columnList)
      <RIGHT_PAREN>
      {
          columnList.applyFunction(IndexColumnList.FunctionType.Z_ORDER_LAT_LON,
                                   latPosition,
                                   2);
      }
    )
    |
      groupIndexColumnItem(columnList)
}

void fullTextColumnItemList(IndexColumnList columnList) throws StandardException :
{
}
{
      <FULL_TEXT> <LEFT_PAREN>
      groupIndexColumnItem(columnList)
      ( <COMMA> groupIndexColumnItem(columnList) )*
      <RIGHT_PAREN>
      {
          columnList.applyFunction(IndexColumnList.FunctionType.FULL_TEXT,
                                   0, columnList.size());
      }
}

void
groupIndexColumnItem(IndexColumnList columnList) throws StandardException :
{
    boolean asc = true;
    ColumnReference groupIndexColumnName;
}
{
    groupIndexColumnName = groupIndexColumnName(columnList)
    [ <ASC> | <DESC> { asc = false; } ]
    {
        IndexColumn indexColumn = (IndexColumn)
            nodeFactory.getNode(NodeTypes.INDEX_COLUMN,
                                groupIndexColumnName.getTableNameNode(),
                                groupIndexColumnName.getColumnName(),
                                asc ? Boolean.TRUE : Boolean.FALSE,
                                parserContext);
        columnList.add(indexColumn);
    }
}

void
unorderedGroupIndexColumnItem(IndexColumnList columnList) throws StandardException :
{
    ColumnReference groupIndexColumnName;
}
{
    groupIndexColumnName = groupIndexColumnName(columnList)
    {
        IndexColumn indexColumn = (IndexColumn)
            nodeFactory.getNode(NodeTypes.INDEX_COLUMN,
                                groupIndexColumnName.getTableNameNode(),
                                groupIndexColumnName.getColumnName(),
                                Boolean.TRUE,
                                parserContext);
        columnList.add(indexColumn);
    }
}

ColumnReference
groupIndexColumnName(IndexColumnList columnList) throws StandardException :
{
    String firstName;
    String secondName = null;
    String thirdName = null;
}
{
    firstName = identifierDeferCheckLength()
    [ LOOKAHEAD( { getToken(1).kind == PERIOD } )
      <PERIOD>
      secondName = identifierDeferCheckLength()
      [ LOOKAHEAD( { getToken(1).kind == PERIOD } )
        <PERIOD>
        thirdName = identifierDeferCheckLength() ] ]
    {
        if (secondName == null) {
            thirdName = firstName;
            firstName = null;
        }
        else if (thirdName == null) {
            thirdName = secondName;
            secondName = firstName;
            firstName = null;
        }
        if (firstName != null)
            parserContext.checkIdentifierLengthLimit(firstName);
        if (secondName != null)
            parserContext.checkIdentifierLengthLimit(secondName);
        parserContext.checkIdentifierLengthLimit(thirdName);
        TableName tableName = null;
        if (secondName != null)
            tableName = (TableName)nodeFactory.getNode(NodeTypes.TABLE_NAME,
                                                       firstName,
                                                       secondName,
                                                       new Integer(nextToLastIdentifierToken.beginOffset),
                                                       new Integer(nextToLastIdentifierToken.endOffset),
                                                       parserContext);
        return (ColumnReference)nodeFactory.getNode(NodeTypes.COLUMN_REFERENCE,
                                                    thirdName,
                                                    tableName,
                                                    new Integer(lastIdentifierToken.beginOffset),
                                                    new Integer(lastIdentifierToken.endOffset),
                                                    parserContext);
    }
}
